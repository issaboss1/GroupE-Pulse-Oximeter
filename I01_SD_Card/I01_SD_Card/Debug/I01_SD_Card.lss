
I01_SD_Card.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00002aa8  00002000  00002000  00002000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .ARM.exidx    00000008  00004aa8  00004aa8  00004aa8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .relocate     0000043c  20000000  00004ab0  00010000  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  3 .bss          000006a8  2000043c  00004eec  0001043c  2**2
                  ALLOC
  4 .stack        00002004  20000ae4  00005594  0001043c  2**0
                  ALLOC
  5 .ARM.attributes 00000028  00000000  00000000  0001043c  2**0
                  CONTENTS, READONLY
  6 .comment      00000059  00000000  00000000  00010464  2**0
                  CONTENTS, READONLY
  7 .debug_info   00011b3c  00000000  00000000  000104bd  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00001361  00000000  00000000  00021ff9  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_loc    000056de  00000000  00000000  0002335a  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_aranges 00000368  00000000  00000000  00028a38  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000360  00000000  00000000  00028da0  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_macro  00013eee  00000000  00000000  00029100  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   00004c5a  00000000  00000000  0003cfee  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    00074986  00000000  00000000  00041c48  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_frame  00000b58  00000000  00000000  000b65d0  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00002000 <exception_table>:
    2000:	e8 2a 00 20 39 24 00 00 35 24 00 00 35 24 00 00     .*. 9$..5$..5$..
	...
    202c:	35 24 00 00 00 00 00 00 00 00 00 00 35 24 00 00     5$..........5$..
    203c:	35 24 00 00 35 24 00 00 35 24 00 00 35 24 00 00     5$..5$..5$..5$..
    204c:	35 24 00 00 35 24 00 00 35 24 00 00 35 24 00 00     5$..5$..5$..5$..
    205c:	35 24 00 00 35 24 00 00 35 24 00 00 35 24 00 00     5$..5$..5$..5$..
    206c:	35 24 00 00 35 24 00 00 35 24 00 00 35 24 00 00     5$..5$..5$..5$..
    207c:	35 24 00 00 35 24 00 00 35 24 00 00 35 24 00 00     5$..5$..5$..5$..
    208c:	35 24 00 00 35 24 00 00 00 00 00 00 00 00 00 00     5$..5$..........
    209c:	35 24 00 00 35 24 00 00 35 24 00 00 35 24 00 00     5$..5$..5$..5$..
    20ac:	35 24 00 00 00 00 00 00                             5$......

000020b4 <__do_global_dtors_aux>:
    20b4:	b510      	push	{r4, lr}
    20b6:	4c06      	ldr	r4, [pc, #24]	; (20d0 <__do_global_dtors_aux+0x1c>)
    20b8:	7823      	ldrb	r3, [r4, #0]
    20ba:	2b00      	cmp	r3, #0
    20bc:	d107      	bne.n	20ce <__do_global_dtors_aux+0x1a>
    20be:	4b05      	ldr	r3, [pc, #20]	; (20d4 <__do_global_dtors_aux+0x20>)
    20c0:	2b00      	cmp	r3, #0
    20c2:	d002      	beq.n	20ca <__do_global_dtors_aux+0x16>
    20c4:	4804      	ldr	r0, [pc, #16]	; (20d8 <__do_global_dtors_aux+0x24>)
    20c6:	e000      	b.n	20ca <__do_global_dtors_aux+0x16>
    20c8:	bf00      	nop
    20ca:	2301      	movs	r3, #1
    20cc:	7023      	strb	r3, [r4, #0]
    20ce:	bd10      	pop	{r4, pc}
    20d0:	2000043c 	.word	0x2000043c
    20d4:	00000000 	.word	0x00000000
    20d8:	00004ab0 	.word	0x00004ab0

000020dc <frame_dummy>:
    20dc:	4b08      	ldr	r3, [pc, #32]	; (2100 <frame_dummy+0x24>)
    20de:	b510      	push	{r4, lr}
    20e0:	2b00      	cmp	r3, #0
    20e2:	d003      	beq.n	20ec <frame_dummy+0x10>
    20e4:	4907      	ldr	r1, [pc, #28]	; (2104 <frame_dummy+0x28>)
    20e6:	4808      	ldr	r0, [pc, #32]	; (2108 <frame_dummy+0x2c>)
    20e8:	e000      	b.n	20ec <frame_dummy+0x10>
    20ea:	bf00      	nop
    20ec:	4807      	ldr	r0, [pc, #28]	; (210c <frame_dummy+0x30>)
    20ee:	6803      	ldr	r3, [r0, #0]
    20f0:	2b00      	cmp	r3, #0
    20f2:	d100      	bne.n	20f6 <frame_dummy+0x1a>
    20f4:	bd10      	pop	{r4, pc}
    20f6:	4b06      	ldr	r3, [pc, #24]	; (2110 <frame_dummy+0x34>)
    20f8:	2b00      	cmp	r3, #0
    20fa:	d0fb      	beq.n	20f4 <frame_dummy+0x18>
    20fc:	4798      	blx	r3
    20fe:	e7f9      	b.n	20f4 <frame_dummy+0x18>
    2100:	00000000 	.word	0x00000000
    2104:	20000440 	.word	0x20000440
    2108:	00004ab0 	.word	0x00004ab0
    210c:	00004ab0 	.word	0x00004ab0
    2110:	00000000 	.word	0x00000000

00002114 <AppInit>:
 * Note:            This was taken from the _00_LED_ON provided by
 *                  Microchip Technology Inc. 
 *
 ******************************************************************************/
void AppInit(void)
{
    2114:	b510      	push	{r4, lr}
	/*	Clock initialization (CPU, AHB, APBx, Asynchronous Peripheral Clocks)
		The System RC Oscillator (RCSYS) provides the source for the main clock
		at chip startup. It is set to 1MHz.
	*/
	ClocksInit();
    2116:	4b04      	ldr	r3, [pc, #16]	; (2128 <AppInit+0x14>)
    2118:	4798      	blx	r3
	
	// Assign SS as OUTPUT
	REG_PORT_DIR0 = PORT_PA08;
    211a:	2380      	movs	r3, #128	; 0x80
    211c:	005b      	lsls	r3, r3, #1
    211e:	4a03      	ldr	r2, [pc, #12]	; (212c <AppInit+0x18>)
    2120:	6013      	str	r3, [r2, #0]
	
	// Set SS OFF
	REG_PORT_OUTCLR0 = PORT_PA08;
    2122:	4a03      	ldr	r2, [pc, #12]	; (2130 <AppInit+0x1c>)
    2124:	6013      	str	r3, [r2, #0]
} // AppInit()
    2126:	bd10      	pop	{r4, pc}
    2128:	0000231d 	.word	0x0000231d
    212c:	41004400 	.word	0x41004400
    2130:	41004414 	.word	0x41004414

00002134 <AppRun>:
 *
 * Note:
 *
 ***************************************************************************/
void AppRun(void)
{
    2134:	b570      	push	{r4, r5, r6, lr}
    2136:	b09a      	sub	sp, #104	; 0x68
	// Initialize the UART at 9600 baud
	UART3_Init(9600);
    2138:	2096      	movs	r0, #150	; 0x96
    213a:	0180      	lsls	r0, r0, #6
    213c:	4b4c      	ldr	r3, [pc, #304]	; (2270 <AppRun+0x13c>)
    213e:	4798      	blx	r3
	delay_ms(500);
    2140:	4e4c      	ldr	r6, [pc, #304]	; (2274 <AppRun+0x140>)
    2142:	0030      	movs	r0, r6
    2144:	4d4c      	ldr	r5, [pc, #304]	; (2278 <AppRun+0x144>)
    2146:	47a8      	blx	r5
	
	// Initialize SPI
	UART3_Write_Text("Initializing SPI in slow mode\n");
    2148:	484c      	ldr	r0, [pc, #304]	; (227c <AppRun+0x148>)
    214a:	4c4d      	ldr	r4, [pc, #308]	; (2280 <AppRun+0x14c>)
    214c:	47a0      	blx	r4
	SPI_Initialize_Slow();
    214e:	4b4d      	ldr	r3, [pc, #308]	; (2284 <AppRun+0x150>)
    2150:	4798      	blx	r3
	UART3_Write_Text("SPI initialization done\n");
    2152:	484d      	ldr	r0, [pc, #308]	; (2288 <AppRun+0x154>)
    2154:	47a0      	blx	r4
	delay_ms(500);
    2156:	0030      	movs	r0, r6
    2158:	47a8      	blx	r5
	//////////////////////////////////////////////////////////////////////////
	// Writing to File
	//////////////////////////////////////////////////////////////////////////
	
	// Start to Init the SD Card
	UART3_Write_Text("Starting SD card initialization\n");
    215a:	484c      	ldr	r0, [pc, #304]	; (228c <AppRun+0x158>)
    215c:	47a0      	blx	r4
	
	UART3_Write_Text("Hello how are u?\n");
    215e:	484c      	ldr	r0, [pc, #304]	; (2290 <AppRun+0x15c>)
    2160:	47a0      	blx	r4
	
	
	
	// Initialize the SD Card
    if (SDCard_Init() != 0) {
    2162:	4b4c      	ldr	r3, [pc, #304]	; (2294 <AppRun+0x160>)
    2164:	4798      	blx	r3
    2166:	2800      	cmp	r0, #0
    2168:	d000      	beq.n	216c <AppRun+0x38>
    216a:	e7fe      	b.n	216a <AppRun+0x36>
		//UART3_Write_Text("SD card initialization failed\n");
		while (1);
	}
	UART3_Write_Text("SD card initialization done\n");
    216c:	484a      	ldr	r0, [pc, #296]	; (2298 <AppRun+0x164>)
    216e:	4c44      	ldr	r4, [pc, #272]	; (2280 <AppRun+0x14c>)
    2170:	47a0      	blx	r4
	
	// Start to mount the SD card
	UART3_Write_Text("Mounting file system\n");
    2172:	484a      	ldr	r0, [pc, #296]	; (229c <AppRun+0x168>)
    2174:	47a0      	blx	r4
	
	// Mount the file
	FR = f_mount(&fs, data_file, 0);
    2176:	2200      	movs	r2, #0
    2178:	4949      	ldr	r1, [pc, #292]	; (22a0 <AppRun+0x16c>)
    217a:	484a      	ldr	r0, [pc, #296]	; (22a4 <AppRun+0x170>)
    217c:	4b4a      	ldr	r3, [pc, #296]	; (22a8 <AppRun+0x174>)
    217e:	4798      	blx	r3
    2180:	4d4a      	ldr	r5, [pc, #296]	; (22ac <AppRun+0x178>)
    2182:	7028      	strb	r0, [r5, #0]
	
	// Finish Mounting
	UART3_Write_Text("File system mounted\n");
    2184:	484a      	ldr	r0, [pc, #296]	; (22b0 <AppRun+0x17c>)
    2186:	47a0      	blx	r4
	
	// Error with mount
	if (FR) {
    2188:	782b      	ldrb	r3, [r5, #0]
    218a:	2b00      	cmp	r3, #0
    218c:	d003      	beq.n	2196 <AppRun+0x62>
		UART3_Write_Text("Error mounting file system\n");
    218e:	4849      	ldr	r0, [pc, #292]	; (22b4 <AppRun+0x180>)
    2190:	4b3b      	ldr	r3, [pc, #236]	; (2280 <AppRun+0x14c>)
    2192:	4798      	blx	r3
    2194:	e7fe      	b.n	2194 <AppRun+0x60>
		while (1);
	}
	
	// Start Open
	UART3_Write_Text("Opening file for writing\n");
    2196:	4848      	ldr	r0, [pc, #288]	; (22b8 <AppRun+0x184>)
    2198:	4b39      	ldr	r3, [pc, #228]	; (2280 <AppRun+0x14c>)
    219a:	4798      	blx	r3
	
	// Open the SD Card for Writing
	FR = f_open(&fil, data_file, FA_WRITE | FA_OPEN_ALWAYS);
    219c:	2212      	movs	r2, #18
    219e:	4940      	ldr	r1, [pc, #256]	; (22a0 <AppRun+0x16c>)
    21a0:	4846      	ldr	r0, [pc, #280]	; (22bc <AppRun+0x188>)
    21a2:	4b47      	ldr	r3, [pc, #284]	; (22c0 <AppRun+0x18c>)
    21a4:	4798      	blx	r3
    21a6:	4b41      	ldr	r3, [pc, #260]	; (22ac <AppRun+0x178>)
    21a8:	7018      	strb	r0, [r3, #0]
	
	// Check if the file was opened successfully
	if (FR) {
    21aa:	2800      	cmp	r0, #0
    21ac:	d003      	beq.n	21b6 <AppRun+0x82>
		UART3_Write_Text("Error opening file\n");
    21ae:	4845      	ldr	r0, [pc, #276]	; (22c4 <AppRun+0x190>)
    21b0:	4b33      	ldr	r3, [pc, #204]	; (2280 <AppRun+0x14c>)
    21b2:	4798      	blx	r3
    21b4:	e7fe      	b.n	21b4 <AppRun+0x80>
		while (1);
	}
	UART3_Write_Text("File opened successfully\n");
    21b6:	4844      	ldr	r0, [pc, #272]	; (22c8 <AppRun+0x194>)
    21b8:	4c31      	ldr	r4, [pc, #196]	; (2280 <AppRun+0x14c>)
    21ba:	47a0      	blx	r4
	
	// Open File to write some CSV Data
	UART3_Write_Text("Writing to file\n");
    21bc:	4843      	ldr	r0, [pc, #268]	; (22cc <AppRun+0x198>)
    21be:	47a0      	blx	r4
	FR = f_write(&fil, "Data1 ,Data2 ,Data3 ,Data4 \r\n", 29, &bw); 
    21c0:	4b43      	ldr	r3, [pc, #268]	; (22d0 <AppRun+0x19c>)
    21c2:	221d      	movs	r2, #29
    21c4:	4943      	ldr	r1, [pc, #268]	; (22d4 <AppRun+0x1a0>)
    21c6:	483d      	ldr	r0, [pc, #244]	; (22bc <AppRun+0x188>)
    21c8:	4c43      	ldr	r4, [pc, #268]	; (22d8 <AppRun+0x1a4>)
    21ca:	47a0      	blx	r4
    21cc:	4b37      	ldr	r3, [pc, #220]	; (22ac <AppRun+0x178>)
    21ce:	7018      	strb	r0, [r3, #0]
	
	// Check for writing error
	if (FR) {
    21d0:	2800      	cmp	r0, #0
    21d2:	d003      	beq.n	21dc <AppRun+0xa8>
		UART3_Write_Text("Error writing to file\n");
    21d4:	4841      	ldr	r0, [pc, #260]	; (22dc <AppRun+0x1a8>)
    21d6:	4b2a      	ldr	r3, [pc, #168]	; (2280 <AppRun+0x14c>)
    21d8:	4798      	blx	r3
    21da:	e7fe      	b.n	21da <AppRun+0xa6>
		while (1);
	}
	UART3_Write_Text("Writing completed\n");
    21dc:	4840      	ldr	r0, [pc, #256]	; (22e0 <AppRun+0x1ac>)
    21de:	4c28      	ldr	r4, [pc, #160]	; (2280 <AppRun+0x14c>)
    21e0:	47a0      	blx	r4
	
	// Close the file
	UART3_Write_Text("Closing file\n");
    21e2:	4840      	ldr	r0, [pc, #256]	; (22e4 <AppRun+0x1b0>)
    21e4:	47a0      	blx	r4
	FR = f_close(&fil);
    21e6:	4835      	ldr	r0, [pc, #212]	; (22bc <AppRun+0x188>)
    21e8:	4b3f      	ldr	r3, [pc, #252]	; (22e8 <AppRun+0x1b4>)
    21ea:	4798      	blx	r3
    21ec:	4b2f      	ldr	r3, [pc, #188]	; (22ac <AppRun+0x178>)
    21ee:	7018      	strb	r0, [r3, #0]
	
	// Check for closing error
	if (FR) {
    21f0:	2800      	cmp	r0, #0
    21f2:	d003      	beq.n	21fc <AppRun+0xc8>
		UART3_Write_Text("Error closing file\n");
    21f4:	483d      	ldr	r0, [pc, #244]	; (22ec <AppRun+0x1b8>)
    21f6:	4b22      	ldr	r3, [pc, #136]	; (2280 <AppRun+0x14c>)
    21f8:	4798      	blx	r3
    21fa:	e7fe      	b.n	21fa <AppRun+0xc6>
		while (1);
	}
	UART3_Write_Text("File closed successfully\n");
    21fc:	483c      	ldr	r0, [pc, #240]	; (22f0 <AppRun+0x1bc>)
    21fe:	4c20      	ldr	r4, [pc, #128]	; (2280 <AppRun+0x14c>)
    2200:	47a0      	blx	r4
	
    UART3_Write_Text("Successful Write File Done!\n");
    2202:	483c      	ldr	r0, [pc, #240]	; (22f4 <AppRun+0x1c0>)
    2204:	47a0      	blx	r4

    //////////////////////////////////////////////////////////////////////////
	// Reading Files
	//////////////////////////////////////////////////////////////////////////
	UART3_Write_Text("Starting to read file\n");
    2206:	483c      	ldr	r0, [pc, #240]	; (22f8 <AppRun+0x1c4>)
    2208:	47a0      	blx	r4
	
    // Open the SD Card for reading
    FR = f_open(&fil, data_file, FA_READ);
    220a:	2201      	movs	r2, #1
    220c:	4924      	ldr	r1, [pc, #144]	; (22a0 <AppRun+0x16c>)
    220e:	482b      	ldr	r0, [pc, #172]	; (22bc <AppRun+0x188>)
    2210:	4b2b      	ldr	r3, [pc, #172]	; (22c0 <AppRun+0x18c>)
    2212:	4798      	blx	r3
    2214:	4b25      	ldr	r3, [pc, #148]	; (22ac <AppRun+0x178>)
    2216:	7018      	strb	r0, [r3, #0]
	
    // Check if the file was opened successfully
    if (FR) {
    2218:	2800      	cmp	r0, #0
    221a:	d003      	beq.n	2224 <AppRun+0xf0>
        UART3_Write_Text("Error opening file for reading\n");
    221c:	4837      	ldr	r0, [pc, #220]	; (22fc <AppRun+0x1c8>)
    221e:	4b18      	ldr	r3, [pc, #96]	; (2280 <AppRun+0x14c>)
    2220:	4798      	blx	r3
    2222:	e7fe      	b.n	2222 <AppRun+0xee>
        while (1);
    }
    UART3_Write_Text("File opened for reading\n");
    2224:	4836      	ldr	r0, [pc, #216]	; (2300 <AppRun+0x1cc>)
    2226:	4c16      	ldr	r4, [pc, #88]	; (2280 <AppRun+0x14c>)
    2228:	47a0      	blx	r4
	
	// Print Read Contents
	UART3_Write_Text("The file contains: \n");
    222a:	4836      	ldr	r0, [pc, #216]	; (2304 <AppRun+0x1d0>)
    222c:	47a0      	blx	r4
	char line[100]; /* Line buffer */
	
	/* Read every line and display it */
	while (f_gets(line, sizeof line, &fil)) {
    222e:	4d23      	ldr	r5, [pc, #140]	; (22bc <AppRun+0x188>)
    2230:	4c35      	ldr	r4, [pc, #212]	; (2308 <AppRun+0x1d4>)
    2232:	002a      	movs	r2, r5
    2234:	2164      	movs	r1, #100	; 0x64
    2236:	a801      	add	r0, sp, #4
    2238:	47a0      	blx	r4
    223a:	2800      	cmp	r0, #0
    223c:	d10f      	bne.n	225e <AppRun+0x12a>
		UART3_Write_Text(line);
	}
	
	UART3_Write_Text("Reading completed\n");
    223e:	4833      	ldr	r0, [pc, #204]	; (230c <AppRun+0x1d8>)
    2240:	4c0f      	ldr	r4, [pc, #60]	; (2280 <AppRun+0x14c>)
    2242:	47a0      	blx	r4
	
	// Close the file
	UART3_Write_Text("Closing file after reading\n");
    2244:	4832      	ldr	r0, [pc, #200]	; (2310 <AppRun+0x1dc>)
    2246:	47a0      	blx	r4
	FR = f_close(&fil);
    2248:	481c      	ldr	r0, [pc, #112]	; (22bc <AppRun+0x188>)
    224a:	4b27      	ldr	r3, [pc, #156]	; (22e8 <AppRun+0x1b4>)
    224c:	4798      	blx	r3
    224e:	4b17      	ldr	r3, [pc, #92]	; (22ac <AppRun+0x178>)
    2250:	7018      	strb	r0, [r3, #0]
	
	// Check for closing error
	if (FR) {
    2252:	2800      	cmp	r0, #0
    2254:	d007      	beq.n	2266 <AppRun+0x132>
		UART3_Write_Text("Error closing file after reading\n");
    2256:	482f      	ldr	r0, [pc, #188]	; (2314 <AppRun+0x1e0>)
    2258:	4b09      	ldr	r3, [pc, #36]	; (2280 <AppRun+0x14c>)
    225a:	4798      	blx	r3
    225c:	e7fe      	b.n	225c <AppRun+0x128>
		UART3_Write_Text(line);
    225e:	a801      	add	r0, sp, #4
    2260:	4b07      	ldr	r3, [pc, #28]	; (2280 <AppRun+0x14c>)
    2262:	4798      	blx	r3
    2264:	e7e5      	b.n	2232 <AppRun+0xfe>
		while (1);
	}
	UART3_Write_Text("File closed successfully after reading\n");
    2266:	482c      	ldr	r0, [pc, #176]	; (2318 <AppRun+0x1e4>)
    2268:	4b05      	ldr	r3, [pc, #20]	; (2280 <AppRun+0x14c>)
    226a:	4798      	blx	r3
    226c:	e7fe      	b.n	226c <AppRun+0x138>
    226e:	46c0      	nop			; (mov r8, r8)
    2270:	00004045 	.word	0x00004045
    2274:	003450dc 	.word	0x003450dc
    2278:	00002429 	.word	0x00002429
    227c:	000045f8 	.word	0x000045f8
    2280:	00004105 	.word	0x00004105
    2284:	00003f65 	.word	0x00003f65
    2288:	00004618 	.word	0x00004618
    228c:	00004634 	.word	0x00004634
    2290:	00004658 	.word	0x00004658
    2294:	00003d1d 	.word	0x00003d1d
    2298:	0000466c 	.word	0x0000466c
    229c:	0000468c 	.word	0x0000468c
    22a0:	20000000 	.word	0x20000000
    22a4:	20000460 	.word	0x20000460
    22a8:	00003559 	.word	0x00003559
    22ac:	20000690 	.word	0x20000690
    22b0:	000046a4 	.word	0x000046a4
    22b4:	000046bc 	.word	0x000046bc
    22b8:	000046d8 	.word	0x000046d8
    22bc:	20000698 	.word	0x20000698
    22c0:	000035c9 	.word	0x000035c9
    22c4:	000046f4 	.word	0x000046f4
    22c8:	00004708 	.word	0x00004708
    22cc:	00004724 	.word	0x00004724
    22d0:	20000694 	.word	0x20000694
    22d4:	00004738 	.word	0x00004738
    22d8:	00003915 	.word	0x00003915
    22dc:	00004758 	.word	0x00004758
    22e0:	00004770 	.word	0x00004770
    22e4:	00004784 	.word	0x00004784
    22e8:	00003bbd 	.word	0x00003bbd
    22ec:	00004794 	.word	0x00004794
    22f0:	000047a8 	.word	0x000047a8
    22f4:	000047c4 	.word	0x000047c4
    22f8:	000047e4 	.word	0x000047e4
    22fc:	000047fc 	.word	0x000047fc
    2300:	0000481c 	.word	0x0000481c
    2304:	00004838 	.word	0x00004838
    2308:	00003be5 	.word	0x00003be5
    230c:	00004850 	.word	0x00004850
    2310:	00004864 	.word	0x00004864
    2314:	00004880 	.word	0x00004880
    2318:	000048a4 	.word	0x000048a4

0000231c <ClocksInit>:

	/* ----------------------------------------------------------------------------------------------
	* 1) Set Flash wait states for 48 MHz (per Table 37-40 in data sheet)
	*/
	
	NVMCTRL->CTRLB.bit.RWS = 1;		/* 1 wait state required @ 3.3V & 48MHz */
    231c:	4a34      	ldr	r2, [pc, #208]	; (23f0 <ClocksInit+0xd4>)
    231e:	6853      	ldr	r3, [r2, #4]
    2320:	211e      	movs	r1, #30
    2322:	438b      	bics	r3, r1
    2324:	391c      	subs	r1, #28
    2326:	430b      	orrs	r3, r1
    2328:	6053      	str	r3, [r2, #4]
		.bit.AAMPEN = 0,		/* Disable automatic amplitude control */
		.bit.EN32K = 1,			/* 32kHz output is disabled */
		.bit.XTALEN = 1			/* Crystal connected to XIN32/XOUT32 */
	};
	// Write these settings
	SYSCTRL->XOSC32K.reg = sysctrl_xosc32k.reg;
    232a:	4b32      	ldr	r3, [pc, #200]	; (23f4 <ClocksInit+0xd8>)
    232c:	2283      	movs	r2, #131	; 0x83
    232e:	0092      	lsls	r2, r2, #2
    2330:	829a      	strh	r2, [r3, #20]
	// Enable the Oscillator - Separate step per data sheet recommendation (sec 17.6.3)
	SYSCTRL->XOSC32K.bit.ENABLE = 1;
    2332:	8a9a      	ldrh	r2, [r3, #20]
    2334:	430a      	orrs	r2, r1
    2336:	829a      	strh	r2, [r3, #20]
	
	// Wait for XOSC32K to stabilize
	while(!SYSCTRL->PCLKSR.bit.XOSC32KRDY);
    2338:	001a      	movs	r2, r3
    233a:	68d3      	ldr	r3, [r2, #12]
    233c:	079b      	lsls	r3, r3, #30
    233e:	d5fc      	bpl.n	233a <ClocksInit+0x1e>
	{
		.bit.DIV = 1,								/* Set output division factor = 1 */
		.bit.ID = GENERIC_CLOCK_GENERATOR_XOSC32K	/* Apply division factor to Generator 1 */
	};
	// Write these settings
	GCLK->GENDIV.reg = gclk1_gendiv.reg;
    2340:	4b2d      	ldr	r3, [pc, #180]	; (23f8 <ClocksInit+0xdc>)
    2342:	2202      	movs	r2, #2
    2344:	32ff      	adds	r2, #255	; 0xff
    2346:	609a      	str	r2, [r3, #8]
	
	// Configure Generic Clock Generator 1 with XOSC32K as source
	GCLK_GENCTRL_Type gclk1_genctrl = 
    2348:	4a2c      	ldr	r2, [pc, #176]	; (23fc <ClocksInit+0xe0>)
		.bit.GENEN = 1,			/* Enable the generator */
		.bit.SRC = 0x05,		/* Generator source: XOSC32K output */
		.bit.ID = GENERIC_CLOCK_GENERATOR_XOSC32K			/* Generator ID: 1 */
	};
	// Write these settings
	GCLK->GENCTRL.reg = gclk1_genctrl.reg;
    234a:	605a      	str	r2, [r3, #4]
	// GENCTRL is Write-Synchronized...so wait for write to complete
	while(GCLK->STATUS.bit.SYNCBUSY);
    234c:	001a      	movs	r2, r3
    234e:	7853      	ldrb	r3, [r2, #1]
    2350:	09db      	lsrs	r3, r3, #7
    2352:	d1fc      	bne.n	234e <ClocksInit+0x32>
		.bit.CLKEN = 1,			/* Enable the Generic Clock */
		.bit.GEN = GENERIC_CLOCK_GENERATOR_XOSC32K, 	/* Generic Clock Generator 1 is the source */
		.bit.ID = 0x00			/* Generic Clock Multiplexer 0 (DFLL48M Reference) */
	};
	// Write these settings
	GCLK->CLKCTRL.reg = gclk_clkctrl.reg;
    2354:	4b28      	ldr	r3, [pc, #160]	; (23f8 <ClocksInit+0xdc>)
    2356:	2282      	movs	r2, #130	; 0x82
    2358:	01d2      	lsls	r2, r2, #7
    235a:	805a      	strh	r2, [r3, #2]
	// Enable the DFLL48M in open loop mode. Without this step, attempts to go into closed loop mode at 48 MHz will
	// result in Processor Reset (you'll be at the in the Reset_Handler in startup_samd21.c).
	// PCLKSR.DFLLRDY must be one before writing to the DFLL Control register
	// Note that the DFLLRDY bit represents status of register synchronization - NOT clock stability
	// (see Data Sheet 17.6.14 Synchronization for detail)
	while(!SYSCTRL->PCLKSR.bit.DFLLRDY);
    235c:	4a25      	ldr	r2, [pc, #148]	; (23f4 <ClocksInit+0xd8>)
    235e:	68d3      	ldr	r3, [r2, #12]
    2360:	06db      	lsls	r3, r3, #27
    2362:	d5fc      	bpl.n	235e <ClocksInit+0x42>
	SYSCTRL->DFLLCTRL.reg = (uint16_t)(SYSCTRL_DFLLCTRL_ENABLE);
    2364:	2202      	movs	r2, #2
    2366:	4b23      	ldr	r3, [pc, #140]	; (23f4 <ClocksInit+0xd8>)
    2368:	849a      	strh	r2, [r3, #36]	; 0x24
	while(!SYSCTRL->PCLKSR.bit.DFLLRDY);
    236a:	001a      	movs	r2, r3
    236c:	68d3      	ldr	r3, [r2, #12]
    236e:	06db      	lsls	r3, r3, #27
    2370:	d5fc      	bpl.n	236c <ClocksInit+0x50>
		.bit.CSTEP = 31,		/* Coarse step - use half of the max value (63) */
		.bit.FSTEP = 511,		/* Fine step - use half of the max value (1023) */
		.bit.MUL = 1465			/* Multiplier = MAIN_CLK_FREQ (48MHz) / EXT_32K_CLK_FREQ (32768 Hz) */
	};
	// Write these settings
	SYSCTRL->DFLLMUL.reg = sysctrl_dfllmul.reg;
    2372:	4b20      	ldr	r3, [pc, #128]	; (23f4 <ClocksInit+0xd8>)
    2374:	4a22      	ldr	r2, [pc, #136]	; (2400 <ClocksInit+0xe4>)
    2376:	62da      	str	r2, [r3, #44]	; 0x2c
	// Wait for synchronization
	while(!SYSCTRL->PCLKSR.bit.DFLLRDY);
    2378:	001a      	movs	r2, r3
    237a:	68d3      	ldr	r3, [r2, #12]
    237c:	06db      	lsls	r3, r3, #27
    237e:	d5fc      	bpl.n	237a <ClocksInit+0x5e>
	
	// To reduce lock time, load factory calibrated values into DFLLVAL (cf. Data Sheet 17.6.7.1)
	// Location of value is defined in Data Sheet Table 10-5. NVM Software Calibration Area Mapping
	
	// Get factory calibrated value for "DFLL48M COARSE CAL" from NVM Software Calibration Area
	tempDFLL48CalibrationCoarse = *(uint32_t*)FUSES_DFLL48M_COARSE_CAL_ADDR;
    2380:	4b20      	ldr	r3, [pc, #128]	; (2404 <ClocksInit+0xe8>)
	tempDFLL48CalibrationCoarse &= FUSES_DFLL48M_COARSE_CAL_Msk;
	tempDFLL48CalibrationCoarse = tempDFLL48CalibrationCoarse>>FUSES_DFLL48M_COARSE_CAL_Pos;
	// Write the coarse calibration value
	SYSCTRL->DFLLVAL.bit.COARSE = tempDFLL48CalibrationCoarse;
    2382:	681a      	ldr	r2, [r3, #0]
    2384:	491b      	ldr	r1, [pc, #108]	; (23f4 <ClocksInit+0xd8>)
    2386:	6a8b      	ldr	r3, [r1, #40]	; 0x28
    2388:	0e92      	lsrs	r2, r2, #26
    238a:	0292      	lsls	r2, r2, #10
    238c:	481e      	ldr	r0, [pc, #120]	; (2408 <ClocksInit+0xec>)
    238e:	4003      	ands	r3, r0
    2390:	4313      	orrs	r3, r2
    2392:	628b      	str	r3, [r1, #40]	; 0x28
	// Switch DFLL48M to Closed Loop mode and enable WAITLOCK
	while(!SYSCTRL->PCLKSR.bit.DFLLRDY);
    2394:	000a      	movs	r2, r1
    2396:	68d3      	ldr	r3, [r2, #12]
    2398:	06db      	lsls	r3, r3, #27
    239a:	d5fc      	bpl.n	2396 <ClocksInit+0x7a>
	SYSCTRL->DFLLCTRL.reg |= (uint16_t) (SYSCTRL_DFLLCTRL_MODE | SYSCTRL_DFLLCTRL_WAITLOCK);
    239c:	4a15      	ldr	r2, [pc, #84]	; (23f4 <ClocksInit+0xd8>)
    239e:	8c93      	ldrh	r3, [r2, #36]	; 0x24
    23a0:	491a      	ldr	r1, [pc, #104]	; (240c <ClocksInit+0xf0>)
    23a2:	430b      	orrs	r3, r1
    23a4:	8493      	strh	r3, [r2, #36]	; 0x24
		.bit.IDC = 1,			/* Generator duty cycle is 50/50 */
		.bit.GENEN = 1,			/* Enable the generator */
		.bit.SRC = 0x07,		/* Generator source: DFLL48M output */
		.bit.ID = GENERIC_CLOCK_GENERATOR_MAIN			/* Generator ID: 0 */
	};
	GCLK->GENCTRL.reg = gclk_genctrl0.reg;
    23a6:	4b14      	ldr	r3, [pc, #80]	; (23f8 <ClocksInit+0xdc>)
    23a8:	4a19      	ldr	r2, [pc, #100]	; (2410 <ClocksInit+0xf4>)
    23aa:	605a      	str	r2, [r3, #4]
	// GENCTRL is Write-Synchronized...so wait for write to complete
	while(GCLK->STATUS.bit.SYNCBUSY);
    23ac:	001a      	movs	r2, r3
    23ae:	7853      	ldrb	r3, [r2, #1]
    23b0:	09db      	lsrs	r3, r3, #7
    23b2:	d1fc      	bne.n	23ae <ClocksInit+0x92>
		.bit.PMUX = 7,			/* Peripheral Function H selected (GCLK_IO[0]) */
		.bit.PMUXEN = 1,		/* Enable peripheral Multiplexer */
		.bit.PINMASK = (uint16_t)(1 << (28-16)) /* Select the pin(s) to be configured */
	};
	// Write these settings
	PORT->Group[0].WRCONFIG.reg = port0_wrconfig.reg;
    23b4:	4b17      	ldr	r3, [pc, #92]	; (2414 <ClocksInit+0xf8>)
    23b6:	4a18      	ldr	r2, [pc, #96]	; (2418 <ClocksInit+0xfc>)
    23b8:	629a      	str	r2, [r3, #40]	; 0x28
	
	/* ----------------------------------------------------------------------------------------------
	* 7) Modify prescaler value of OSC8M to produce 8MHz output
	*/

	SYSCTRL->OSC8M.bit.PRESC = 0;		/* Prescale by 1 */
    23ba:	4b0e      	ldr	r3, [pc, #56]	; (23f4 <ClocksInit+0xd8>)
    23bc:	6a1a      	ldr	r2, [r3, #32]
    23be:	4917      	ldr	r1, [pc, #92]	; (241c <ClocksInit+0x100>)
    23c0:	400a      	ands	r2, r1
    23c2:	621a      	str	r2, [r3, #32]
	SYSCTRL->OSC8M.bit.ONDEMAND = 0 ;	/* Oscillator is always on if enabled */
    23c4:	6a1a      	ldr	r2, [r3, #32]
    23c6:	2180      	movs	r1, #128	; 0x80
    23c8:	438a      	bics	r2, r1
    23ca:	621a      	str	r2, [r3, #32]
	{
		.bit.DIV = 1,								/* Set output division factor = 1 */
		.bit.ID = GENERIC_CLOCK_GENERATOR_OSC8M		/* Apply division factor to Generator 3 */
	};
	// Write these settings
	GCLK->GENDIV.reg = gclk3_gendiv.reg;
    23cc:	4b0a      	ldr	r3, [pc, #40]	; (23f8 <ClocksInit+0xdc>)
    23ce:	2204      	movs	r2, #4
    23d0:	32ff      	adds	r2, #255	; 0xff
    23d2:	609a      	str	r2, [r3, #8]
	
	// Configure Generic Clock Generator 3 with OSC8M as source
	GCLK_GENCTRL_Type gclk3_genctrl = 
    23d4:	4a12      	ldr	r2, [pc, #72]	; (2420 <ClocksInit+0x104>)
		.bit.GENEN = 1,			/* Enable the generator */
		.bit.SRC = 0x06,		/* Generator source: OSC8M output */
		.bit.ID = GENERIC_CLOCK_GENERATOR_OSC8M			/* Generator ID: 3 */
	};
	// Write these settings
	GCLK->GENCTRL.reg = gclk3_genctrl.reg;
    23d6:	605a      	str	r2, [r3, #4]
	// GENCTRL is Write-Synchronized...so wait for write to complete
	while(GCLK->STATUS.bit.SYNCBUSY);
    23d8:	001a      	movs	r2, r3
    23da:	7853      	ldrb	r3, [r2, #1]
    23dc:	09db      	lsrs	r3, r3, #7
    23de:	d1fc      	bne.n	23da <ClocksInit+0xbe>
	
	/* ----------------------------------------------------------------------------------------------
	* 9) Set CPU and APBx BUS Clocks to 48MHz
	*/
	PM->CPUSEL.reg  = PM_CPUSEL_CPUDIV_DIV1 ;
    23e0:	4b10      	ldr	r3, [pc, #64]	; (2424 <ClocksInit+0x108>)
    23e2:	2200      	movs	r2, #0
    23e4:	721a      	strb	r2, [r3, #8]
	PM->APBASEL.reg = PM_APBASEL_APBADIV_DIV1_Val ;
    23e6:	725a      	strb	r2, [r3, #9]
	PM->APBBSEL.reg = PM_APBBSEL_APBBDIV_DIV1_Val ;
    23e8:	729a      	strb	r2, [r3, #10]
	PM->APBCSEL.reg = PM_APBCSEL_APBCDIV_DIV1_Val ;
    23ea:	72da      	strb	r2, [r3, #11]
	
    23ec:	4770      	bx	lr
    23ee:	46c0      	nop			; (mov r8, r8)
    23f0:	41004000 	.word	0x41004000
    23f4:	40000800 	.word	0x40000800
    23f8:	40000c00 	.word	0x40000c00
    23fc:	00030501 	.word	0x00030501
    2400:	7dff05b9 	.word	0x7dff05b9
    2404:	00806024 	.word	0x00806024
    2408:	ffff03ff 	.word	0xffff03ff
    240c:	00000804 	.word	0x00000804
    2410:	000b0700 	.word	0x000b0700
    2414:	41004400 	.word	0x41004400
    2418:	d7011000 	.word	0xd7011000
    241c:	fffffcff 	.word	0xfffffcff
    2420:	00030603 	.word	0x00030603
    2424:	40000400 	.word	0x40000400

00002428 <delay_n_cycles>:
 *
 ******************************************************************************/

void delay_n_cycles(unsigned long n)
{
	__asm (
    2428:	f3bf 8f5f 	dmb	sy
    242c:	3801      	subs	r0, #1
    242e:	2800      	cmp	r0, #0
    2430:	d1fa      	bne.n	2428 <delay_n_cycles>
	"loop: DMB	\n"
	"SUB r0, r0, #1 \n"
	"CMP r0, #0  \n"
	"BNE loop         "
	);
} // delay_n_cycles()
    2432:	4770      	bx	lr

00002434 <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
    2434:	e7fe      	b.n	2434 <Dummy_Handler>
	...

00002438 <Reset_Handler>:
{
    2438:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
        if (pSrc != pDest) {
    243a:	4a2a      	ldr	r2, [pc, #168]	; (24e4 <Reset_Handler+0xac>)
    243c:	4b2a      	ldr	r3, [pc, #168]	; (24e8 <Reset_Handler+0xb0>)
    243e:	429a      	cmp	r2, r3
    2440:	d011      	beq.n	2466 <Reset_Handler+0x2e>
                for (; pDest < &_erelocate;) {
    2442:	001a      	movs	r2, r3
    2444:	4b29      	ldr	r3, [pc, #164]	; (24ec <Reset_Handler+0xb4>)
    2446:	429a      	cmp	r2, r3
    2448:	d20d      	bcs.n	2466 <Reset_Handler+0x2e>
    244a:	4a29      	ldr	r2, [pc, #164]	; (24f0 <Reset_Handler+0xb8>)
    244c:	3303      	adds	r3, #3
    244e:	1a9b      	subs	r3, r3, r2
    2450:	089b      	lsrs	r3, r3, #2
    2452:	3301      	adds	r3, #1
    2454:	009b      	lsls	r3, r3, #2
    2456:	2200      	movs	r2, #0
                        *pDest++ = *pSrc++;
    2458:	4823      	ldr	r0, [pc, #140]	; (24e8 <Reset_Handler+0xb0>)
    245a:	4922      	ldr	r1, [pc, #136]	; (24e4 <Reset_Handler+0xac>)
    245c:	588c      	ldr	r4, [r1, r2]
    245e:	5084      	str	r4, [r0, r2]
    2460:	3204      	adds	r2, #4
                for (; pDest < &_erelocate;) {
    2462:	429a      	cmp	r2, r3
    2464:	d1fa      	bne.n	245c <Reset_Handler+0x24>
        for (pDest = &_szero; pDest < &_ezero;) {
    2466:	4a23      	ldr	r2, [pc, #140]	; (24f4 <Reset_Handler+0xbc>)
    2468:	4b23      	ldr	r3, [pc, #140]	; (24f8 <Reset_Handler+0xc0>)
    246a:	429a      	cmp	r2, r3
    246c:	d20a      	bcs.n	2484 <Reset_Handler+0x4c>
    246e:	43d3      	mvns	r3, r2
    2470:	4921      	ldr	r1, [pc, #132]	; (24f8 <Reset_Handler+0xc0>)
    2472:	185b      	adds	r3, r3, r1
    2474:	2103      	movs	r1, #3
    2476:	438b      	bics	r3, r1
    2478:	3304      	adds	r3, #4
    247a:	189b      	adds	r3, r3, r2
                *pDest++ = 0;
    247c:	2100      	movs	r1, #0
    247e:	c202      	stmia	r2!, {r1}
        for (pDest = &_szero; pDest < &_ezero;) {
    2480:	4293      	cmp	r3, r2
    2482:	d1fc      	bne.n	247e <Reset_Handler+0x46>
        SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
    2484:	4a1d      	ldr	r2, [pc, #116]	; (24fc <Reset_Handler+0xc4>)
    2486:	21ff      	movs	r1, #255	; 0xff
    2488:	4b1d      	ldr	r3, [pc, #116]	; (2500 <Reset_Handler+0xc8>)
    248a:	438b      	bics	r3, r1
    248c:	6093      	str	r3, [r2, #8]
        SBMATRIX->SFR[SBMATRIX_SLAVE_HMCRAMC0].reg = 2;
    248e:	39fd      	subs	r1, #253	; 0xfd
    2490:	2390      	movs	r3, #144	; 0x90
    2492:	005b      	lsls	r3, r3, #1
    2494:	4a1b      	ldr	r2, [pc, #108]	; (2504 <Reset_Handler+0xcc>)
    2496:	50d1      	str	r1, [r2, r3]
        USB->DEVICE.QOSCTRL.bit.CQOS = 2;
    2498:	4a1b      	ldr	r2, [pc, #108]	; (2508 <Reset_Handler+0xd0>)
    249a:	78d3      	ldrb	r3, [r2, #3]
    249c:	2503      	movs	r5, #3
    249e:	43ab      	bics	r3, r5
    24a0:	2402      	movs	r4, #2
    24a2:	4323      	orrs	r3, r4
    24a4:	70d3      	strb	r3, [r2, #3]
        USB->DEVICE.QOSCTRL.bit.DQOS = 2;
    24a6:	78d3      	ldrb	r3, [r2, #3]
    24a8:	270c      	movs	r7, #12
    24aa:	43bb      	bics	r3, r7
    24ac:	2608      	movs	r6, #8
    24ae:	4333      	orrs	r3, r6
    24b0:	70d3      	strb	r3, [r2, #3]
        DMAC->QOSCTRL.bit.DQOS = 2;
    24b2:	4b16      	ldr	r3, [pc, #88]	; (250c <Reset_Handler+0xd4>)
    24b4:	7b98      	ldrb	r0, [r3, #14]
    24b6:	2230      	movs	r2, #48	; 0x30
    24b8:	4390      	bics	r0, r2
    24ba:	2220      	movs	r2, #32
    24bc:	4310      	orrs	r0, r2
    24be:	7398      	strb	r0, [r3, #14]
        DMAC->QOSCTRL.bit.FQOS = 2;
    24c0:	7b99      	ldrb	r1, [r3, #14]
    24c2:	43b9      	bics	r1, r7
    24c4:	4331      	orrs	r1, r6
    24c6:	7399      	strb	r1, [r3, #14]
        DMAC->QOSCTRL.bit.WRBQOS = 2;
    24c8:	7b9a      	ldrb	r2, [r3, #14]
    24ca:	43aa      	bics	r2, r5
    24cc:	4322      	orrs	r2, r4
    24ce:	739a      	strb	r2, [r3, #14]
        NVMCTRL->CTRLB.bit.MANW = 1;
    24d0:	4a0f      	ldr	r2, [pc, #60]	; (2510 <Reset_Handler+0xd8>)
    24d2:	6853      	ldr	r3, [r2, #4]
    24d4:	2180      	movs	r1, #128	; 0x80
    24d6:	430b      	orrs	r3, r1
    24d8:	6053      	str	r3, [r2, #4]
        __libc_init_array();
    24da:	4b0e      	ldr	r3, [pc, #56]	; (2514 <Reset_Handler+0xdc>)
    24dc:	4798      	blx	r3
        main();
    24de:	4b0e      	ldr	r3, [pc, #56]	; (2518 <Reset_Handler+0xe0>)
    24e0:	4798      	blx	r3
    24e2:	e7fe      	b.n	24e2 <Reset_Handler+0xaa>
    24e4:	00004ab0 	.word	0x00004ab0
    24e8:	20000000 	.word	0x20000000
    24ec:	2000043c 	.word	0x2000043c
    24f0:	20000004 	.word	0x20000004
    24f4:	2000043c 	.word	0x2000043c
    24f8:	20000ae4 	.word	0x20000ae4
    24fc:	e000ed00 	.word	0xe000ed00
    2500:	00002000 	.word	0x00002000
    2504:	41007000 	.word	0x41007000
    2508:	41005000 	.word	0x41005000
    250c:	41004800 	.word	0x41004800
    2510:	41004000 	.word	0x41004000
    2514:	00004459 	.word	0x00004459
    2518:	00003c39 	.word	0x00003c39

0000251c <disk_status>:
/* Get Drive Status                                                      */
/*-----------------------------------------------------------------------*/

DSTATUS disk_status ( BYTE pdrv) /* Physical drive number to identify the drive */
{
     if(pdrv)
    251c:	1e43      	subs	r3, r0, #1
    251e:	4198      	sbcs	r0, r3
    2520:	b2c0      	uxtb	r0, r0
    {
        return STA_NOINIT;
    }
    return RES_OK;
}
    2522:	4770      	bx	lr

00002524 <disk_initialize>:
/*-----------------------------------------------------------------------*/
/* Initialize a Drive                                                    */
/*-----------------------------------------------------------------------*/

DSTATUS disk_initialize (BYTE pdrv)
{
    2524:	b510      	push	{r4, lr}
	DSTATUS stat;
	stat=SDCard_Init();  //SD card initialization
    2526:	4b04      	ldr	r3, [pc, #16]	; (2538 <disk_initialize+0x14>)
    2528:	4798      	blx	r3
    252a:	0003      	movs	r3, r0

	if(stat == STA_NODISK)
    252c:	2802      	cmp	r0, #2
    252e:	d002      	beq.n	2536 <disk_initialize+0x12>
	{
		return STA_NODISK;
	}
	else if(stat != 0)
    2530:	1e58      	subs	r0, r3, #1
    2532:	4183      	sbcs	r3, r0
		return STA_NODISK;
    2534:	b2d8      	uxtb	r0, r3
	}
	  else
	  {
		return 0;
	  }
}
    2536:	bd10      	pop	{r4, pc}
    2538:	00003d1d 	.word	0x00003d1d

0000253c <disk_read>:
	BYTE pdrv,                                /* Physical drive number to identify the drive */
	BYTE *buff,                               /* Data buffer to store read data */
	DWORD sector,        /* Sector address in LBA */
	UINT count                               /* Number of sectors to read */
)
{
    253c:	b510      	push	{r4, lr}
    DRESULT res;
    if (pdrv || !count)
    {
        return RES_PARERR;
    253e:	2204      	movs	r2, #4
    if (pdrv || !count)
    2540:	2800      	cmp	r0, #0
    2542:	d001      	beq.n	2548 <disk_read+0xc>
    }
    else
    {
        return RES_ERROR;
    }
}
    2544:	0010      	movs	r0, r2
    2546:	bd10      	pop	{r4, pc}
    if (pdrv || !count)
    2548:	2b00      	cmp	r3, #0
    254a:	d0fb      	beq.n	2544 <disk_read+0x8>
        return RES_OK;
    254c:	2200      	movs	r2, #0
		if (count == 1)
    254e:	2b01      	cmp	r3, #1
    2550:	d0f8      	beq.n	2544 <disk_read+0x8>
			UART3_Write_Text("read 2 \n");
    2552:	4802      	ldr	r0, [pc, #8]	; (255c <disk_read+0x20>)
    2554:	4b02      	ldr	r3, [pc, #8]	; (2560 <disk_read+0x24>)
    2556:	4798      	blx	r3
        return RES_OK;
    2558:	2200      	movs	r2, #0
    255a:	e7f3      	b.n	2544 <disk_read+0x8>
    255c:	000048cc 	.word	0x000048cc
    2560:	00004105 	.word	0x00004105

00002564 <disk_write>:
	BYTE pdrv,             /* Physical drive number to identify the drive */
	const BYTE *buff,      /* Data to be written */
	DWORD sector,          /* Sector address in LBA */
	UINT count             /* Number of sectors to write */
)
{
    2564:	b510      	push	{r4, lr}
    DRESULT res;
	if (pdrv || !count)
    {
        return RES_PARERR;
    2566:	2204      	movs	r2, #4
	if (pdrv || !count)
    2568:	2800      	cmp	r0, #0
    256a:	d001      	beq.n	2570 <disk_write+0xc>
    }
    else
    {
        return RES_ERROR;
    }
}
    256c:	0010      	movs	r0, r2
    256e:	bd10      	pop	{r4, pc}
	if (pdrv || !count)
    2570:	2b00      	cmp	r3, #0
    2572:	d0fb      	beq.n	256c <disk_write+0x8>
    if(count == 1)
    2574:	2b01      	cmp	r3, #1
    2576:	d004      	beq.n	2582 <disk_write+0x1e>
    	UART3_Write_Text("write 2 \n");
    2578:	4804      	ldr	r0, [pc, #16]	; (258c <disk_write+0x28>)
    257a:	4b05      	ldr	r3, [pc, #20]	; (2590 <disk_write+0x2c>)
    257c:	4798      	blx	r3
        return RES_OK;
    257e:	2200      	movs	r2, #0
    2580:	e7f4      	b.n	256c <disk_write+0x8>
    	UART3_Write_Text("write 1 \n");
    2582:	4804      	ldr	r0, [pc, #16]	; (2594 <disk_write+0x30>)
    2584:	4b02      	ldr	r3, [pc, #8]	; (2590 <disk_write+0x2c>)
    2586:	4798      	blx	r3
        return RES_OK;
    2588:	2200      	movs	r2, #0
    258a:	e7ef      	b.n	256c <disk_write+0x8>
    258c:	000048e4 	.word	0x000048e4
    2590:	00004105 	.word	0x00004105
    2594:	000048d8 	.word	0x000048d8

00002598 <disk_ioctl>:
DRESULT disk_ioctl (
	BYTE pdrv,               /* Physical drive number (0..) */
	BYTE cmd,                /* Control code */
	void *buff               /* Buffer to send/receive control data */
)
{
    2598:	b510      	push	{r4, lr}
	BYTE n, csd[16];
	DWORD csize;

	if (pdrv)
	{
		 return RES_PARERR;
    259a:	2304      	movs	r3, #4
	if (pdrv)
    259c:	2800      	cmp	r0, #0
    259e:	d001      	beq.n	25a4 <disk_ioctl+0xc>
		
		default:
		 res = RES_PARERR; break;
	}
	return res;
}
    25a0:	0018      	movs	r0, r3
    25a2:	bd10      	pop	{r4, pc}
	switch (cmd)
    25a4:	2901      	cmp	r1, #1
    25a6:	d00c      	beq.n	25c2 <disk_ioctl+0x2a>
    25a8:	2900      	cmp	r1, #0
    25aa:	d016      	beq.n	25da <disk_ioctl+0x42>
    25ac:	2902      	cmp	r1, #2
    25ae:	d00f      	beq.n	25d0 <disk_ioctl+0x38>
    25b0:	2903      	cmp	r1, #3
    25b2:	d1f5      	bne.n	25a0 <disk_ioctl+0x8>
				if ((SDCard_WriteCmd(0x49,0x00,0x95) == 0) && SDCard_CardID(0x49, csd)) /* Read CSD */
    25b4:	2295      	movs	r2, #149	; 0x95
    25b6:	2100      	movs	r1, #0
    25b8:	2049      	movs	r0, #73	; 0x49
    25ba:	4b09      	ldr	r3, [pc, #36]	; (25e0 <disk_ioctl+0x48>)
    25bc:	4798      	blx	r3
	res = RES_ERROR;
    25be:	2301      	movs	r3, #1
    25c0:	e7ee      	b.n	25a0 <disk_ioctl+0x8>
				if((SDCard_WriteCmd(0x49,0x00,0x95) == 0) && SDCard_CardID(0x49, csd))
    25c2:	2295      	movs	r2, #149	; 0x95
    25c4:	2100      	movs	r1, #0
    25c6:	2049      	movs	r0, #73	; 0x49
    25c8:	4b05      	ldr	r3, [pc, #20]	; (25e0 <disk_ioctl+0x48>)
    25ca:	4798      	blx	r3
	res = RES_ERROR;
    25cc:	2301      	movs	r3, #1
    25ce:	e7e7      	b.n	25a0 <disk_ioctl+0x8>
				*(WORD*)buff = 512;
    25d0:	2380      	movs	r3, #128	; 0x80
    25d2:	009b      	lsls	r3, r3, #2
    25d4:	8013      	strh	r3, [r2, #0]
				res = RES_OK;
    25d6:	2300      	movs	r3, #0
				break;
    25d8:	e7e2      	b.n	25a0 <disk_ioctl+0x8>
		case CTRL_SYNC        : res = RES_OK; break;
    25da:	2300      	movs	r3, #0
    25dc:	e7e0      	b.n	25a0 <disk_ioctl+0x8>
    25de:	46c0      	nop			; (mov r8, r8)
    25e0:	00003c81 	.word	0x00003c81

000025e4 <get_fattime>:

// FATTIME Work around
DWORD get_fattime (void)
{
	return 0;
}
    25e4:	2000      	movs	r0, #0
    25e6:	4770      	bx	lr

000025e8 <mem_cpy>:
/* String functions                                                      */
/*-----------------------------------------------------------------------*/

/* Copy memory to memory */
static
void mem_cpy (void* dst, const void* src, UINT cnt) {
    25e8:	b510      	push	{r4, lr}
		*(int*)d = *(int*)s;
		d += sizeof (int); s += sizeof (int);
		cnt -= sizeof (int);
	}
#endif
	while (cnt--)
    25ea:	2a00      	cmp	r2, #0
    25ec:	d005      	beq.n	25fa <mem_cpy+0x12>
    25ee:	2300      	movs	r3, #0
		*d++ = *s++;
    25f0:	5ccc      	ldrb	r4, [r1, r3]
    25f2:	54c4      	strb	r4, [r0, r3]
    25f4:	3301      	adds	r3, #1
	while (cnt--)
    25f6:	4293      	cmp	r3, r2
    25f8:	d1fa      	bne.n	25f0 <mem_cpy+0x8>
}
    25fa:	bd10      	pop	{r4, pc}

000025fc <ld_clust>:
static
DWORD ld_clust (
	FATFS* fs,	/* Pointer to the fs object */
	BYTE* dir	/* Pointer to the directory entry */
)
{
    25fc:	b510      	push	{r4, lr}
    25fe:	0004      	movs	r4, r0
	DWORD cl;

	cl = LD_WORD(dir + DIR_FstClusLO);
    2600:	7eca      	ldrb	r2, [r1, #27]
    2602:	0212      	lsls	r2, r2, #8
    2604:	7e88      	ldrb	r0, [r1, #26]
    2606:	4310      	orrs	r0, r2
	if (fs->fs_type == FS_FAT32)
    2608:	7823      	ldrb	r3, [r4, #0]
    260a:	2b03      	cmp	r3, #3
    260c:	d000      	beq.n	2610 <ld_clust+0x14>
		cl |= (DWORD)LD_WORD(dir + DIR_FstClusHI) << 16;

	return cl;
}
    260e:	bd10      	pop	{r4, pc}
		cl |= (DWORD)LD_WORD(dir + DIR_FstClusHI) << 16;
    2610:	7d4a      	ldrb	r2, [r1, #21]
    2612:	0212      	lsls	r2, r2, #8
    2614:	7d0b      	ldrb	r3, [r1, #20]
    2616:	4313      	orrs	r3, r2
    2618:	041b      	lsls	r3, r3, #16
    261a:	4318      	orrs	r0, r3
	return cl;
    261c:	e7f7      	b.n	260e <ld_clust+0x12>

0000261e <get_ldnumber>:

static
int get_ldnumber (		/* Returns logical drive number (-1:invalid drive) */
	const TCHAR** path	/* Pointer to pointer to the path name */
)
{
    261e:	b530      	push	{r4, r5, lr}
	char c;
	TCHAR tc;
#endif


	if (*path) {	/* If the pointer is not a null */
    2620:	6801      	ldr	r1, [r0, #0]
    2622:	2900      	cmp	r1, #0
    2624:	d01b      	beq.n	265e <get_ldnumber+0x40>
		for (tt = *path; (UINT)*tt >= (_USE_LFN ? ' ' : '!') && *tt != ':'; tt++) ;	/* Find ':' in the path */
    2626:	780c      	ldrb	r4, [r1, #0]
    2628:	2c20      	cmp	r4, #32
    262a:	d911      	bls.n	2650 <get_ldnumber+0x32>
    262c:	2c3a      	cmp	r4, #58	; 0x3a
    262e:	d01f      	beq.n	2670 <get_ldnumber+0x52>
    2630:	000b      	movs	r3, r1
    2632:	3301      	adds	r3, #1
    2634:	781a      	ldrb	r2, [r3, #0]
    2636:	2a20      	cmp	r2, #32
    2638:	d90c      	bls.n	2654 <get_ldnumber+0x36>
    263a:	2a3a      	cmp	r2, #58	; 0x3a
    263c:	d1f9      	bne.n	2632 <get_ldnumber+0x14>
		if (*tt == ':') {	/* If a ':' is exist in the path name */
			tp = *path;
			i = *tp++ - '0'; 
    263e:	1c4a      	adds	r2, r1, #1
			if (i < 10 && tp == tt) {	/* Is there a numeric drive id? */
    2640:	4293      	cmp	r3, r2
    2642:	d10f      	bne.n	2664 <get_ldnumber+0x46>
				if (i < _VOLUMES) {	/* If a drive id is found, get the value and strip it */
    2644:	2c30      	cmp	r4, #48	; 0x30
    2646:	d110      	bne.n	266a <get_ldnumber+0x4c>
					vol = (int)i;
					*path = ++tt;
    2648:	3102      	adds	r1, #2
    264a:	6001      	str	r1, [r0, #0]
					vol = (int)i;
    264c:	2500      	movs	r5, #0
    264e:	e004      	b.n	265a <get_ldnumber+0x3c>
		for (tt = *path; (UINT)*tt >= (_USE_LFN ? ' ' : '!') && *tt != ':'; tt++) ;	/* Find ':' in the path */
    2650:	0022      	movs	r2, r4
    2652:	000b      	movs	r3, r1
			return vol;
		}
#if _FS_RPATH && _VOLUMES >= 2
		vol = CurrVol;	/* Current drive */
#else
		vol = 0;		/* Drive 0 */
    2654:	2500      	movs	r5, #0
		if (*tt == ':') {	/* If a ':' is exist in the path name */
    2656:	2a3a      	cmp	r2, #58	; 0x3a
    2658:	d0f1      	beq.n	263e <get_ldnumber+0x20>
#endif
	}
	return vol;
}
    265a:	0028      	movs	r0, r5
    265c:	bd30      	pop	{r4, r5, pc}
	int vol = -1;
    265e:	2501      	movs	r5, #1
    2660:	426d      	negs	r5, r5
    2662:	e7fa      	b.n	265a <get_ldnumber+0x3c>
    2664:	2501      	movs	r5, #1
    2666:	426d      	negs	r5, r5
    2668:	e7f7      	b.n	265a <get_ldnumber+0x3c>
    266a:	2501      	movs	r5, #1
    266c:	426d      	negs	r5, r5
    266e:	e7f4      	b.n	265a <get_ldnumber+0x3c>
		for (tt = *path; (UINT)*tt >= (_USE_LFN ? ' ' : '!') && *tt != ':'; tt++) ;	/* Find ':' in the path */
    2670:	000b      	movs	r3, r1
    2672:	e7e4      	b.n	263e <get_ldnumber+0x20>

00002674 <sync_window>:
{
    2674:	b5f0      	push	{r4, r5, r6, r7, lr}
    2676:	b083      	sub	sp, #12
    2678:	0004      	movs	r4, r0
	if (fs->wflag) {	/* Write back the sector if it is dirty */
    267a:	7903      	ldrb	r3, [r0, #4]
	FRESULT res = FR_OK;
    267c:	2000      	movs	r0, #0
	if (fs->wflag) {	/* Write back the sector if it is dirty */
    267e:	2b00      	cmp	r3, #0
    2680:	d101      	bne.n	2686 <sync_window+0x12>
}
    2682:	b003      	add	sp, #12
    2684:	bdf0      	pop	{r4, r5, r6, r7, pc}
		wsect = fs->winsect;	/* Current sector number */
    2686:	6ae5      	ldr	r5, [r4, #44]	; 0x2c
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
    2688:	2330      	movs	r3, #48	; 0x30
    268a:	469c      	mov	ip, r3
    268c:	44a4      	add	ip, r4
    268e:	4663      	mov	r3, ip
    2690:	4661      	mov	r1, ip
    2692:	9301      	str	r3, [sp, #4]
    2694:	7860      	ldrb	r0, [r4, #1]
    2696:	2301      	movs	r3, #1
    2698:	002a      	movs	r2, r5
    269a:	4e10      	ldr	r6, [pc, #64]	; (26dc <sync_window+0x68>)
    269c:	47b0      	blx	r6
    269e:	0003      	movs	r3, r0
			res = FR_DISK_ERR;
    26a0:	2001      	movs	r0, #1
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
    26a2:	2b00      	cmp	r3, #0
    26a4:	d1ed      	bne.n	2682 <sync_window+0xe>
			fs->wflag = 0;
    26a6:	7123      	strb	r3, [r4, #4]
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
    26a8:	6a23      	ldr	r3, [r4, #32]
    26aa:	1aeb      	subs	r3, r5, r3
	FRESULT res = FR_OK;
    26ac:	2000      	movs	r0, #0
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
    26ae:	69a2      	ldr	r2, [r4, #24]
    26b0:	4293      	cmp	r3, r2
    26b2:	d2e6      	bcs.n	2682 <sync_window+0xe>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
    26b4:	78e6      	ldrb	r6, [r4, #3]
    26b6:	2e01      	cmp	r6, #1
    26b8:	d90d      	bls.n	26d6 <sync_window+0x62>
					disk_write(fs->drv, fs->win, wsect, 1);
    26ba:	4f08      	ldr	r7, [pc, #32]	; (26dc <sync_window+0x68>)
					wsect += fs->fsize;
    26bc:	69a3      	ldr	r3, [r4, #24]
    26be:	469c      	mov	ip, r3
    26c0:	4465      	add	r5, ip
					disk_write(fs->drv, fs->win, wsect, 1);
    26c2:	7860      	ldrb	r0, [r4, #1]
    26c4:	2301      	movs	r3, #1
    26c6:	002a      	movs	r2, r5
    26c8:	9901      	ldr	r1, [sp, #4]
    26ca:	47b8      	blx	r7
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
    26cc:	3e01      	subs	r6, #1
    26ce:	2e01      	cmp	r6, #1
    26d0:	d1f4      	bne.n	26bc <sync_window+0x48>
	FRESULT res = FR_OK;
    26d2:	2000      	movs	r0, #0
    26d4:	e7d5      	b.n	2682 <sync_window+0xe>
    26d6:	2000      	movs	r0, #0
    26d8:	e7d3      	b.n	2682 <sync_window+0xe>
    26da:	46c0      	nop			; (mov r8, r8)
    26dc:	00002565 	.word	0x00002565

000026e0 <move_window>:
{
    26e0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    26e2:	0005      	movs	r5, r0
    26e4:	000e      	movs	r6, r1
	FRESULT res = FR_OK;
    26e6:	2400      	movs	r4, #0
	if (sector != fs->winsect) {	/* Window offset changed? */
    26e8:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
    26ea:	428b      	cmp	r3, r1
    26ec:	d003      	beq.n	26f6 <move_window+0x16>
		res = sync_window(fs);		/* Write-back changes */
    26ee:	4b0a      	ldr	r3, [pc, #40]	; (2718 <move_window+0x38>)
    26f0:	4798      	blx	r3
    26f2:	1e04      	subs	r4, r0, #0
		if (res == FR_OK) {			/* Fill sector window with new data */
    26f4:	d001      	beq.n	26fa <move_window+0x1a>
}
    26f6:	0020      	movs	r0, r4
    26f8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
    26fa:	0029      	movs	r1, r5
    26fc:	3130      	adds	r1, #48	; 0x30
    26fe:	7868      	ldrb	r0, [r5, #1]
    2700:	2301      	movs	r3, #1
    2702:	0032      	movs	r2, r6
    2704:	4f05      	ldr	r7, [pc, #20]	; (271c <move_window+0x3c>)
    2706:	47b8      	blx	r7
    2708:	2800      	cmp	r0, #0
    270a:	d002      	beq.n	2712 <move_window+0x32>
				res = FR_DISK_ERR;
    270c:	3401      	adds	r4, #1
				sector = 0xFFFFFFFF;	/* Invalidate window if data is not reliable */
    270e:	2601      	movs	r6, #1
    2710:	4276      	negs	r6, r6
			fs->winsect = sector;
    2712:	62ee      	str	r6, [r5, #44]	; 0x2c
    2714:	e7ef      	b.n	26f6 <move_window+0x16>
    2716:	46c0      	nop			; (mov r8, r8)
    2718:	00002675 	.word	0x00002675
    271c:	0000253d 	.word	0x0000253d

00002720 <check_fs>:
static
BYTE check_fs (	/* 0:FAT boor sector, 1:Valid boor sector but not FAT, 2:Not a boot sector, 3:Disk error */
	FATFS* fs,	/* File system object */
	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
)
{
    2720:	b510      	push	{r4, lr}
    2722:	0004      	movs	r4, r0
	fs->wflag = 0; fs->winsect = 0xFFFFFFFF;	/* Invaidate window */
    2724:	2300      	movs	r3, #0
    2726:	7103      	strb	r3, [r0, #4]
    2728:	3b01      	subs	r3, #1
    272a:	62c3      	str	r3, [r0, #44]	; 0x2c
	if (move_window(fs, sect) != FR_OK)			/* Load boot record */
    272c:	4b1e      	ldr	r3, [pc, #120]	; (27a8 <check_fs+0x88>)
    272e:	4798      	blx	r3
		return 3;
    2730:	2303      	movs	r3, #3
	if (move_window(fs, sect) != FR_OK)			/* Load boot record */
    2732:	2800      	cmp	r0, #0
    2734:	d001      	beq.n	273a <check_fs+0x1a>
		return 0;
	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
		return 0;

	return 1;
}
    2736:	0018      	movs	r0, r3
    2738:	bd10      	pop	{r4, pc}
	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)	/* Check boot record signature (always placed at offset 510 even if the sector size is >512) */
    273a:	4b1c      	ldr	r3, [pc, #112]	; (27ac <check_fs+0x8c>)
    273c:	5ce3      	ldrb	r3, [r4, r3]
    273e:	021b      	lsls	r3, r3, #8
    2740:	4a1b      	ldr	r2, [pc, #108]	; (27b0 <check_fs+0x90>)
    2742:	5ca2      	ldrb	r2, [r4, r2]
    2744:	431a      	orrs	r2, r3
    2746:	491b      	ldr	r1, [pc, #108]	; (27b4 <check_fs+0x94>)
    2748:	b212      	sxth	r2, r2
		return 2;
    274a:	2302      	movs	r3, #2
	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)	/* Check boot record signature (always placed at offset 510 even if the sector size is >512) */
    274c:	428a      	cmp	r2, r1
    274e:	d1f2      	bne.n	2736 <check_fs+0x16>
	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)		/* Check "FAT" string */
    2750:	3367      	adds	r3, #103	; 0x67
    2752:	5ce3      	ldrb	r3, [r4, r3]
    2754:	061b      	lsls	r3, r3, #24
    2756:	2268      	movs	r2, #104	; 0x68
    2758:	5ca2      	ldrb	r2, [r4, r2]
    275a:	0412      	lsls	r2, r2, #16
    275c:	4313      	orrs	r3, r2
    275e:	2266      	movs	r2, #102	; 0x66
    2760:	5ca2      	ldrb	r2, [r4, r2]
    2762:	4313      	orrs	r3, r2
    2764:	2267      	movs	r2, #103	; 0x67
    2766:	5ca2      	ldrb	r2, [r4, r2]
    2768:	0212      	lsls	r2, r2, #8
    276a:	4313      	orrs	r3, r2
    276c:	021b      	lsls	r3, r3, #8
    276e:	0a1b      	lsrs	r3, r3, #8
    2770:	4a11      	ldr	r2, [pc, #68]	; (27b8 <check_fs+0x98>)
    2772:	4293      	cmp	r3, r2
    2774:	d016      	beq.n	27a4 <check_fs+0x84>
	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
    2776:	2385      	movs	r3, #133	; 0x85
    2778:	5ce3      	ldrb	r3, [r4, r3]
    277a:	061b      	lsls	r3, r3, #24
    277c:	2284      	movs	r2, #132	; 0x84
    277e:	5ca2      	ldrb	r2, [r4, r2]
    2780:	0412      	lsls	r2, r2, #16
    2782:	4313      	orrs	r3, r2
    2784:	2282      	movs	r2, #130	; 0x82
    2786:	5ca2      	ldrb	r2, [r4, r2]
    2788:	4313      	orrs	r3, r2
    278a:	2283      	movs	r2, #131	; 0x83
    278c:	5ca2      	ldrb	r2, [r4, r2]
    278e:	0212      	lsls	r2, r2, #8
    2790:	4313      	orrs	r3, r2
    2792:	021b      	lsls	r3, r3, #8
    2794:	0a1b      	lsrs	r3, r3, #8
    2796:	4a09      	ldr	r2, [pc, #36]	; (27bc <check_fs+0x9c>)
    2798:	4694      	mov	ip, r2
    279a:	4463      	add	r3, ip
    279c:	1e58      	subs	r0, r3, #1
    279e:	4183      	sbcs	r3, r0
		return 3;
    27a0:	b2db      	uxtb	r3, r3
    27a2:	e7c8      	b.n	2736 <check_fs+0x16>
		return 0;
    27a4:	2300      	movs	r3, #0
    27a6:	e7c6      	b.n	2736 <check_fs+0x16>
    27a8:	000026e1 	.word	0x000026e1
    27ac:	0000022f 	.word	0x0000022f
    27b0:	0000022e 	.word	0x0000022e
    27b4:	ffffaa55 	.word	0xffffaa55
    27b8:	00544146 	.word	0x00544146
    27bc:	ffabbeba 	.word	0xffabbeba

000027c0 <validate>:

static
FRESULT validate (	/* FR_OK(0): The object is valid, !=0: Invalid */
	void* obj		/* Pointer to the object FIL/DIR to check validity */
)
{
    27c0:	b510      	push	{r4, lr}
	FIL *fil = (FIL*)obj;	/* Assuming offset of .fs and .id in the FIL/DIR structure is identical */


	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
    27c2:	2800      	cmp	r0, #0
    27c4:	d014      	beq.n	27f0 <validate+0x30>
    27c6:	6802      	ldr	r2, [r0, #0]
    27c8:	2a00      	cmp	r2, #0
    27ca:	d013      	beq.n	27f4 <validate+0x34>
    27cc:	7811      	ldrb	r1, [r2, #0]
		return FR_INVALID_OBJECT;
    27ce:	2309      	movs	r3, #9
	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
    27d0:	2900      	cmp	r1, #0
    27d2:	d101      	bne.n	27d8 <validate+0x18>

	if (disk_status(fil->fs->drv) & STA_NOINIT)
		return FR_NOT_READY;

	return FR_OK;
}
    27d4:	0018      	movs	r0, r3
    27d6:	bd10      	pop	{r4, pc}
	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
    27d8:	88d4      	ldrh	r4, [r2, #6]
    27da:	8881      	ldrh	r1, [r0, #4]
    27dc:	428c      	cmp	r4, r1
    27de:	d1f9      	bne.n	27d4 <validate+0x14>
	if (disk_status(fil->fs->drv) & STA_NOINIT)
    27e0:	7850      	ldrb	r0, [r2, #1]
    27e2:	4b05      	ldr	r3, [pc, #20]	; (27f8 <validate+0x38>)
    27e4:	4798      	blx	r3
		return FR_NOT_READY;
    27e6:	2303      	movs	r3, #3
	return FR_OK;
    27e8:	07c0      	lsls	r0, r0, #31
    27ea:	17c0      	asrs	r0, r0, #31
    27ec:	4003      	ands	r3, r0
    27ee:	e7f1      	b.n	27d4 <validate+0x14>
		return FR_INVALID_OBJECT;
    27f0:	2309      	movs	r3, #9
    27f2:	e7ef      	b.n	27d4 <validate+0x14>
    27f4:	2309      	movs	r3, #9
    27f6:	e7ed      	b.n	27d4 <validate+0x14>
    27f8:	0000251d 	.word	0x0000251d

000027fc <find_volume>:
{
    27fc:	b5f0      	push	{r4, r5, r6, r7, lr}
    27fe:	46d6      	mov	lr, sl
    2800:	464f      	mov	r7, r9
    2802:	4646      	mov	r6, r8
    2804:	b5c0      	push	{r6, r7, lr}
    2806:	b084      	sub	sp, #16
    2808:	0007      	movs	r7, r0
    280a:	0016      	movs	r6, r2
	*rfs = 0;
    280c:	2300      	movs	r3, #0
    280e:	6003      	str	r3, [r0, #0]
	vol = get_ldnumber(path);
    2810:	0008      	movs	r0, r1
    2812:	4b9f      	ldr	r3, [pc, #636]	; (2a90 <find_volume+0x294>)
    2814:	4798      	blx	r3
    2816:	0004      	movs	r4, r0
	if (vol < 0) return FR_INVALID_DRIVE;
    2818:	230b      	movs	r3, #11
    281a:	2800      	cmp	r0, #0
    281c:	db1f      	blt.n	285e <find_volume+0x62>
	fs = FatFs[vol];					/* Get pointer to the file system object */
    281e:	0083      	lsls	r3, r0, #2
    2820:	4a9c      	ldr	r2, [pc, #624]	; (2a94 <find_volume+0x298>)
    2822:	589d      	ldr	r5, [r3, r2]
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
    2824:	2d00      	cmp	r5, #0
    2826:	d100      	bne.n	282a <find_volume+0x2e>
    2828:	e1a7      	b.n	2b7a <find_volume+0x37e>
	*rfs = fs;							/* Return pointer to the file system object */
    282a:	603d      	str	r5, [r7, #0]
	if (fs->fs_type) {					/* If the volume has been mounted */
    282c:	782b      	ldrb	r3, [r5, #0]
    282e:	2b00      	cmp	r3, #0
    2830:	d00c      	beq.n	284c <find_volume+0x50>
		stat = disk_status(fs->drv);
    2832:	7868      	ldrb	r0, [r5, #1]
    2834:	4b98      	ldr	r3, [pc, #608]	; (2a98 <find_volume+0x29c>)
    2836:	4798      	blx	r3
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized */
    2838:	07c3      	lsls	r3, r0, #31
    283a:	d407      	bmi.n	284c <find_volume+0x50>
			return FR_OK;				/* The file system object is valid */
    283c:	2300      	movs	r3, #0
			if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check write protection if needed */
    283e:	2e00      	cmp	r6, #0
    2840:	d00d      	beq.n	285e <find_volume+0x62>
    2842:	0743      	lsls	r3, r0, #29
    2844:	d400      	bmi.n	2848 <find_volume+0x4c>
    2846:	e19a      	b.n	2b7e <find_volume+0x382>
				return FR_WRITE_PROTECTED;
    2848:	230a      	movs	r3, #10
    284a:	e008      	b.n	285e <find_volume+0x62>
	fs->fs_type = 0;					/* Clear the file system object */
    284c:	2300      	movs	r3, #0
    284e:	702b      	strb	r3, [r5, #0]
	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
    2850:	b2e0      	uxtb	r0, r4
    2852:	7068      	strb	r0, [r5, #1]
	stat = disk_initialize(fs->drv);	/* Initialize the physical drive */
    2854:	4b91      	ldr	r3, [pc, #580]	; (2a9c <find_volume+0x2a0>)
    2856:	4798      	blx	r3
		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
    2858:	2303      	movs	r3, #3
	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
    285a:	07c2      	lsls	r2, r0, #31
    285c:	d506      	bpl.n	286c <find_volume+0x70>
}
    285e:	0018      	movs	r0, r3
    2860:	b004      	add	sp, #16
    2862:	bc1c      	pop	{r2, r3, r4}
    2864:	4690      	mov	r8, r2
    2866:	4699      	mov	r9, r3
    2868:	46a2      	mov	sl, r4
    286a:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check disk write protection if needed */
    286c:	2e00      	cmp	r6, #0
    286e:	d002      	beq.n	2876 <find_volume+0x7a>
		return FR_WRITE_PROTECTED;
    2870:	3307      	adds	r3, #7
	if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check disk write protection if needed */
    2872:	0742      	lsls	r2, r0, #29
    2874:	d4f3      	bmi.n	285e <find_volume+0x62>
	fmt = check_fs(fs, bsect);					/* Load sector 0 and check if it is an FAT boot sector as SFD */
    2876:	2100      	movs	r1, #0
    2878:	0028      	movs	r0, r5
    287a:	4b89      	ldr	r3, [pc, #548]	; (2aa0 <find_volume+0x2a4>)
    287c:	4798      	blx	r3
	bsect = 0;
    287e:	2700      	movs	r7, #0
	if (fmt == 1 || (!fmt && (LD2PT(vol)))) {	/* Not an FAT boot sector or forced partition number */
    2880:	2801      	cmp	r0, #1
    2882:	d100      	bne.n	2886 <find_volume+0x8a>
    2884:	e0b4      	b.n	29f0 <find_volume+0x1f4>
	if (fmt == 3) return FR_DISK_ERR;		/* An error occured in the disk I/O layer */
    2886:	2803      	cmp	r0, #3
    2888:	d100      	bne.n	288c <find_volume+0x90>
    288a:	e17a      	b.n	2b82 <find_volume+0x386>
	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
    288c:	230d      	movs	r3, #13
    288e:	2800      	cmp	r0, #0
    2890:	d1e5      	bne.n	285e <find_volume+0x62>
	if (LD_WORD(fs->win + BPB_BytsPerSec) != SS(fs))	/* (BPB_BytsPerSec must be equal to the physical sector size) */
    2892:	233c      	movs	r3, #60	; 0x3c
    2894:	5ceb      	ldrb	r3, [r5, r3]
    2896:	021b      	lsls	r3, r3, #8
    2898:	223b      	movs	r2, #59	; 0x3b
    289a:	5caa      	ldrb	r2, [r5, r2]
    289c:	431a      	orrs	r2, r3
    289e:	2180      	movs	r1, #128	; 0x80
    28a0:	0089      	lsls	r1, r1, #2
    28a2:	b212      	sxth	r2, r2
		return FR_NO_FILESYSTEM;
    28a4:	230d      	movs	r3, #13
	if (LD_WORD(fs->win + BPB_BytsPerSec) != SS(fs))	/* (BPB_BytsPerSec must be equal to the physical sector size) */
    28a6:	428a      	cmp	r2, r1
    28a8:	d1d9      	bne.n	285e <find_volume+0x62>
	fasize = LD_WORD(fs->win + BPB_FATSz16);			/* Number of sectors per FAT */
    28aa:	333a      	adds	r3, #58	; 0x3a
    28ac:	5ceb      	ldrb	r3, [r5, r3]
    28ae:	021b      	lsls	r3, r3, #8
    28b0:	2246      	movs	r2, #70	; 0x46
    28b2:	5cac      	ldrb	r4, [r5, r2]
    28b4:	431c      	orrs	r4, r3
	if (!fasize) fasize = LD_DWORD(fs->win + BPB_FATSz32);
    28b6:	d10d      	bne.n	28d4 <find_volume+0xd8>
    28b8:	2357      	movs	r3, #87	; 0x57
    28ba:	5cec      	ldrb	r4, [r5, r3]
    28bc:	0624      	lsls	r4, r4, #24
    28be:	3b01      	subs	r3, #1
    28c0:	5ceb      	ldrb	r3, [r5, r3]
    28c2:	041b      	lsls	r3, r3, #16
    28c4:	431c      	orrs	r4, r3
    28c6:	2354      	movs	r3, #84	; 0x54
    28c8:	5ceb      	ldrb	r3, [r5, r3]
    28ca:	431c      	orrs	r4, r3
    28cc:	2355      	movs	r3, #85	; 0x55
    28ce:	5ceb      	ldrb	r3, [r5, r3]
    28d0:	021b      	lsls	r3, r3, #8
    28d2:	431c      	orrs	r4, r3
	fs->fsize = fasize;
    28d4:	61ac      	str	r4, [r5, #24]
	fs->n_fats = fs->win[BPB_NumFATs];					/* Number of FAT copies */
    28d6:	2340      	movs	r3, #64	; 0x40
    28d8:	5cea      	ldrb	r2, [r5, r3]
    28da:	70ea      	strb	r2, [r5, #3]
	if (fs->n_fats != 1 && fs->n_fats != 2)				/* (Must be 1 or 2) */
    28dc:	1e51      	subs	r1, r2, #1
		return FR_NO_FILESYSTEM;
    28de:	3b33      	subs	r3, #51	; 0x33
	if (fs->n_fats != 1 && fs->n_fats != 2)				/* (Must be 1 or 2) */
    28e0:	2901      	cmp	r1, #1
    28e2:	d8bc      	bhi.n	285e <find_volume+0x62>
	fs->csize = fs->win[BPB_SecPerClus];				/* Number of sectors per cluster */
    28e4:	3330      	adds	r3, #48	; 0x30
    28e6:	5ce9      	ldrb	r1, [r5, r3]
    28e8:	70a9      	strb	r1, [r5, #2]
		return FR_NO_FILESYSTEM;
    28ea:	3b30      	subs	r3, #48	; 0x30
	if (!fs->csize || (fs->csize & (fs->csize - 1)))	/* (Must be power of 2) */
    28ec:	2900      	cmp	r1, #0
    28ee:	d0b6      	beq.n	285e <find_volume+0x62>
    28f0:	1e48      	subs	r0, r1, #1
    28f2:	4201      	tst	r1, r0
    28f4:	d1b3      	bne.n	285e <find_volume+0x62>
	fs->n_rootdir = LD_WORD(fs->win + BPB_RootEntCnt);	/* Number of root directory entries */
    28f6:	3335      	adds	r3, #53	; 0x35
    28f8:	5ceb      	ldrb	r3, [r5, r3]
    28fa:	021b      	lsls	r3, r3, #8
    28fc:	2041      	movs	r0, #65	; 0x41
    28fe:	5c28      	ldrb	r0, [r5, r0]
    2900:	4318      	orrs	r0, r3
    2902:	4682      	mov	sl, r0
    2904:	8128      	strh	r0, [r5, #8]
		return FR_NO_FILESYSTEM;
    2906:	230d      	movs	r3, #13
	if (fs->n_rootdir % (SS(fs) / SZ_DIRE))				/* (Must be sector aligned) */
    2908:	0700      	lsls	r0, r0, #28
    290a:	d1a8      	bne.n	285e <find_volume+0x62>
	tsect = LD_WORD(fs->win + BPB_TotSec16);			/* Number of sectors on the volume */
    290c:	3337      	adds	r3, #55	; 0x37
    290e:	5ceb      	ldrb	r3, [r5, r3]
    2910:	021b      	lsls	r3, r3, #8
    2912:	2043      	movs	r0, #67	; 0x43
    2914:	5c28      	ldrb	r0, [r5, r0]
    2916:	4318      	orrs	r0, r3
	if (!tsect) tsect = LD_DWORD(fs->win + BPB_TotSec32);
    2918:	d10d      	bne.n	2936 <find_volume+0x13a>
    291a:	2353      	movs	r3, #83	; 0x53
    291c:	5ce8      	ldrb	r0, [r5, r3]
    291e:	0600      	lsls	r0, r0, #24
    2920:	3b01      	subs	r3, #1
    2922:	5ceb      	ldrb	r3, [r5, r3]
    2924:	041b      	lsls	r3, r3, #16
    2926:	4318      	orrs	r0, r3
    2928:	2350      	movs	r3, #80	; 0x50
    292a:	5ceb      	ldrb	r3, [r5, r3]
    292c:	4318      	orrs	r0, r3
    292e:	2351      	movs	r3, #81	; 0x51
    2930:	5ceb      	ldrb	r3, [r5, r3]
    2932:	021b      	lsls	r3, r3, #8
    2934:	4318      	orrs	r0, r3
	nrsv = LD_WORD(fs->win + BPB_RsvdSecCnt);			/* Number of reserved sectors */
    2936:	233f      	movs	r3, #63	; 0x3f
    2938:	5ceb      	ldrb	r3, [r5, r3]
    293a:	021b      	lsls	r3, r3, #8
    293c:	263e      	movs	r6, #62	; 0x3e
    293e:	5dae      	ldrb	r6, [r5, r6]
    2940:	431e      	orrs	r6, r3
    2942:	46b0      	mov	r8, r6
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (Must not be 0) */
    2944:	230d      	movs	r3, #13
    2946:	2e00      	cmp	r6, #0
    2948:	d100      	bne.n	294c <find_volume+0x150>
    294a:	e788      	b.n	285e <find_volume+0x62>
	fasize *= fs->n_fats;								/* Number of sectors for FAT area */
    294c:	4362      	muls	r2, r4
    294e:	4691      	mov	r9, r2
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIRE);	/* RSV + FAT + DIR */
    2950:	4653      	mov	r3, sl
    2952:	091e      	lsrs	r6, r3, #4
    2954:	4446      	add	r6, r8
    2956:	444e      	add	r6, r9
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
    2958:	230d      	movs	r3, #13
    295a:	42b0      	cmp	r0, r6
    295c:	d200      	bcs.n	2960 <find_volume+0x164>
    295e:	e77e      	b.n	285e <find_volume+0x62>
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
    2960:	1b80      	subs	r0, r0, r6
    2962:	4b50      	ldr	r3, [pc, #320]	; (2aa4 <find_volume+0x2a8>)
    2964:	4798      	blx	r3
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
    2966:	230d      	movs	r3, #13
    2968:	2800      	cmp	r0, #0
    296a:	d100      	bne.n	296e <find_volume+0x172>
    296c:	e777      	b.n	285e <find_volume+0x62>
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
    296e:	4a4e      	ldr	r2, [pc, #312]	; (2aa8 <find_volume+0x2ac>)
    2970:	4282      	cmp	r2, r0
    2972:	4192      	sbcs	r2, r2
    2974:	4252      	negs	r2, r2
    2976:	3201      	adds	r2, #1
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
    2978:	4b4c      	ldr	r3, [pc, #304]	; (2aac <find_volume+0x2b0>)
    297a:	4298      	cmp	r0, r3
    297c:	d900      	bls.n	2980 <find_volume+0x184>
    297e:	e102      	b.n	2b86 <find_volume+0x38a>
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
    2980:	3002      	adds	r0, #2
    2982:	6168      	str	r0, [r5, #20]
	fs->volbase = bsect;								/* Volume start sector */
    2984:	61ef      	str	r7, [r5, #28]
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
    2986:	4643      	mov	r3, r8
    2988:	19d9      	adds	r1, r3, r7
    298a:	6229      	str	r1, [r5, #32]
	fs->database = bsect + sysect;						/* Data start sector */
    298c:	19f6      	adds	r6, r6, r7
    298e:	62ae      	str	r6, [r5, #40]	; 0x28
	if (fmt == FS_FAT32) {
    2990:	2a03      	cmp	r2, #3
    2992:	d15b      	bne.n	2a4c <find_volume+0x250>
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
    2994:	230d      	movs	r3, #13
    2996:	4652      	mov	r2, sl
    2998:	2a00      	cmp	r2, #0
    299a:	d000      	beq.n	299e <find_volume+0x1a2>
    299c:	e75f      	b.n	285e <find_volume+0x62>
		fs->dirbase = LD_DWORD(fs->win + BPB_RootClus);	/* Root directory start cluster */
    299e:	3352      	adds	r3, #82	; 0x52
    29a0:	5ceb      	ldrb	r3, [r5, r3]
    29a2:	061b      	lsls	r3, r3, #24
    29a4:	325e      	adds	r2, #94	; 0x5e
    29a6:	5caa      	ldrb	r2, [r5, r2]
    29a8:	0412      	lsls	r2, r2, #16
    29aa:	4313      	orrs	r3, r2
    29ac:	225c      	movs	r2, #92	; 0x5c
    29ae:	5caa      	ldrb	r2, [r5, r2]
    29b0:	4313      	orrs	r3, r2
    29b2:	225d      	movs	r2, #93	; 0x5d
    29b4:	5caa      	ldrb	r2, [r5, r2]
    29b6:	0212      	lsls	r2, r2, #8
    29b8:	4313      	orrs	r3, r2
    29ba:	626b      	str	r3, [r5, #36]	; 0x24
		szbfat = fs->n_fatent * 4;						/* (Needed FAT size) */
    29bc:	0082      	lsls	r2, r0, #2
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than the size needed) */
    29be:	4b3c      	ldr	r3, [pc, #240]	; (2ab0 <find_volume+0x2b4>)
    29c0:	469c      	mov	ip, r3
    29c2:	4462      	add	r2, ip
    29c4:	0a52      	lsrs	r2, r2, #9
		return FR_NO_FILESYSTEM;
    29c6:	3bf3      	subs	r3, #243	; 0xf3
    29c8:	3bff      	subs	r3, #255	; 0xff
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than the size needed) */
    29ca:	4294      	cmp	r4, r2
    29cc:	d200      	bcs.n	29d0 <find_volume+0x1d4>
    29ce:	e746      	b.n	285e <find_volume+0x62>
	fs->last_clust = fs->free_clust = 0xFFFFFFFF;
    29d0:	2301      	movs	r3, #1
    29d2:	425b      	negs	r3, r3
    29d4:	612b      	str	r3, [r5, #16]
    29d6:	60eb      	str	r3, [r5, #12]
	fs->fsi_flag = 0x80;
    29d8:	3381      	adds	r3, #129	; 0x81
    29da:	716b      	strb	r3, [r5, #5]
		&& LD_WORD(fs->win + BPB_FSInfo) == 1
    29dc:	3b1f      	subs	r3, #31
    29de:	5cea      	ldrb	r2, [r5, r3]
    29e0:	0212      	lsls	r2, r2, #8
    29e2:	3b01      	subs	r3, #1
    29e4:	5ceb      	ldrb	r3, [r5, r3]
    29e6:	4313      	orrs	r3, r2
    29e8:	2b01      	cmp	r3, #1
    29ea:	d063      	beq.n	2ab4 <find_volume+0x2b8>
    29ec:	2203      	movs	r2, #3
    29ee:	e0bb      	b.n	2b68 <find_volume+0x36c>
    29f0:	002a      	movs	r2, r5
    29f2:	32f3      	adds	r2, #243	; 0xf3
    29f4:	32ff      	adds	r2, #255	; 0xff
	if (fmt == 1 || (!fmt && (LD2PT(vol)))) {	/* Not an FAT boot sector or forced partition number */
    29f6:	2000      	movs	r0, #0
			br[i] = pt[4] ? LD_DWORD(&pt[8]) : 0;
    29f8:	2100      	movs	r1, #0
    29fa:	e005      	b.n	2a08 <find_volume+0x20c>
    29fc:	466c      	mov	r4, sp
    29fe:	5103      	str	r3, [r0, r4]
    2a00:	3210      	adds	r2, #16
    2a02:	3004      	adds	r0, #4
		for (i = 0; i < 4; i++) {			/* Get partition offset */
    2a04:	2810      	cmp	r0, #16
    2a06:	d00e      	beq.n	2a26 <find_volume+0x22a>
			br[i] = pt[4] ? LD_DWORD(&pt[8]) : 0;
    2a08:	7814      	ldrb	r4, [r2, #0]
    2a0a:	000b      	movs	r3, r1
    2a0c:	2c00      	cmp	r4, #0
    2a0e:	d0f5      	beq.n	29fc <find_volume+0x200>
    2a10:	79d3      	ldrb	r3, [r2, #7]
    2a12:	061b      	lsls	r3, r3, #24
    2a14:	7994      	ldrb	r4, [r2, #6]
    2a16:	0424      	lsls	r4, r4, #16
    2a18:	4323      	orrs	r3, r4
    2a1a:	7914      	ldrb	r4, [r2, #4]
    2a1c:	4323      	orrs	r3, r4
    2a1e:	7954      	ldrb	r4, [r2, #5]
    2a20:	0224      	lsls	r4, r4, #8
    2a22:	4323      	orrs	r3, r4
    2a24:	e7ea      	b.n	29fc <find_volume+0x200>
    2a26:	2600      	movs	r6, #0
			fmt = bsect ? check_fs(fs, bsect) : 2;	/* Check the partition */
    2a28:	2402      	movs	r4, #2
    2a2a:	e003      	b.n	2a34 <find_volume+0x238>
    2a2c:	3604      	adds	r6, #4
		} while (!LD2PT(vol) && fmt && ++i < 4);
    2a2e:	2e10      	cmp	r6, #16
    2a30:	d100      	bne.n	2a34 <find_volume+0x238>
    2a32:	e728      	b.n	2886 <find_volume+0x8a>
			bsect = br[i];
    2a34:	466b      	mov	r3, sp
    2a36:	58f7      	ldr	r7, [r6, r3]
			fmt = bsect ? check_fs(fs, bsect) : 2;	/* Check the partition */
    2a38:	0020      	movs	r0, r4
    2a3a:	2f00      	cmp	r7, #0
    2a3c:	d0f6      	beq.n	2a2c <find_volume+0x230>
    2a3e:	0039      	movs	r1, r7
    2a40:	0028      	movs	r0, r5
    2a42:	4b17      	ldr	r3, [pc, #92]	; (2aa0 <find_volume+0x2a4>)
    2a44:	4798      	blx	r3
		} while (!LD2PT(vol) && fmt && ++i < 4);
    2a46:	2800      	cmp	r0, #0
    2a48:	d1f0      	bne.n	2a2c <find_volume+0x230>
    2a4a:	e722      	b.n	2892 <find_volume+0x96>
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
    2a4c:	230d      	movs	r3, #13
    2a4e:	4656      	mov	r6, sl
    2a50:	2e00      	cmp	r6, #0
    2a52:	d100      	bne.n	2a56 <find_volume+0x25a>
    2a54:	e703      	b.n	285e <find_volume+0x62>
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
    2a56:	4449      	add	r1, r9
    2a58:	6269      	str	r1, [r5, #36]	; 0x24
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
    2a5a:	2a02      	cmp	r2, #2
    2a5c:	d110      	bne.n	2a80 <find_volume+0x284>
    2a5e:	0040      	lsls	r0, r0, #1
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than the size needed) */
    2a60:	4b13      	ldr	r3, [pc, #76]	; (2ab0 <find_volume+0x2b4>)
    2a62:	469c      	mov	ip, r3
    2a64:	4460      	add	r0, ip
    2a66:	0a40      	lsrs	r0, r0, #9
		return FR_NO_FILESYSTEM;
    2a68:	3bf3      	subs	r3, #243	; 0xf3
    2a6a:	3bff      	subs	r3, #255	; 0xff
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than the size needed) */
    2a6c:	4284      	cmp	r4, r0
    2a6e:	d200      	bcs.n	2a72 <find_volume+0x276>
    2a70:	e6f5      	b.n	285e <find_volume+0x62>
	fs->last_clust = fs->free_clust = 0xFFFFFFFF;
    2a72:	2301      	movs	r3, #1
    2a74:	425b      	negs	r3, r3
    2a76:	612b      	str	r3, [r5, #16]
    2a78:	60eb      	str	r3, [r5, #12]
	fs->fsi_flag = 0x80;
    2a7a:	3381      	adds	r3, #129	; 0x81
    2a7c:	716b      	strb	r3, [r5, #5]
    2a7e:	e073      	b.n	2b68 <find_volume+0x36c>
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
    2a80:	2303      	movs	r3, #3
    2a82:	4343      	muls	r3, r0
    2a84:	085b      	lsrs	r3, r3, #1
    2a86:	2101      	movs	r1, #1
    2a88:	4008      	ands	r0, r1
    2a8a:	1818      	adds	r0, r3, r0
    2a8c:	e7e8      	b.n	2a60 <find_volume+0x264>
    2a8e:	46c0      	nop			; (mov r8, r8)
    2a90:	0000261f 	.word	0x0000261f
    2a94:	20000458 	.word	0x20000458
    2a98:	0000251d 	.word	0x0000251d
    2a9c:	00002525 	.word	0x00002525
    2aa0:	00002721 	.word	0x00002721
    2aa4:	0000412d 	.word	0x0000412d
    2aa8:	00000ff5 	.word	0x00000ff5
    2aac:	0000fff5 	.word	0x0000fff5
    2ab0:	000001ff 	.word	0x000001ff
		&& move_window(fs, bsect + 1) == FR_OK)
    2ab4:	1c79      	adds	r1, r7, #1
    2ab6:	0028      	movs	r0, r5
    2ab8:	4b37      	ldr	r3, [pc, #220]	; (2b98 <find_volume+0x39c>)
    2aba:	4798      	blx	r3
    2abc:	2203      	movs	r2, #3
    2abe:	2800      	cmp	r0, #0
    2ac0:	d152      	bne.n	2b68 <find_volume+0x36c>
		fs->fsi_flag = 0;
    2ac2:	2300      	movs	r3, #0
    2ac4:	716b      	strb	r3, [r5, #5]
		if (LD_WORD(fs->win + BS_55AA) == 0xAA55	/* Load FSINFO data if available */
    2ac6:	4b35      	ldr	r3, [pc, #212]	; (2b9c <find_volume+0x3a0>)
    2ac8:	5cea      	ldrb	r2, [r5, r3]
    2aca:	0212      	lsls	r2, r2, #8
    2acc:	4b34      	ldr	r3, [pc, #208]	; (2ba0 <find_volume+0x3a4>)
    2ace:	5ceb      	ldrb	r3, [r5, r3]
    2ad0:	4313      	orrs	r3, r2
    2ad2:	4934      	ldr	r1, [pc, #208]	; (2ba4 <find_volume+0x3a8>)
    2ad4:	b21b      	sxth	r3, r3
    2ad6:	2203      	movs	r2, #3
    2ad8:	428b      	cmp	r3, r1
    2ada:	d145      	bne.n	2b68 <find_volume+0x36c>
			&& LD_DWORD(fs->win + FSI_LeadSig) == 0x41615252
    2adc:	2333      	movs	r3, #51	; 0x33
    2ade:	5ceb      	ldrb	r3, [r5, r3]
    2ae0:	061b      	lsls	r3, r3, #24
    2ae2:	322f      	adds	r2, #47	; 0x2f
    2ae4:	5caa      	ldrb	r2, [r5, r2]
    2ae6:	0412      	lsls	r2, r2, #16
    2ae8:	4313      	orrs	r3, r2
    2aea:	2230      	movs	r2, #48	; 0x30
    2aec:	5caa      	ldrb	r2, [r5, r2]
    2aee:	4313      	orrs	r3, r2
    2af0:	2231      	movs	r2, #49	; 0x31
    2af2:	5caa      	ldrb	r2, [r5, r2]
    2af4:	0212      	lsls	r2, r2, #8
    2af6:	4313      	orrs	r3, r2
    2af8:	492b      	ldr	r1, [pc, #172]	; (2ba8 <find_volume+0x3ac>)
    2afa:	2203      	movs	r2, #3
    2afc:	428b      	cmp	r3, r1
    2afe:	d133      	bne.n	2b68 <find_volume+0x36c>
			&& LD_DWORD(fs->win + FSI_StrucSig) == 0x61417272)
    2b00:	4b2a      	ldr	r3, [pc, #168]	; (2bac <find_volume+0x3b0>)
    2b02:	5ceb      	ldrb	r3, [r5, r3]
    2b04:	061b      	lsls	r3, r3, #24
    2b06:	4a2a      	ldr	r2, [pc, #168]	; (2bb0 <find_volume+0x3b4>)
    2b08:	5caa      	ldrb	r2, [r5, r2]
    2b0a:	0412      	lsls	r2, r2, #16
    2b0c:	4313      	orrs	r3, r2
    2b0e:	2285      	movs	r2, #133	; 0x85
    2b10:	0092      	lsls	r2, r2, #2
    2b12:	5caa      	ldrb	r2, [r5, r2]
    2b14:	4313      	orrs	r3, r2
    2b16:	4a27      	ldr	r2, [pc, #156]	; (2bb4 <find_volume+0x3b8>)
    2b18:	5caa      	ldrb	r2, [r5, r2]
    2b1a:	0212      	lsls	r2, r2, #8
    2b1c:	4313      	orrs	r3, r2
    2b1e:	4926      	ldr	r1, [pc, #152]	; (2bb8 <find_volume+0x3bc>)
    2b20:	2203      	movs	r2, #3
    2b22:	428b      	cmp	r3, r1
    2b24:	d120      	bne.n	2b68 <find_volume+0x36c>
			fs->free_clust = LD_DWORD(fs->win + FSI_Free_Count);
    2b26:	4b25      	ldr	r3, [pc, #148]	; (2bbc <find_volume+0x3c0>)
    2b28:	5ceb      	ldrb	r3, [r5, r3]
    2b2a:	061b      	lsls	r3, r3, #24
    2b2c:	4a24      	ldr	r2, [pc, #144]	; (2bc0 <find_volume+0x3c4>)
    2b2e:	5caa      	ldrb	r2, [r5, r2]
    2b30:	0412      	lsls	r2, r2, #16
    2b32:	4313      	orrs	r3, r2
    2b34:	2286      	movs	r2, #134	; 0x86
    2b36:	0092      	lsls	r2, r2, #2
    2b38:	5caa      	ldrb	r2, [r5, r2]
    2b3a:	4313      	orrs	r3, r2
    2b3c:	4a21      	ldr	r2, [pc, #132]	; (2bc4 <find_volume+0x3c8>)
    2b3e:	5caa      	ldrb	r2, [r5, r2]
    2b40:	0212      	lsls	r2, r2, #8
    2b42:	4313      	orrs	r3, r2
    2b44:	612b      	str	r3, [r5, #16]
			fs->last_clust = LD_DWORD(fs->win + FSI_Nxt_Free);
    2b46:	4b20      	ldr	r3, [pc, #128]	; (2bc8 <find_volume+0x3cc>)
    2b48:	5ceb      	ldrb	r3, [r5, r3]
    2b4a:	061b      	lsls	r3, r3, #24
    2b4c:	4a1f      	ldr	r2, [pc, #124]	; (2bcc <find_volume+0x3d0>)
    2b4e:	5caa      	ldrb	r2, [r5, r2]
    2b50:	0412      	lsls	r2, r2, #16
    2b52:	4313      	orrs	r3, r2
    2b54:	2287      	movs	r2, #135	; 0x87
    2b56:	0092      	lsls	r2, r2, #2
    2b58:	5caa      	ldrb	r2, [r5, r2]
    2b5a:	4313      	orrs	r3, r2
    2b5c:	4a1c      	ldr	r2, [pc, #112]	; (2bd0 <find_volume+0x3d4>)
    2b5e:	5caa      	ldrb	r2, [r5, r2]
    2b60:	0212      	lsls	r2, r2, #8
    2b62:	4313      	orrs	r3, r2
    2b64:	60eb      	str	r3, [r5, #12]
    2b66:	2203      	movs	r2, #3
	fs->fs_type = fmt;	/* FAT sub-type */
    2b68:	702a      	strb	r2, [r5, #0]
	fs->id = ++Fsid;	/* File system mount ID */
    2b6a:	4a1a      	ldr	r2, [pc, #104]	; (2bd4 <find_volume+0x3d8>)
    2b6c:	8893      	ldrh	r3, [r2, #4]
    2b6e:	3301      	adds	r3, #1
    2b70:	b29b      	uxth	r3, r3
    2b72:	8093      	strh	r3, [r2, #4]
    2b74:	80eb      	strh	r3, [r5, #6]
	return FR_OK;
    2b76:	2300      	movs	r3, #0
    2b78:	e671      	b.n	285e <find_volume+0x62>
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
    2b7a:	230c      	movs	r3, #12
    2b7c:	e66f      	b.n	285e <find_volume+0x62>
			return FR_OK;				/* The file system object is valid */
    2b7e:	2300      	movs	r3, #0
    2b80:	e66d      	b.n	285e <find_volume+0x62>
	if (fmt == 3) return FR_DISK_ERR;		/* An error occured in the disk I/O layer */
    2b82:	2301      	movs	r3, #1
    2b84:	e66b      	b.n	285e <find_volume+0x62>
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
    2b86:	3002      	adds	r0, #2
    2b88:	6168      	str	r0, [r5, #20]
	fs->volbase = bsect;								/* Volume start sector */
    2b8a:	61ef      	str	r7, [r5, #28]
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
    2b8c:	4643      	mov	r3, r8
    2b8e:	19db      	adds	r3, r3, r7
    2b90:	622b      	str	r3, [r5, #32]
	fs->database = bsect + sysect;						/* Data start sector */
    2b92:	19f6      	adds	r6, r6, r7
    2b94:	62ae      	str	r6, [r5, #40]	; 0x28
    2b96:	e6fd      	b.n	2994 <find_volume+0x198>
    2b98:	000026e1 	.word	0x000026e1
    2b9c:	0000022f 	.word	0x0000022f
    2ba0:	0000022e 	.word	0x0000022e
    2ba4:	ffffaa55 	.word	0xffffaa55
    2ba8:	41615252 	.word	0x41615252
    2bac:	00000217 	.word	0x00000217
    2bb0:	00000216 	.word	0x00000216
    2bb4:	00000215 	.word	0x00000215
    2bb8:	61417272 	.word	0x61417272
    2bbc:	0000021b 	.word	0x0000021b
    2bc0:	0000021a 	.word	0x0000021a
    2bc4:	00000219 	.word	0x00000219
    2bc8:	0000021f 	.word	0x0000021f
    2bcc:	0000021e 	.word	0x0000021e
    2bd0:	0000021d 	.word	0x0000021d
    2bd4:	20000458 	.word	0x20000458

00002bd8 <sync_fs>:
{
    2bd8:	b570      	push	{r4, r5, r6, lr}
    2bda:	0004      	movs	r4, r0
	res = sync_window(fs);
    2bdc:	4b2d      	ldr	r3, [pc, #180]	; (2c94 <sync_fs+0xbc>)
    2bde:	4798      	blx	r3
	if (res == FR_OK) {
    2be0:	2800      	cmp	r0, #0
    2be2:	d10a      	bne.n	2bfa <sync_fs+0x22>
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) {
    2be4:	7823      	ldrb	r3, [r4, #0]
    2be6:	2b03      	cmp	r3, #3
    2be8:	d008      	beq.n	2bfc <sync_fs+0x24>
		if (disk_ioctl(fs->drv, CTRL_SYNC, 0) != RES_OK)
    2bea:	7860      	ldrb	r0, [r4, #1]
    2bec:	2200      	movs	r2, #0
    2bee:	2100      	movs	r1, #0
    2bf0:	4b29      	ldr	r3, [pc, #164]	; (2c98 <sync_fs+0xc0>)
    2bf2:	4798      	blx	r3
    2bf4:	1e43      	subs	r3, r0, #1
    2bf6:	4198      	sbcs	r0, r3
	res = sync_window(fs);
    2bf8:	b2c0      	uxtb	r0, r0
}
    2bfa:	bd70      	pop	{r4, r5, r6, pc}
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) {
    2bfc:	7963      	ldrb	r3, [r4, #5]
    2bfe:	2b01      	cmp	r3, #1
    2c00:	d1f3      	bne.n	2bea <sync_fs+0x12>
			mem_set(fs->win, 0, SS(fs));
    2c02:	0021      	movs	r1, r4
    2c04:	3130      	adds	r1, #48	; 0x30
    2c06:	000b      	movs	r3, r1
    2c08:	228c      	movs	r2, #140	; 0x8c
    2c0a:	0092      	lsls	r2, r2, #2
    2c0c:	18a0      	adds	r0, r4, r2
		*d++ = (BYTE)val;
    2c0e:	2200      	movs	r2, #0
    2c10:	701a      	strb	r2, [r3, #0]
    2c12:	3301      	adds	r3, #1
	while (cnt--)
    2c14:	4283      	cmp	r3, r0
    2c16:	d1fb      	bne.n	2c10 <sync_fs+0x38>
			ST_WORD(fs->win + BS_55AA, 0xAA55);
    2c18:	2255      	movs	r2, #85	; 0x55
    2c1a:	4b20      	ldr	r3, [pc, #128]	; (2c9c <sync_fs+0xc4>)
    2c1c:	54e2      	strb	r2, [r4, r3]
    2c1e:	3255      	adds	r2, #85	; 0x55
    2c20:	4b1f      	ldr	r3, [pc, #124]	; (2ca0 <sync_fs+0xc8>)
    2c22:	54e2      	strb	r2, [r4, r3]
			ST_DWORD(fs->win + FSI_LeadSig, 0x41615252);
    2c24:	3bde      	subs	r3, #222	; 0xde
    2c26:	3bff      	subs	r3, #255	; 0xff
    2c28:	3a7a      	subs	r2, #122	; 0x7a
    2c2a:	54a3      	strb	r3, [r4, r2]
    2c2c:	3201      	adds	r2, #1
    2c2e:	54a3      	strb	r3, [r4, r2]
    2c30:	330f      	adds	r3, #15
    2c32:	3201      	adds	r2, #1
    2c34:	54a3      	strb	r3, [r4, r2]
    2c36:	320f      	adds	r2, #15
    2c38:	2033      	movs	r0, #51	; 0x33
    2c3a:	5422      	strb	r2, [r4, r0]
			ST_DWORD(fs->win + FSI_StrucSig, 0x61417272);
    2c3c:	303f      	adds	r0, #63	; 0x3f
    2c3e:	2585      	movs	r5, #133	; 0x85
    2c40:	00ad      	lsls	r5, r5, #2
    2c42:	5560      	strb	r0, [r4, r5]
    2c44:	4d17      	ldr	r5, [pc, #92]	; (2ca4 <sync_fs+0xcc>)
    2c46:	5560      	strb	r0, [r4, r5]
    2c48:	4817      	ldr	r0, [pc, #92]	; (2ca8 <sync_fs+0xd0>)
    2c4a:	5422      	strb	r2, [r4, r0]
    2c4c:	4a17      	ldr	r2, [pc, #92]	; (2cac <sync_fs+0xd4>)
    2c4e:	54a3      	strb	r3, [r4, r2]
			ST_DWORD(fs->win + FSI_Free_Count, fs->free_clust);
    2c50:	6923      	ldr	r3, [r4, #16]
    2c52:	3201      	adds	r2, #1
    2c54:	54a3      	strb	r3, [r4, r2]
    2c56:	0a18      	lsrs	r0, r3, #8
    2c58:	4a15      	ldr	r2, [pc, #84]	; (2cb0 <sync_fs+0xd8>)
    2c5a:	54a0      	strb	r0, [r4, r2]
    2c5c:	0c18      	lsrs	r0, r3, #16
    2c5e:	4a15      	ldr	r2, [pc, #84]	; (2cb4 <sync_fs+0xdc>)
    2c60:	54a0      	strb	r0, [r4, r2]
    2c62:	0e1b      	lsrs	r3, r3, #24
    2c64:	4a14      	ldr	r2, [pc, #80]	; (2cb8 <sync_fs+0xe0>)
    2c66:	54a3      	strb	r3, [r4, r2]
			ST_DWORD(fs->win + FSI_Nxt_Free, fs->last_clust);
    2c68:	68e3      	ldr	r3, [r4, #12]
    2c6a:	3201      	adds	r2, #1
    2c6c:	54a3      	strb	r3, [r4, r2]
    2c6e:	0a18      	lsrs	r0, r3, #8
    2c70:	4a12      	ldr	r2, [pc, #72]	; (2cbc <sync_fs+0xe4>)
    2c72:	54a0      	strb	r0, [r4, r2]
    2c74:	0c18      	lsrs	r0, r3, #16
    2c76:	4a12      	ldr	r2, [pc, #72]	; (2cc0 <sync_fs+0xe8>)
    2c78:	54a0      	strb	r0, [r4, r2]
    2c7a:	0e1b      	lsrs	r3, r3, #24
    2c7c:	4a11      	ldr	r2, [pc, #68]	; (2cc4 <sync_fs+0xec>)
    2c7e:	54a3      	strb	r3, [r4, r2]
			fs->winsect = fs->volbase + 1;
    2c80:	69e3      	ldr	r3, [r4, #28]
    2c82:	1c5a      	adds	r2, r3, #1
    2c84:	62e2      	str	r2, [r4, #44]	; 0x2c
			disk_write(fs->drv, fs->win, fs->winsect, 1);
    2c86:	7860      	ldrb	r0, [r4, #1]
    2c88:	2301      	movs	r3, #1
    2c8a:	4d0f      	ldr	r5, [pc, #60]	; (2cc8 <sync_fs+0xf0>)
    2c8c:	47a8      	blx	r5
			fs->fsi_flag = 0;
    2c8e:	2300      	movs	r3, #0
    2c90:	7163      	strb	r3, [r4, #5]
    2c92:	e7aa      	b.n	2bea <sync_fs+0x12>
    2c94:	00002675 	.word	0x00002675
    2c98:	00002599 	.word	0x00002599
    2c9c:	0000022e 	.word	0x0000022e
    2ca0:	0000022f 	.word	0x0000022f
    2ca4:	00000215 	.word	0x00000215
    2ca8:	00000216 	.word	0x00000216
    2cac:	00000217 	.word	0x00000217
    2cb0:	00000219 	.word	0x00000219
    2cb4:	0000021a 	.word	0x0000021a
    2cb8:	0000021b 	.word	0x0000021b
    2cbc:	0000021d 	.word	0x0000021d
    2cc0:	0000021e 	.word	0x0000021e
    2cc4:	0000021f 	.word	0x0000021f
    2cc8:	00002565 	.word	0x00002565

00002ccc <clust2sect>:
{
    2ccc:	0002      	movs	r2, r0
	clst -= 2;
    2cce:	3902      	subs	r1, #2
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
    2cd0:	6943      	ldr	r3, [r0, #20]
    2cd2:	3b02      	subs	r3, #2
    2cd4:	2000      	movs	r0, #0
    2cd6:	4299      	cmp	r1, r3
    2cd8:	d203      	bcs.n	2ce2 <clust2sect+0x16>
	return clst * fs->csize + fs->database;
    2cda:	7890      	ldrb	r0, [r2, #2]
    2cdc:	4341      	muls	r1, r0
    2cde:	6a90      	ldr	r0, [r2, #40]	; 0x28
    2ce0:	1808      	adds	r0, r1, r0
}
    2ce2:	4770      	bx	lr

00002ce4 <get_fat>:
{
    2ce4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    2ce6:	0005      	movs	r5, r0
    2ce8:	000c      	movs	r4, r1
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
    2cea:	2901      	cmp	r1, #1
    2cec:	d972      	bls.n	2dd4 <get_fat+0xf0>
		val = 1;	/* Internal error */
    2cee:	2001      	movs	r0, #1
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
    2cf0:	696b      	ldr	r3, [r5, #20]
    2cf2:	4299      	cmp	r1, r3
    2cf4:	d26f      	bcs.n	2dd6 <get_fat+0xf2>
		switch (fs->fs_type) {
    2cf6:	782b      	ldrb	r3, [r5, #0]
    2cf8:	2b02      	cmp	r3, #2
    2cfa:	d032      	beq.n	2d62 <get_fat+0x7e>
    2cfc:	2b03      	cmp	r3, #3
    2cfe:	d047      	beq.n	2d90 <get_fat+0xac>
			val = 1;	/* Internal error */
    2d00:	2001      	movs	r0, #1
		switch (fs->fs_type) {
    2d02:	2b01      	cmp	r3, #1
    2d04:	d167      	bne.n	2dd6 <get_fat+0xf2>
			bc = (UINT)clst; bc += bc / 2;
    2d06:	084e      	lsrs	r6, r1, #1
    2d08:	1876      	adds	r6, r6, r1
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
    2d0a:	0a71      	lsrs	r1, r6, #9
    2d0c:	6a2b      	ldr	r3, [r5, #32]
    2d0e:	469c      	mov	ip, r3
    2d10:	4461      	add	r1, ip
    2d12:	0028      	movs	r0, r5
    2d14:	4b30      	ldr	r3, [pc, #192]	; (2dd8 <get_fat+0xf4>)
    2d16:	4798      	blx	r3
    2d18:	2800      	cmp	r0, #0
    2d1a:	d002      	beq.n	2d22 <get_fat+0x3e>
		val = 0xFFFFFFFF;	/* Default value falls on disk error */
    2d1c:	2001      	movs	r0, #1
    2d1e:	4240      	negs	r0, r0
    2d20:	e059      	b.n	2dd6 <get_fat+0xf2>
			wc = fs->win[bc++ % SS(fs)];
    2d22:	1c77      	adds	r7, r6, #1
    2d24:	05f3      	lsls	r3, r6, #23
    2d26:	0ddb      	lsrs	r3, r3, #23
    2d28:	18eb      	adds	r3, r5, r3
    2d2a:	3330      	adds	r3, #48	; 0x30
    2d2c:	781e      	ldrb	r6, [r3, #0]
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
    2d2e:	0a79      	lsrs	r1, r7, #9
    2d30:	6a2b      	ldr	r3, [r5, #32]
    2d32:	469c      	mov	ip, r3
    2d34:	4461      	add	r1, ip
    2d36:	0028      	movs	r0, r5
    2d38:	4b27      	ldr	r3, [pc, #156]	; (2dd8 <get_fat+0xf4>)
    2d3a:	4798      	blx	r3
    2d3c:	2800      	cmp	r0, #0
    2d3e:	d002      	beq.n	2d46 <get_fat+0x62>
		val = 0xFFFFFFFF;	/* Default value falls on disk error */
    2d40:	2001      	movs	r0, #1
    2d42:	4240      	negs	r0, r0
    2d44:	e047      	b.n	2dd6 <get_fat+0xf2>
			wc |= fs->win[bc % SS(fs)] << 8;
    2d46:	05ff      	lsls	r7, r7, #23
    2d48:	0dff      	lsrs	r7, r7, #23
    2d4a:	19ed      	adds	r5, r5, r7
    2d4c:	3530      	adds	r5, #48	; 0x30
    2d4e:	7828      	ldrb	r0, [r5, #0]
    2d50:	0200      	lsls	r0, r0, #8
    2d52:	4330      	orrs	r0, r6
			val = clst & 1 ? wc >> 4 : (wc & 0xFFF);
    2d54:	07e3      	lsls	r3, r4, #31
    2d56:	d501      	bpl.n	2d5c <get_fat+0x78>
    2d58:	0900      	lsrs	r0, r0, #4
    2d5a:	e03c      	b.n	2dd6 <get_fat+0xf2>
    2d5c:	0500      	lsls	r0, r0, #20
    2d5e:	0d00      	lsrs	r0, r0, #20
    2d60:	e039      	b.n	2dd6 <get_fat+0xf2>
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
    2d62:	0a09      	lsrs	r1, r1, #8
    2d64:	6a2b      	ldr	r3, [r5, #32]
    2d66:	469c      	mov	ip, r3
    2d68:	4461      	add	r1, ip
    2d6a:	0028      	movs	r0, r5
    2d6c:	4b1a      	ldr	r3, [pc, #104]	; (2dd8 <get_fat+0xf4>)
    2d6e:	4798      	blx	r3
    2d70:	2800      	cmp	r0, #0
    2d72:	d002      	beq.n	2d7a <get_fat+0x96>
		val = 0xFFFFFFFF;	/* Default value falls on disk error */
    2d74:	2001      	movs	r0, #1
    2d76:	4240      	negs	r0, r0
    2d78:	e02d      	b.n	2dd6 <get_fat+0xf2>
			p = &fs->win[clst * 2 % SS(fs)];
    2d7a:	0064      	lsls	r4, r4, #1
    2d7c:	23ff      	movs	r3, #255	; 0xff
    2d7e:	005b      	lsls	r3, r3, #1
    2d80:	401c      	ands	r4, r3
			val = LD_WORD(p);
    2d82:	192d      	adds	r5, r5, r4
    2d84:	3530      	adds	r5, #48	; 0x30
    2d86:	786b      	ldrb	r3, [r5, #1]
    2d88:	021b      	lsls	r3, r3, #8
    2d8a:	7828      	ldrb	r0, [r5, #0]
    2d8c:	4318      	orrs	r0, r3
			break;
    2d8e:	e022      	b.n	2dd6 <get_fat+0xf2>
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
    2d90:	09c9      	lsrs	r1, r1, #7
    2d92:	6a2b      	ldr	r3, [r5, #32]
    2d94:	469c      	mov	ip, r3
    2d96:	4461      	add	r1, ip
    2d98:	0028      	movs	r0, r5
    2d9a:	4b0f      	ldr	r3, [pc, #60]	; (2dd8 <get_fat+0xf4>)
    2d9c:	4798      	blx	r3
    2d9e:	2800      	cmp	r0, #0
    2da0:	d002      	beq.n	2da8 <get_fat+0xc4>
		val = 0xFFFFFFFF;	/* Default value falls on disk error */
    2da2:	2001      	movs	r0, #1
    2da4:	4240      	negs	r0, r0
	return val;
    2da6:	e016      	b.n	2dd6 <get_fat+0xf2>
			p = &fs->win[clst * 4 % SS(fs)];
    2da8:	00a4      	lsls	r4, r4, #2
    2daa:	23fe      	movs	r3, #254	; 0xfe
    2dac:	005b      	lsls	r3, r3, #1
    2dae:	401c      	ands	r4, r3
    2db0:	0023      	movs	r3, r4
    2db2:	3330      	adds	r3, #48	; 0x30
    2db4:	18eb      	adds	r3, r5, r3
			val = LD_DWORD(p) & 0x0FFFFFFF;
    2db6:	78d8      	ldrb	r0, [r3, #3]
    2db8:	0600      	lsls	r0, r0, #24
    2dba:	789a      	ldrb	r2, [r3, #2]
    2dbc:	0412      	lsls	r2, r2, #16
    2dbe:	4310      	orrs	r0, r2
    2dc0:	192c      	adds	r4, r5, r4
    2dc2:	3430      	adds	r4, #48	; 0x30
    2dc4:	7822      	ldrb	r2, [r4, #0]
    2dc6:	4310      	orrs	r0, r2
    2dc8:	785b      	ldrb	r3, [r3, #1]
    2dca:	021b      	lsls	r3, r3, #8
    2dcc:	4318      	orrs	r0, r3
    2dce:	0100      	lsls	r0, r0, #4
    2dd0:	0900      	lsrs	r0, r0, #4
			break;
    2dd2:	e000      	b.n	2dd6 <get_fat+0xf2>
		val = 1;	/* Internal error */
    2dd4:	2001      	movs	r0, #1
}
    2dd6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    2dd8:	000026e1 	.word	0x000026e1

00002ddc <dir_sdi>:
{
    2ddc:	b5f0      	push	{r4, r5, r6, r7, lr}
    2dde:	46c6      	mov	lr, r8
    2de0:	b500      	push	{lr}
    2de2:	0005      	movs	r5, r0
    2de4:	000e      	movs	r6, r1
	dp->index = (WORD)idx;	/* Current index */
    2de6:	80e9      	strh	r1, [r5, #6]
	clst = dp->sclust;		/* Table start cluster (0:root) */
    2de8:	6884      	ldr	r4, [r0, #8]
		return FR_INT_ERR;
    2dea:	2002      	movs	r0, #2
	if (clst == 1 || clst >= dp->fs->n_fatent)	/* Check start cluster range */
    2dec:	2c01      	cmp	r4, #1
    2dee:	d003      	beq.n	2df8 <dir_sdi+0x1c>
    2df0:	682b      	ldr	r3, [r5, #0]
    2df2:	695a      	ldr	r2, [r3, #20]
    2df4:	4294      	cmp	r4, r2
    2df6:	d302      	bcc.n	2dfe <dir_sdi+0x22>
}
    2df8:	bc04      	pop	{r2}
    2dfa:	4690      	mov	r8, r2
    2dfc:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (!clst && dp->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
    2dfe:	2c00      	cmp	r4, #0
    2e00:	d11b      	bne.n	2e3a <dir_sdi+0x5e>
    2e02:	781a      	ldrb	r2, [r3, #0]
    2e04:	2a03      	cmp	r2, #3
    2e06:	d014      	beq.n	2e32 <dir_sdi+0x56>
		if (idx >= dp->fs->n_rootdir)	/* Is index out of range? */
    2e08:	891a      	ldrh	r2, [r3, #8]
			return FR_INT_ERR;
    2e0a:	2002      	movs	r0, #2
		if (idx >= dp->fs->n_rootdir)	/* Is index out of range? */
    2e0c:	4296      	cmp	r6, r2
    2e0e:	d2f3      	bcs.n	2df8 <dir_sdi+0x1c>
		sect = dp->fs->dirbase;
    2e10:	6a5b      	ldr	r3, [r3, #36]	; 0x24
	dp->clust = clst;	/* Current cluster# */
    2e12:	60ec      	str	r4, [r5, #12]
	if (!sect) return FR_INT_ERR;
    2e14:	2002      	movs	r0, #2
    2e16:	2b00      	cmp	r3, #0
    2e18:	d0ee      	beq.n	2df8 <dir_sdi+0x1c>
	dp->sect = sect + idx / (SS(dp->fs) / SZ_DIRE);					/* Sector# of the directory entry */
    2e1a:	0930      	lsrs	r0, r6, #4
    2e1c:	18c3      	adds	r3, r0, r3
    2e1e:	612b      	str	r3, [r5, #16]
	dp->dir = dp->fs->win + (idx % (SS(dp->fs) / SZ_DIRE)) * SZ_DIRE;	/* Ptr to the entry in the sector */
    2e20:	682b      	ldr	r3, [r5, #0]
    2e22:	3330      	adds	r3, #48	; 0x30
    2e24:	220f      	movs	r2, #15
    2e26:	4016      	ands	r6, r2
    2e28:	0176      	lsls	r6, r6, #5
    2e2a:	199e      	adds	r6, r3, r6
    2e2c:	616e      	str	r6, [r5, #20]
	return FR_OK;
    2e2e:	2000      	movs	r0, #0
    2e30:	e7e2      	b.n	2df8 <dir_sdi+0x1c>
		clst = dp->fs->dirbase;
    2e32:	6a5a      	ldr	r2, [r3, #36]	; 0x24
	if (clst == 0) {	/* Static table (root-directory in FAT12/16) */
    2e34:	2a00      	cmp	r2, #0
    2e36:	d0e7      	beq.n	2e08 <dir_sdi+0x2c>
		clst = dp->fs->dirbase;
    2e38:	0014      	movs	r4, r2
		ic = SS(dp->fs) / SZ_DIRE * dp->fs->csize;	/* Entries per cluster */
    2e3a:	789f      	ldrb	r7, [r3, #2]
    2e3c:	013f      	lsls	r7, r7, #4
		while (idx >= ic) {	/* Follow cluster chain */
    2e3e:	42be      	cmp	r6, r7
    2e40:	d313      	bcc.n	2e6a <dir_sdi+0x8e>
    2e42:	1bf6      	subs	r6, r6, r7
			clst = get_fat(dp->fs, clst);				/* Get next cluster */
    2e44:	4b0f      	ldr	r3, [pc, #60]	; (2e84 <dir_sdi+0xa8>)
    2e46:	4698      	mov	r8, r3
    2e48:	e000      	b.n	2e4c <dir_sdi+0x70>
    2e4a:	001e      	movs	r6, r3
    2e4c:	0021      	movs	r1, r4
    2e4e:	6828      	ldr	r0, [r5, #0]
    2e50:	47c0      	blx	r8
    2e52:	0004      	movs	r4, r0
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
    2e54:	1c43      	adds	r3, r0, #1
    2e56:	d00e      	beq.n	2e76 <dir_sdi+0x9a>
			if (clst < 2 || clst >= dp->fs->n_fatent)	/* Reached to end of table or internal error */
    2e58:	2801      	cmp	r0, #1
    2e5a:	d90e      	bls.n	2e7a <dir_sdi+0x9e>
    2e5c:	682b      	ldr	r3, [r5, #0]
    2e5e:	695b      	ldr	r3, [r3, #20]
    2e60:	4298      	cmp	r0, r3
    2e62:	d20c      	bcs.n	2e7e <dir_sdi+0xa2>
    2e64:	1bf3      	subs	r3, r6, r7
		while (idx >= ic) {	/* Follow cluster chain */
    2e66:	42be      	cmp	r6, r7
    2e68:	d2ef      	bcs.n	2e4a <dir_sdi+0x6e>
		sect = clust2sect(dp->fs, clst);
    2e6a:	0021      	movs	r1, r4
    2e6c:	6828      	ldr	r0, [r5, #0]
    2e6e:	4b06      	ldr	r3, [pc, #24]	; (2e88 <dir_sdi+0xac>)
    2e70:	4798      	blx	r3
    2e72:	0003      	movs	r3, r0
    2e74:	e7cd      	b.n	2e12 <dir_sdi+0x36>
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
    2e76:	2001      	movs	r0, #1
    2e78:	e7be      	b.n	2df8 <dir_sdi+0x1c>
				return FR_INT_ERR;
    2e7a:	2002      	movs	r0, #2
    2e7c:	e7bc      	b.n	2df8 <dir_sdi+0x1c>
    2e7e:	2002      	movs	r0, #2
    2e80:	e7ba      	b.n	2df8 <dir_sdi+0x1c>
    2e82:	46c0      	nop			; (mov r8, r8)
    2e84:	00002ce5 	.word	0x00002ce5
    2e88:	00002ccd 	.word	0x00002ccd

00002e8c <put_fat>:
{
    2e8c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    2e8e:	46ce      	mov	lr, r9
    2e90:	4647      	mov	r7, r8
    2e92:	b580      	push	{r7, lr}
    2e94:	0007      	movs	r7, r0
    2e96:	000c      	movs	r4, r1
    2e98:	0016      	movs	r6, r2
		res = FR_INT_ERR;
    2e9a:	2502      	movs	r5, #2
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
    2e9c:	2901      	cmp	r1, #1
    2e9e:	d902      	bls.n	2ea6 <put_fat+0x1a>
    2ea0:	6943      	ldr	r3, [r0, #20]
    2ea2:	4299      	cmp	r1, r3
    2ea4:	d304      	bcc.n	2eb0 <put_fat+0x24>
}
    2ea6:	0028      	movs	r0, r5
    2ea8:	bc0c      	pop	{r2, r3}
    2eaa:	4690      	mov	r8, r2
    2eac:	4699      	mov	r9, r3
    2eae:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		switch (fs->fs_type) {
    2eb0:	7803      	ldrb	r3, [r0, #0]
    2eb2:	2b02      	cmp	r3, #2
    2eb4:	d055      	beq.n	2f62 <put_fat+0xd6>
    2eb6:	2b03      	cmp	r3, #3
    2eb8:	d067      	beq.n	2f8a <put_fat+0xfe>
			res = FR_INT_ERR;
    2eba:	2502      	movs	r5, #2
		switch (fs->fs_type) {
    2ebc:	2b01      	cmp	r3, #1
    2ebe:	d1f2      	bne.n	2ea6 <put_fat+0x1a>
			bc = (UINT)clst; bc += bc / 2;
    2ec0:	084b      	lsrs	r3, r1, #1
    2ec2:	4698      	mov	r8, r3
    2ec4:	4488      	add	r8, r1
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
    2ec6:	4643      	mov	r3, r8
    2ec8:	0a59      	lsrs	r1, r3, #9
    2eca:	6a03      	ldr	r3, [r0, #32]
    2ecc:	469c      	mov	ip, r3
    2ece:	4461      	add	r1, ip
    2ed0:	4b40      	ldr	r3, [pc, #256]	; (2fd4 <put_fat+0x148>)
    2ed2:	4798      	blx	r3
    2ed4:	1e05      	subs	r5, r0, #0
			if (res != FR_OK) break;
    2ed6:	d1e6      	bne.n	2ea6 <put_fat+0x1a>
			p = &fs->win[bc++ % SS(fs)];
    2ed8:	2301      	movs	r3, #1
    2eda:	4443      	add	r3, r8
    2edc:	4699      	mov	r9, r3
    2ede:	4643      	mov	r3, r8
    2ee0:	05db      	lsls	r3, r3, #23
    2ee2:	0ddb      	lsrs	r3, r3, #23
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
    2ee4:	07e2      	lsls	r2, r4, #31
    2ee6:	d521      	bpl.n	2f2c <put_fat+0xa0>
    2ee8:	18fb      	adds	r3, r7, r3
    2eea:	3330      	adds	r3, #48	; 0x30
    2eec:	7819      	ldrb	r1, [r3, #0]
    2eee:	220f      	movs	r2, #15
    2ef0:	400a      	ands	r2, r1
    2ef2:	0131      	lsls	r1, r6, #4
    2ef4:	20ff      	movs	r0, #255	; 0xff
    2ef6:	0100      	lsls	r0, r0, #4
    2ef8:	4001      	ands	r1, r0
    2efa:	430a      	orrs	r2, r1
    2efc:	701a      	strb	r2, [r3, #0]
			fs->wflag = 1;
    2efe:	2301      	movs	r3, #1
    2f00:	713b      	strb	r3, [r7, #4]
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
    2f02:	464b      	mov	r3, r9
    2f04:	0a59      	lsrs	r1, r3, #9
    2f06:	6a3b      	ldr	r3, [r7, #32]
    2f08:	469c      	mov	ip, r3
    2f0a:	4461      	add	r1, ip
    2f0c:	0038      	movs	r0, r7
    2f0e:	4b31      	ldr	r3, [pc, #196]	; (2fd4 <put_fat+0x148>)
    2f10:	4798      	blx	r3
			if (res != FR_OK) break;
    2f12:	2800      	cmp	r0, #0
    2f14:	d159      	bne.n	2fca <put_fat+0x13e>
			p = &fs->win[bc % SS(fs)];
    2f16:	464b      	mov	r3, r9
    2f18:	05db      	lsls	r3, r3, #23
    2f1a:	0ddb      	lsrs	r3, r3, #23
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
    2f1c:	0936      	lsrs	r6, r6, #4
    2f1e:	b2f6      	uxtb	r6, r6
    2f20:	18fb      	adds	r3, r7, r3
    2f22:	3330      	adds	r3, #48	; 0x30
    2f24:	701e      	strb	r6, [r3, #0]
			fs->wflag = 1;
    2f26:	2301      	movs	r3, #1
    2f28:	713b      	strb	r3, [r7, #4]
			break;
    2f2a:	e7bc      	b.n	2ea6 <put_fat+0x1a>
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
    2f2c:	18fb      	adds	r3, r7, r3
    2f2e:	3330      	adds	r3, #48	; 0x30
    2f30:	701e      	strb	r6, [r3, #0]
			fs->wflag = 1;
    2f32:	2301      	movs	r3, #1
    2f34:	713b      	strb	r3, [r7, #4]
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
    2f36:	464b      	mov	r3, r9
    2f38:	0a59      	lsrs	r1, r3, #9
    2f3a:	6a3b      	ldr	r3, [r7, #32]
    2f3c:	469c      	mov	ip, r3
    2f3e:	4461      	add	r1, ip
    2f40:	0038      	movs	r0, r7
    2f42:	4b24      	ldr	r3, [pc, #144]	; (2fd4 <put_fat+0x148>)
    2f44:	4798      	blx	r3
			if (res != FR_OK) break;
    2f46:	2800      	cmp	r0, #0
    2f48:	d141      	bne.n	2fce <put_fat+0x142>
			p = &fs->win[bc % SS(fs)];
    2f4a:	464b      	mov	r3, r9
    2f4c:	05db      	lsls	r3, r3, #23
    2f4e:	0ddb      	lsrs	r3, r3, #23
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
    2f50:	18fa      	adds	r2, r7, r3
    2f52:	3230      	adds	r2, #48	; 0x30
    2f54:	7812      	ldrb	r2, [r2, #0]
    2f56:	210f      	movs	r1, #15
    2f58:	438a      	bics	r2, r1
    2f5a:	0536      	lsls	r6, r6, #20
    2f5c:	0f36      	lsrs	r6, r6, #28
    2f5e:	4316      	orrs	r6, r2
    2f60:	e7de      	b.n	2f20 <put_fat+0x94>
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
    2f62:	0a09      	lsrs	r1, r1, #8
    2f64:	6a03      	ldr	r3, [r0, #32]
    2f66:	469c      	mov	ip, r3
    2f68:	4461      	add	r1, ip
    2f6a:	4b1a      	ldr	r3, [pc, #104]	; (2fd4 <put_fat+0x148>)
    2f6c:	4798      	blx	r3
    2f6e:	1e05      	subs	r5, r0, #0
			if (res != FR_OK) break;
    2f70:	d199      	bne.n	2ea6 <put_fat+0x1a>
			p = &fs->win[clst * 2 % SS(fs)];
    2f72:	0063      	lsls	r3, r4, #1
    2f74:	24ff      	movs	r4, #255	; 0xff
    2f76:	0064      	lsls	r4, r4, #1
    2f78:	4023      	ands	r3, r4
			ST_WORD(p, (WORD)val);
    2f7a:	18fb      	adds	r3, r7, r3
    2f7c:	3330      	adds	r3, #48	; 0x30
    2f7e:	701e      	strb	r6, [r3, #0]
    2f80:	0a36      	lsrs	r6, r6, #8
    2f82:	705e      	strb	r6, [r3, #1]
			fs->wflag = 1;
    2f84:	2301      	movs	r3, #1
    2f86:	713b      	strb	r3, [r7, #4]
			break;
    2f88:	e78d      	b.n	2ea6 <put_fat+0x1a>
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
    2f8a:	09c9      	lsrs	r1, r1, #7
    2f8c:	6a03      	ldr	r3, [r0, #32]
    2f8e:	469c      	mov	ip, r3
    2f90:	4461      	add	r1, ip
    2f92:	4b10      	ldr	r3, [pc, #64]	; (2fd4 <put_fat+0x148>)
    2f94:	4798      	blx	r3
    2f96:	1e05      	subs	r5, r0, #0
			if (res != FR_OK) break;
    2f98:	d000      	beq.n	2f9c <put_fat+0x110>
    2f9a:	e784      	b.n	2ea6 <put_fat+0x1a>
			p = &fs->win[clst * 4 % SS(fs)];
    2f9c:	00a4      	lsls	r4, r4, #2
    2f9e:	23fe      	movs	r3, #254	; 0xfe
    2fa0:	005b      	lsls	r3, r3, #1
    2fa2:	401c      	ands	r4, r3
    2fa4:	0022      	movs	r2, r4
    2fa6:	3230      	adds	r2, #48	; 0x30
    2fa8:	18ba      	adds	r2, r7, r2
			val |= LD_DWORD(p) & 0xF0000000;
    2faa:	78d3      	ldrb	r3, [r2, #3]
    2fac:	193c      	adds	r4, r7, r4
    2fae:	3430      	adds	r4, #48	; 0x30
    2fb0:	091b      	lsrs	r3, r3, #4
    2fb2:	071b      	lsls	r3, r3, #28
    2fb4:	431e      	orrs	r6, r3
			ST_DWORD(p, val);
    2fb6:	7026      	strb	r6, [r4, #0]
    2fb8:	0a33      	lsrs	r3, r6, #8
    2fba:	7053      	strb	r3, [r2, #1]
    2fbc:	0c33      	lsrs	r3, r6, #16
    2fbe:	7093      	strb	r3, [r2, #2]
    2fc0:	0e36      	lsrs	r6, r6, #24
    2fc2:	70d6      	strb	r6, [r2, #3]
			fs->wflag = 1;
    2fc4:	2301      	movs	r3, #1
    2fc6:	713b      	strb	r3, [r7, #4]
			break;
    2fc8:	e76d      	b.n	2ea6 <put_fat+0x1a>
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
    2fca:	0005      	movs	r5, r0
    2fcc:	e76b      	b.n	2ea6 <put_fat+0x1a>
    2fce:	0005      	movs	r5, r0
	return res;
    2fd0:	e769      	b.n	2ea6 <put_fat+0x1a>
    2fd2:	46c0      	nop			; (mov r8, r8)
    2fd4:	000026e1 	.word	0x000026e1

00002fd8 <create_chain>:
{
    2fd8:	b5f0      	push	{r4, r5, r6, r7, lr}
    2fda:	46c6      	mov	lr, r8
    2fdc:	b500      	push	{lr}
    2fde:	0005      	movs	r5, r0
    2fe0:	4688      	mov	r8, r1
	if (clst == 0) {		/* Create a new chain */
    2fe2:	2900      	cmp	r1, #0
    2fe4:	d107      	bne.n	2ff6 <create_chain+0x1e>
		scl = fs->last_clust;			/* Get suggested start point */
    2fe6:	68c6      	ldr	r6, [r0, #12]
		if (!scl || scl >= fs->n_fatent) scl = 1;
    2fe8:	2e00      	cmp	r6, #0
    2fea:	d00f      	beq.n	300c <create_chain+0x34>
    2fec:	6943      	ldr	r3, [r0, #20]
    2fee:	429e      	cmp	r6, r3
    2ff0:	d30d      	bcc.n	300e <create_chain+0x36>
    2ff2:	2601      	movs	r6, #1
    2ff4:	e00b      	b.n	300e <create_chain+0x36>
		cs = get_fat(fs, clst);			/* Check the cluster status */
    2ff6:	4b28      	ldr	r3, [pc, #160]	; (3098 <create_chain+0xc0>)
    2ff8:	4798      	blx	r3
		if (cs < 2) return 1;			/* Invalid value */
    2ffa:	2801      	cmp	r0, #1
    2ffc:	d941      	bls.n	3082 <create_chain+0xaa>
		if (cs == 0xFFFFFFFF) return cs;	/* A disk error occurred */
    2ffe:	1c43      	adds	r3, r0, #1
    3000:	d044      	beq.n	308c <create_chain+0xb4>
		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
    3002:	696b      	ldr	r3, [r5, #20]
		scl = clst;
    3004:	4646      	mov	r6, r8
		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
    3006:	4298      	cmp	r0, r3
    3008:	d201      	bcs.n	300e <create_chain+0x36>
    300a:	e03f      	b.n	308c <create_chain+0xb4>
		if (!scl || scl >= fs->n_fatent) scl = 1;
    300c:	2601      	movs	r6, #1
	ncl = scl;				/* Start cluster */
    300e:	0034      	movs	r4, r6
		cs = get_fat(fs, ncl);			/* Get the cluster status */
    3010:	4f21      	ldr	r7, [pc, #132]	; (3098 <create_chain+0xc0>)
    3012:	e00a      	b.n	302a <create_chain+0x52>
    3014:	0021      	movs	r1, r4
    3016:	0028      	movs	r0, r5
    3018:	47b8      	blx	r7
		if (cs == 0) break;				/* Found a free cluster */
    301a:	2800      	cmp	r0, #0
    301c:	d00d      	beq.n	303a <create_chain+0x62>
		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
    301e:	1c43      	adds	r3, r0, #1
    3020:	d034      	beq.n	308c <create_chain+0xb4>
    3022:	2801      	cmp	r0, #1
    3024:	d032      	beq.n	308c <create_chain+0xb4>
		if (ncl == scl) return 0;		/* No free cluster */
    3026:	42b4      	cmp	r4, r6
    3028:	d02f      	beq.n	308a <create_chain+0xb2>
		ncl++;							/* Next cluster */
    302a:	3401      	adds	r4, #1
		if (ncl >= fs->n_fatent) {		/* Check wrap around */
    302c:	696b      	ldr	r3, [r5, #20]
    302e:	429c      	cmp	r4, r3
    3030:	d3f0      	bcc.n	3014 <create_chain+0x3c>
			if (ncl > scl) return 0;	/* No free cluster */
    3032:	2e01      	cmp	r6, #1
    3034:	d927      	bls.n	3086 <create_chain+0xae>
			ncl = 2;
    3036:	2402      	movs	r4, #2
    3038:	e7ec      	b.n	3014 <create_chain+0x3c>
	res = put_fat(fs, ncl, 0x0FFFFFFF);	/* Mark the new cluster "last link" */
    303a:	4a18      	ldr	r2, [pc, #96]	; (309c <create_chain+0xc4>)
    303c:	0021      	movs	r1, r4
    303e:	0028      	movs	r0, r5
    3040:	4b17      	ldr	r3, [pc, #92]	; (30a0 <create_chain+0xc8>)
    3042:	4798      	blx	r3
	if (res == FR_OK && clst != 0) {
    3044:	2800      	cmp	r0, #0
    3046:	d115      	bne.n	3074 <create_chain+0x9c>
    3048:	4643      	mov	r3, r8
    304a:	2b00      	cmp	r3, #0
    304c:	d10b      	bne.n	3066 <create_chain+0x8e>
		fs->last_clust = ncl;			/* Update FSINFO */
    304e:	60ec      	str	r4, [r5, #12]
		if (fs->free_clust != 0xFFFFFFFF) {
    3050:	692b      	ldr	r3, [r5, #16]
    3052:	1c5a      	adds	r2, r3, #1
    3054:	d01d      	beq.n	3092 <create_chain+0xba>
			fs->free_clust--;
    3056:	3b01      	subs	r3, #1
    3058:	612b      	str	r3, [r5, #16]
			fs->fsi_flag |= 1;
    305a:	796b      	ldrb	r3, [r5, #5]
    305c:	2201      	movs	r2, #1
    305e:	4313      	orrs	r3, r2
    3060:	716b      	strb	r3, [r5, #5]
    3062:	0020      	movs	r0, r4
    3064:	e012      	b.n	308c <create_chain+0xb4>
		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
    3066:	0022      	movs	r2, r4
    3068:	4641      	mov	r1, r8
    306a:	0028      	movs	r0, r5
    306c:	4b0c      	ldr	r3, [pc, #48]	; (30a0 <create_chain+0xc8>)
    306e:	4798      	blx	r3
	if (res == FR_OK) {
    3070:	2800      	cmp	r0, #0
    3072:	d0ec      	beq.n	304e <create_chain+0x76>
		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
    3074:	3801      	subs	r0, #1
    3076:	4242      	negs	r2, r0
    3078:	4142      	adcs	r2, r0
    307a:	4250      	negs	r0, r2
    307c:	2301      	movs	r3, #1
    307e:	4318      	orrs	r0, r3
    3080:	e004      	b.n	308c <create_chain+0xb4>
		if (cs < 2) return 1;			/* Invalid value */
    3082:	2001      	movs	r0, #1
    3084:	e002      	b.n	308c <create_chain+0xb4>
			if (ncl > scl) return 0;	/* No free cluster */
    3086:	2000      	movs	r0, #0
    3088:	e000      	b.n	308c <create_chain+0xb4>
		if (ncl == scl) return 0;		/* No free cluster */
    308a:	2000      	movs	r0, #0
}
    308c:	bc04      	pop	{r2}
    308e:	4690      	mov	r8, r2
    3090:	bdf0      	pop	{r4, r5, r6, r7, pc}
    3092:	0020      	movs	r0, r4
    3094:	e7fa      	b.n	308c <create_chain+0xb4>
    3096:	46c0      	nop			; (mov r8, r8)
    3098:	00002ce5 	.word	0x00002ce5
    309c:	0fffffff 	.word	0x0fffffff
    30a0:	00002e8d 	.word	0x00002e8d

000030a4 <dir_next>:
{
    30a4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    30a6:	46ce      	mov	lr, r9
    30a8:	4647      	mov	r7, r8
    30aa:	b580      	push	{r7, lr}
    30ac:	0006      	movs	r6, r0
    30ae:	000d      	movs	r5, r1
	i = dp->index + 1;
    30b0:	88c4      	ldrh	r4, [r0, #6]
    30b2:	3401      	adds	r4, #1
	if (!(i & 0xFFFF) || !dp->sect)	/* Report EOT when index has reached 65535 */
    30b4:	0423      	lsls	r3, r4, #16
		return FR_NO_FILE;
    30b6:	2004      	movs	r0, #4
	if (!(i & 0xFFFF) || !dp->sect)	/* Report EOT when index has reached 65535 */
    30b8:	2b00      	cmp	r3, #0
    30ba:	d103      	bne.n	30c4 <dir_next+0x20>
}
    30bc:	bc0c      	pop	{r2, r3}
    30be:	4690      	mov	r8, r2
    30c0:	4699      	mov	r9, r3
    30c2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (!(i & 0xFFFF) || !dp->sect)	/* Report EOT when index has reached 65535 */
    30c4:	6933      	ldr	r3, [r6, #16]
    30c6:	2b00      	cmp	r3, #0
    30c8:	d0f8      	beq.n	30bc <dir_next+0x18>
	if (!(i % (SS(dp->fs) / SZ_DIRE))) {	/* Sector changed? */
    30ca:	270f      	movs	r7, #15
    30cc:	4027      	ands	r7, r4
    30ce:	d110      	bne.n	30f2 <dir_next+0x4e>
		dp->sect++;					/* Next sector */
    30d0:	3301      	adds	r3, #1
    30d2:	6133      	str	r3, [r6, #16]
		if (!dp->clust) {		/* Static table */
    30d4:	68f1      	ldr	r1, [r6, #12]
    30d6:	2900      	cmp	r1, #0
    30d8:	d104      	bne.n	30e4 <dir_next+0x40>
			if (i >= dp->fs->n_rootdir)	/* Report EOT if it reached end of static table */
    30da:	6833      	ldr	r3, [r6, #0]
    30dc:	891b      	ldrh	r3, [r3, #8]
    30de:	429c      	cmp	r4, r3
    30e0:	d2ec      	bcs.n	30bc <dir_next+0x18>
    30e2:	e006      	b.n	30f2 <dir_next+0x4e>
			if (((i / (SS(dp->fs) / SZ_DIRE)) & (dp->fs->csize - 1)) == 0) {	/* Cluster changed? */
    30e4:	6830      	ldr	r0, [r6, #0]
    30e6:	7883      	ldrb	r3, [r0, #2]
    30e8:	3b01      	subs	r3, #1
    30ea:	0922      	lsrs	r2, r4, #4
    30ec:	401a      	ands	r2, r3
    30ee:	4690      	mov	r8, r2
    30f0:	d007      	beq.n	3102 <dir_next+0x5e>
	dp->index = (WORD)i;	/* Current index */
    30f2:	80f4      	strh	r4, [r6, #6]
	dp->dir = dp->fs->win + (i % (SS(dp->fs) / SZ_DIRE)) * SZ_DIRE;	/* Current entry in the window */
    30f4:	6833      	ldr	r3, [r6, #0]
    30f6:	3330      	adds	r3, #48	; 0x30
    30f8:	017f      	lsls	r7, r7, #5
    30fa:	19df      	adds	r7, r3, r7
    30fc:	6177      	str	r7, [r6, #20]
	return FR_OK;
    30fe:	2000      	movs	r0, #0
    3100:	e7dc      	b.n	30bc <dir_next+0x18>
				clst = get_fat(dp->fs, dp->clust);				/* Get next cluster */
    3102:	4b2d      	ldr	r3, [pc, #180]	; (31b8 <dir_next+0x114>)
    3104:	4798      	blx	r3
    3106:	4681      	mov	r9, r0
				if (clst <= 1) return FR_INT_ERR;
    3108:	2002      	movs	r0, #2
    310a:	464b      	mov	r3, r9
    310c:	2b01      	cmp	r3, #1
    310e:	d9d5      	bls.n	30bc <dir_next+0x18>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
    3110:	3301      	adds	r3, #1
    3112:	d04d      	beq.n	31b0 <dir_next+0x10c>
				if (clst >= dp->fs->n_fatent) {					/* If it reached end of dynamic table, */
    3114:	6833      	ldr	r3, [r6, #0]
    3116:	695a      	ldr	r2, [r3, #20]
    3118:	4591      	cmp	r9, r2
    311a:	d341      	bcc.n	31a0 <dir_next+0xfc>
					if (!stretch) return FR_NO_FILE;			/* If do not stretch, report EOT */
    311c:	3002      	adds	r0, #2
    311e:	2d00      	cmp	r5, #0
    3120:	d0cc      	beq.n	30bc <dir_next+0x18>
					clst = create_chain(dp->fs, dp->clust);		/* Stretch cluster chain */
    3122:	68f1      	ldr	r1, [r6, #12]
    3124:	0018      	movs	r0, r3
    3126:	4b25      	ldr	r3, [pc, #148]	; (31bc <dir_next+0x118>)
    3128:	4798      	blx	r3
    312a:	4681      	mov	r9, r0
					if (clst == 0) return FR_DENIED;			/* No free cluster */
    312c:	2007      	movs	r0, #7
    312e:	464b      	mov	r3, r9
    3130:	2b00      	cmp	r3, #0
    3132:	d0c3      	beq.n	30bc <dir_next+0x18>
					if (clst == 1) return FR_INT_ERR;
    3134:	3805      	subs	r0, #5
    3136:	2b01      	cmp	r3, #1
    3138:	d0c0      	beq.n	30bc <dir_next+0x18>
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
    313a:	3801      	subs	r0, #1
    313c:	3301      	adds	r3, #1
    313e:	d0bd      	beq.n	30bc <dir_next+0x18>
					if (sync_window(dp->fs)) return FR_DISK_ERR;/* Flush disk access window */
    3140:	6830      	ldr	r0, [r6, #0]
    3142:	4b1f      	ldr	r3, [pc, #124]	; (31c0 <dir_next+0x11c>)
    3144:	4798      	blx	r3
    3146:	0003      	movs	r3, r0
    3148:	2001      	movs	r0, #1
    314a:	2b00      	cmp	r3, #0
    314c:	d1b6      	bne.n	30bc <dir_next+0x18>
					mem_set(dp->fs->win, 0, SS(dp->fs));		/* Clear window buffer */
    314e:	6833      	ldr	r3, [r6, #0]
    3150:	001a      	movs	r2, r3
    3152:	3230      	adds	r2, #48	; 0x30
    3154:	218c      	movs	r1, #140	; 0x8c
    3156:	0089      	lsls	r1, r1, #2
    3158:	468c      	mov	ip, r1
    315a:	4463      	add	r3, ip
		*d++ = (BYTE)val;
    315c:	2100      	movs	r1, #0
    315e:	7011      	strb	r1, [r2, #0]
    3160:	3201      	adds	r2, #1
	while (cnt--)
    3162:	429a      	cmp	r2, r3
    3164:	d1fb      	bne.n	315e <dir_next+0xba>
					dp->fs->winsect = clust2sect(dp->fs, clst);	/* Cluster start sector */
    3166:	6835      	ldr	r5, [r6, #0]
    3168:	4649      	mov	r1, r9
    316a:	0028      	movs	r0, r5
    316c:	4b15      	ldr	r3, [pc, #84]	; (31c4 <dir_next+0x120>)
    316e:	4798      	blx	r3
    3170:	62e8      	str	r0, [r5, #44]	; 0x2c
						dp->fs->wflag = 1;
    3172:	2501      	movs	r5, #1
					for (c = 0; c < dp->fs->csize; c++) {		/* Fill the new cluster with 0 */
    3174:	6833      	ldr	r3, [r6, #0]
    3176:	789a      	ldrb	r2, [r3, #2]
    3178:	4590      	cmp	r8, r2
    317a:	d20d      	bcs.n	3198 <dir_next+0xf4>
						dp->fs->wflag = 1;
    317c:	711d      	strb	r5, [r3, #4]
						if (sync_window(dp->fs)) return FR_DISK_ERR;
    317e:	6830      	ldr	r0, [r6, #0]
    3180:	4b0f      	ldr	r3, [pc, #60]	; (31c0 <dir_next+0x11c>)
    3182:	4798      	blx	r3
    3184:	2800      	cmp	r0, #0
    3186:	d115      	bne.n	31b4 <dir_next+0x110>
						dp->fs->winsect++;
    3188:	6832      	ldr	r2, [r6, #0]
    318a:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
    318c:	3301      	adds	r3, #1
    318e:	62d3      	str	r3, [r2, #44]	; 0x2c
					for (c = 0; c < dp->fs->csize; c++) {		/* Fill the new cluster with 0 */
    3190:	2301      	movs	r3, #1
    3192:	469c      	mov	ip, r3
    3194:	44e0      	add	r8, ip
    3196:	e7ed      	b.n	3174 <dir_next+0xd0>
					dp->fs->winsect -= c;						/* Rewind window offset */
    3198:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    319a:	4641      	mov	r1, r8
    319c:	1a52      	subs	r2, r2, r1
    319e:	62da      	str	r2, [r3, #44]	; 0x2c
				dp->clust = clst;				/* Initialize data for new cluster */
    31a0:	464b      	mov	r3, r9
    31a2:	60f3      	str	r3, [r6, #12]
				dp->sect = clust2sect(dp->fs, clst);
    31a4:	4649      	mov	r1, r9
    31a6:	6830      	ldr	r0, [r6, #0]
    31a8:	4b06      	ldr	r3, [pc, #24]	; (31c4 <dir_next+0x120>)
    31aa:	4798      	blx	r3
    31ac:	6130      	str	r0, [r6, #16]
    31ae:	e7a0      	b.n	30f2 <dir_next+0x4e>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
    31b0:	2001      	movs	r0, #1
    31b2:	e783      	b.n	30bc <dir_next+0x18>
						if (sync_window(dp->fs)) return FR_DISK_ERR;
    31b4:	2001      	movs	r0, #1
    31b6:	e781      	b.n	30bc <dir_next+0x18>
    31b8:	00002ce5 	.word	0x00002ce5
    31bc:	00002fd9 	.word	0x00002fd9
    31c0:	00002675 	.word	0x00002675
    31c4:	00002ccd 	.word	0x00002ccd

000031c8 <follow_path>:
{
    31c8:	b5f0      	push	{r4, r5, r6, r7, lr}
    31ca:	46de      	mov	lr, fp
    31cc:	4657      	mov	r7, sl
    31ce:	464e      	mov	r6, r9
    31d0:	4645      	mov	r5, r8
    31d2:	b5e0      	push	{r5, r6, r7, lr}
    31d4:	b085      	sub	sp, #20
    31d6:	0004      	movs	r4, r0
    31d8:	000e      	movs	r6, r1
	if (*path == '/' || *path == '\\')		/* Strip heading separator if exist */
    31da:	780b      	ldrb	r3, [r1, #0]
    31dc:	2b2f      	cmp	r3, #47	; 0x2f
    31de:	d009      	beq.n	31f4 <follow_path+0x2c>
    31e0:	2b5c      	cmp	r3, #92	; 0x5c
    31e2:	d007      	beq.n	31f4 <follow_path+0x2c>
	dp->sclust = 0;							/* Always start from the root directory */
    31e4:	2300      	movs	r3, #0
    31e6:	60a3      	str	r3, [r4, #8]
	if ((UINT)*path < ' ') {				/* Null path name is the origin directory itself */
    31e8:	7833      	ldrb	r3, [r6, #0]
    31ea:	2b1f      	cmp	r3, #31
    31ec:	d904      	bls.n	31f8 <follow_path+0x30>
		res = dir_next(dp, 0);		/* Next entry */
    31ee:	4b95      	ldr	r3, [pc, #596]	; (3444 <follow_path+0x27c>)
    31f0:	469a      	mov	sl, r3
    31f2:	e009      	b.n	3208 <follow_path+0x40>
		path++;
    31f4:	3601      	adds	r6, #1
    31f6:	e7f5      	b.n	31e4 <follow_path+0x1c>
		res = dir_sdi(dp, 0);
    31f8:	2100      	movs	r1, #0
    31fa:	0020      	movs	r0, r4
    31fc:	4b92      	ldr	r3, [pc, #584]	; (3448 <follow_path+0x280>)
    31fe:	4798      	blx	r3
		dp->dir = 0;
    3200:	2300      	movs	r3, #0
    3202:	6163      	str	r3, [r4, #20]
    3204:	e10d      	b.n	3422 <follow_path+0x25a>
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
    3206:	3601      	adds	r6, #1
    3208:	7833      	ldrb	r3, [r6, #0]
    320a:	2b2f      	cmp	r3, #47	; 0x2f
    320c:	d0fb      	beq.n	3206 <follow_path+0x3e>
    320e:	2b5c      	cmp	r3, #92	; 0x5c
    3210:	d0f9      	beq.n	3206 <follow_path+0x3e>
	sfn = dp->fn;
    3212:	69a1      	ldr	r1, [r4, #24]
    3214:	000b      	movs	r3, r1
    3216:	0008      	movs	r0, r1
    3218:	300b      	adds	r0, #11
		*d++ = (BYTE)val;
    321a:	2220      	movs	r2, #32
    321c:	701a      	strb	r2, [r3, #0]
    321e:	3301      	adds	r3, #1
	while (cnt--)
    3220:	4298      	cmp	r0, r3
    3222:	d1fb      	bne.n	321c <follow_path+0x54>
    3224:	2000      	movs	r0, #0
    3226:	2200      	movs	r2, #0
    3228:	2508      	movs	r5, #8
    322a:	2300      	movs	r3, #0
    322c:	469c      	mov	ip, r3
					b |= 1; c -= 0x20;
    322e:	2301      	movs	r3, #1
    3230:	4699      	mov	r9, r3
			b |= 3;						/* Eliminate NT flag */
    3232:	2303      	movs	r3, #3
    3234:	4698      	mov	r8, r3
    3236:	9101      	str	r1, [sp, #4]
    3238:	9402      	str	r4, [sp, #8]
		c = (BYTE)p[si++];
    323a:	1c57      	adds	r7, r2, #1
    323c:	5cb3      	ldrb	r3, [r6, r2]
		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
    323e:	2b20      	cmp	r3, #32
    3240:	d800      	bhi.n	3244 <follow_path+0x7c>
    3242:	e0e5      	b.n	3410 <follow_path+0x248>
    3244:	2b2f      	cmp	r3, #47	; 0x2f
    3246:	d100      	bne.n	324a <follow_path+0x82>
    3248:	e0da      	b.n	3400 <follow_path+0x238>
    324a:	2b5c      	cmp	r3, #92	; 0x5c
    324c:	d100      	bne.n	3250 <follow_path+0x88>
    324e:	e0d7      	b.n	3400 <follow_path+0x238>
		if (c == '.' || i >= ni) {
    3250:	2b2e      	cmp	r3, #46	; 0x2e
    3252:	d100      	bne.n	3256 <follow_path+0x8e>
    3254:	e0ec      	b.n	3430 <follow_path+0x268>
    3256:	4285      	cmp	r5, r0
    3258:	d800      	bhi.n	325c <follow_path+0x94>
    325a:	e0c5      	b.n	33e8 <follow_path+0x220>
		if (c >= 0x80) {				/* Extended character? */
    325c:	b25c      	sxtb	r4, r3
    325e:	2c00      	cmp	r4, #0
    3260:	db27      	blt.n	32b2 <follow_path+0xea>
		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
    3262:	247f      	movs	r4, #127	; 0x7f
    3264:	46a3      	mov	fp, r4
    3266:	449b      	add	fp, r3
    3268:	465c      	mov	r4, fp
    326a:	4669      	mov	r1, sp
    326c:	730c      	strb	r4, [r1, #12]
    326e:	b2e4      	uxtb	r4, r4
    3270:	2c1e      	cmp	r4, #30
    3272:	d907      	bls.n	3284 <follow_path+0xbc>
    3274:	2420      	movs	r4, #32
    3276:	46a3      	mov	fp, r4
    3278:	449b      	add	fp, r3
    327a:	465c      	mov	r4, fp
    327c:	730c      	strb	r4, [r1, #12]
    327e:	b2e4      	uxtb	r4, r4
    3280:	2c1c      	cmp	r4, #28
    3282:	d81f      	bhi.n	32c4 <follow_path+0xfc>
			d = (BYTE)p[si++];			/* Get 2nd byte */
    3284:	3202      	adds	r2, #2
    3286:	5df4      	ldrb	r4, [r6, r7]
    3288:	46a3      	mov	fp, r4
			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
    328a:	0027      	movs	r7, r4
    328c:	3f40      	subs	r7, #64	; 0x40
    328e:	2f3e      	cmp	r7, #62	; 0x3e
    3290:	d904      	bls.n	329c <follow_path+0xd4>
    3292:	3f40      	subs	r7, #64	; 0x40
    3294:	b2ff      	uxtb	r7, r7
    3296:	2f7c      	cmp	r7, #124	; 0x7c
    3298:	d900      	bls.n	329c <follow_path+0xd4>
    329a:	e0a7      	b.n	33ec <follow_path+0x224>
    329c:	1e6f      	subs	r7, r5, #1
    329e:	42b8      	cmp	r0, r7
    32a0:	d300      	bcc.n	32a4 <follow_path+0xdc>
    32a2:	e0a5      	b.n	33f0 <follow_path+0x228>
			sfn[i++] = c;
    32a4:	1c47      	adds	r7, r0, #1
    32a6:	9901      	ldr	r1, [sp, #4]
    32a8:	540b      	strb	r3, [r1, r0]
			sfn[i++] = d;
    32aa:	465b      	mov	r3, fp
    32ac:	55cb      	strb	r3, [r1, r7]
    32ae:	3002      	adds	r0, #2
    32b0:	e7c3      	b.n	323a <follow_path+0x72>
			b |= 3;						/* Eliminate NT flag */
    32b2:	4664      	mov	r4, ip
    32b4:	4641      	mov	r1, r8
    32b6:	430c      	orrs	r4, r1
    32b8:	1c21      	adds	r1, r4, #0
    32ba:	466c      	mov	r4, sp
    32bc:	7321      	strb	r1, [r4, #12]
    32be:	7b21      	ldrb	r1, [r4, #12]
    32c0:	468c      	mov	ip, r1
    32c2:	e7ce      	b.n	3262 <follow_path+0x9a>
	while (*str && *str != chr) str++;
    32c4:	2b22      	cmp	r3, #34	; 0x22
    32c6:	d021      	beq.n	330c <follow_path+0x144>
    32c8:	222a      	movs	r2, #42	; 0x2a
    32ca:	4693      	mov	fp, r2
    32cc:	4a5f      	ldr	r2, [pc, #380]	; (344c <follow_path+0x284>)
    32ce:	4659      	mov	r1, fp
    32d0:	9103      	str	r1, [sp, #12]
    32d2:	9901      	ldr	r1, [sp, #4]
    32d4:	468b      	mov	fp, r1
    32d6:	0019      	movs	r1, r3
    32d8:	9c02      	ldr	r4, [sp, #8]
    32da:	232a      	movs	r3, #42	; 0x2a
    32dc:	4299      	cmp	r1, r3
    32de:	d017      	beq.n	3310 <follow_path+0x148>
    32e0:	3201      	adds	r2, #1
    32e2:	7813      	ldrb	r3, [r2, #0]
    32e4:	2b00      	cmp	r3, #0
    32e6:	d1f9      	bne.n	32dc <follow_path+0x114>
    32e8:	000b      	movs	r3, r1
    32ea:	465a      	mov	r2, fp
    32ec:	9201      	str	r2, [sp, #4]
    32ee:	9402      	str	r4, [sp, #8]
			if (IsUpper(c)) {			/* ASCII large capital? */
    32f0:	000a      	movs	r2, r1
    32f2:	3a41      	subs	r2, #65	; 0x41
    32f4:	2a19      	cmp	r2, #25
    32f6:	d810      	bhi.n	331a <follow_path+0x152>
				b |= 2;
    32f8:	4662      	mov	r2, ip
    32fa:	2102      	movs	r1, #2
    32fc:	430a      	orrs	r2, r1
    32fe:	b2d2      	uxtb	r2, r2
    3300:	4694      	mov	ip, r2
			sfn[i++] = c;
    3302:	9a01      	ldr	r2, [sp, #4]
    3304:	5413      	strb	r3, [r2, r0]
    3306:	3001      	adds	r0, #1
		c = (BYTE)p[si++];
    3308:	003a      	movs	r2, r7
    330a:	e796      	b.n	323a <follow_path+0x72>
				return FR_INVALID_NAME;
    330c:	2006      	movs	r0, #6
    330e:	e088      	b.n	3422 <follow_path+0x25a>
    3310:	1e0b      	subs	r3, r1, #0
    3312:	465a      	mov	r2, fp
    3314:	9201      	str	r2, [sp, #4]
    3316:	9402      	str	r4, [sp, #8]
			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c))	/* Reject illegal chrs for SFN */
    3318:	d16c      	bne.n	33f4 <follow_path+0x22c>
				if (IsLower(c)) {		/* ASCII small capital? */
    331a:	001a      	movs	r2, r3
    331c:	3a61      	subs	r2, #97	; 0x61
    331e:	2a19      	cmp	r2, #25
    3320:	d8ef      	bhi.n	3302 <follow_path+0x13a>
					b |= 1; c -= 0x20;
    3322:	4662      	mov	r2, ip
    3324:	4649      	mov	r1, r9
    3326:	430a      	orrs	r2, r1
    3328:	b2d2      	uxtb	r2, r2
    332a:	4694      	mov	ip, r2
    332c:	3b20      	subs	r3, #32
    332e:	b2db      	uxtb	r3, r3
    3330:	e7e7      	b.n	3302 <follow_path+0x13a>
	if (sfn[0] == DDEM) sfn[0] = RDDEM;	/* When first character collides with DDEM, replace it with RDDEM */
    3332:	780a      	ldrb	r2, [r1, #0]
    3334:	2ae5      	cmp	r2, #229	; 0xe5
    3336:	d018      	beq.n	336a <follow_path+0x1a2>
	if (ni == 8) b <<= 2;
    3338:	2d08      	cmp	r5, #8
    333a:	d019      	beq.n	3370 <follow_path+0x1a8>
	if ((b & 0x03) == 0x01) c |= NS_EXT;	/* NT flag (Name extension has only small capital) */
    333c:	2203      	movs	r2, #3
    333e:	4660      	mov	r0, ip
    3340:	4002      	ands	r2, r0
    3342:	2a01      	cmp	r2, #1
    3344:	d019      	beq.n	337a <follow_path+0x1b2>
	if ((b & 0x0C) == 0x04) c |= NS_BODY;	/* NT flag (Name body has only small capital) */
    3346:	220c      	movs	r2, #12
    3348:	4660      	mov	r0, ip
    334a:	4002      	ands	r2, r0
    334c:	2a04      	cmp	r2, #4
    334e:	d017      	beq.n	3380 <follow_path+0x1b8>
	sfn[NSFLAG] = c;		/* Store NT flag, File name is created */
    3350:	72cb      	strb	r3, [r1, #11]
	res = dir_sdi(dp, 0);			/* Rewind directory object */
    3352:	2100      	movs	r1, #0
    3354:	0020      	movs	r0, r4
    3356:	4b3c      	ldr	r3, [pc, #240]	; (3448 <follow_path+0x280>)
    3358:	4798      	blx	r3
	if (res != FR_OK) return res;
    335a:	2800      	cmp	r0, #0
    335c:	d15d      	bne.n	341a <follow_path+0x252>
		res = move_window(dp->fs, dp->sect);
    335e:	4b3c      	ldr	r3, [pc, #240]	; (3450 <follow_path+0x288>)
    3360:	469b      	mov	fp, r3
		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dp->fn, 11)) /* Is it a valid entry? */
    3362:	2308      	movs	r3, #8
    3364:	4698      	mov	r8, r3
    3366:	46b1      	mov	r9, r6
    3368:	e012      	b.n	3390 <follow_path+0x1c8>
	if (sfn[0] == DDEM) sfn[0] = RDDEM;	/* When first character collides with DDEM, replace it with RDDEM */
    336a:	3ae0      	subs	r2, #224	; 0xe0
    336c:	700a      	strb	r2, [r1, #0]
    336e:	e7e3      	b.n	3338 <follow_path+0x170>
	if (ni == 8) b <<= 2;
    3370:	4662      	mov	r2, ip
    3372:	0092      	lsls	r2, r2, #2
    3374:	b2d2      	uxtb	r2, r2
    3376:	4694      	mov	ip, r2
    3378:	e7e0      	b.n	333c <follow_path+0x174>
	if ((b & 0x03) == 0x01) c |= NS_EXT;	/* NT flag (Name extension has only small capital) */
    337a:	320f      	adds	r2, #15
    337c:	4313      	orrs	r3, r2
    337e:	e7e2      	b.n	3346 <follow_path+0x17e>
	if ((b & 0x0C) == 0x04) c |= NS_BODY;	/* NT flag (Name body has only small capital) */
    3380:	3204      	adds	r2, #4
    3382:	4313      	orrs	r3, r2
    3384:	e7e4      	b.n	3350 <follow_path+0x188>
		res = dir_next(dp, 0);		/* Next entry */
    3386:	2100      	movs	r1, #0
    3388:	0020      	movs	r0, r4
    338a:	47d0      	blx	sl
	} while (res == FR_OK);
    338c:	2800      	cmp	r0, #0
    338e:	d144      	bne.n	341a <follow_path+0x252>
		res = move_window(dp->fs, dp->sect);
    3390:	6921      	ldr	r1, [r4, #16]
    3392:	6820      	ldr	r0, [r4, #0]
    3394:	47d8      	blx	fp
		if (res != FR_OK) break;
    3396:	2800      	cmp	r0, #0
    3398:	d13f      	bne.n	341a <follow_path+0x252>
		dir = dp->dir;					/* Ptr to the directory entry of current index */
    339a:	6961      	ldr	r1, [r4, #20]
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
    339c:	780b      	ldrb	r3, [r1, #0]
    339e:	2b00      	cmp	r3, #0
    33a0:	d01a      	beq.n	33d8 <follow_path+0x210>
		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dp->fn, 11)) /* Is it a valid entry? */
    33a2:	7ace      	ldrb	r6, [r1, #11]
    33a4:	4643      	mov	r3, r8
    33a6:	4233      	tst	r3, r6
    33a8:	d1ed      	bne.n	3386 <follow_path+0x1be>
    33aa:	69a7      	ldr	r7, [r4, #24]
    33ac:	2300      	movs	r3, #0
	while (cnt-- && (r = *d++ - *s++) == 0) ;
    33ae:	5ccd      	ldrb	r5, [r1, r3]
    33b0:	5cfa      	ldrb	r2, [r7, r3]
    33b2:	4295      	cmp	r5, r2
    33b4:	d1e7      	bne.n	3386 <follow_path+0x1be>
    33b6:	3301      	adds	r3, #1
    33b8:	2b0b      	cmp	r3, #11
    33ba:	d1f8      	bne.n	33ae <follow_path+0x1e6>
    33bc:	464b      	mov	r3, r9
    33be:	46b1      	mov	r9, r6
    33c0:	001e      	movs	r6, r3
			if (ns & NS_LAST) break;			/* Last segment matched. Function completed. */
    33c2:	7afb      	ldrb	r3, [r7, #11]
    33c4:	075b      	lsls	r3, r3, #29
    33c6:	d42c      	bmi.n	3422 <follow_path+0x25a>
			if (!(dir[DIR_Attr] & AM_DIR)) {	/* It is not a sub-directory and cannot follow */
    33c8:	464b      	mov	r3, r9
    33ca:	06db      	lsls	r3, r3, #27
    33cc:	d514      	bpl.n	33f8 <follow_path+0x230>
			dp->sclust = ld_clust(dp->fs, dir);
    33ce:	6820      	ldr	r0, [r4, #0]
    33d0:	4b20      	ldr	r3, [pc, #128]	; (3454 <follow_path+0x28c>)
    33d2:	4798      	blx	r3
    33d4:	60a0      	str	r0, [r4, #8]
			res = create_name(dp, &path);	/* Get a segment name of the path */
    33d6:	e717      	b.n	3208 <follow_path+0x40>
			ns = dp->fn[NSFLAG];
    33d8:	69a3      	ldr	r3, [r4, #24]
    33da:	7adb      	ldrb	r3, [r3, #11]
						if (!(ns & NS_LAST)) res = FR_NO_PATH;	/* Adjust error code if not last segment */
    33dc:	2004      	movs	r0, #4
    33de:	4003      	ands	r3, r0
    33e0:	4258      	negs	r0, r3
    33e2:	4158      	adcs	r0, r3
    33e4:	3004      	adds	r0, #4
    33e6:	e01c      	b.n	3422 <follow_path+0x25a>
		if (c == '.' || i >= ni) {
    33e8:	2006      	movs	r0, #6
    33ea:	e01a      	b.n	3422 <follow_path+0x25a>
			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
    33ec:	2006      	movs	r0, #6
    33ee:	e018      	b.n	3422 <follow_path+0x25a>
    33f0:	2006      	movs	r0, #6
    33f2:	e016      	b.n	3422 <follow_path+0x25a>
			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c))	/* Reject illegal chrs for SFN */
    33f4:	2006      	movs	r0, #6
    33f6:	e014      	b.n	3422 <follow_path+0x25a>
				res = FR_NO_PATH; break;
    33f8:	2005      	movs	r0, #5
    33fa:	e012      	b.n	3422 <follow_path+0x25a>
			if (ni != 8 || c != '.') return FR_INVALID_NAME;
    33fc:	2006      	movs	r0, #6
    33fe:	e010      	b.n	3422 <follow_path+0x25a>
    3400:	9901      	ldr	r1, [sp, #4]
    3402:	9c02      	ldr	r4, [sp, #8]
	*path = &p[si];						/* Return pointer to the next segment */
    3404:	19f6      	adds	r6, r6, r7
	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
    3406:	2300      	movs	r3, #0
	if (!i) return FR_INVALID_NAME;		/* Reject nul string */
    3408:	2800      	cmp	r0, #0
    340a:	d192      	bne.n	3332 <follow_path+0x16a>
    340c:	2006      	movs	r0, #6
    340e:	e008      	b.n	3422 <follow_path+0x25a>
    3410:	9901      	ldr	r1, [sp, #4]
    3412:	9c02      	ldr	r4, [sp, #8]
	*path = &p[si];						/* Return pointer to the next segment */
    3414:	19f6      	adds	r6, r6, r7
	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
    3416:	2304      	movs	r3, #4
    3418:	e7f6      	b.n	3408 <follow_path+0x240>
			ns = dp->fn[NSFLAG];
    341a:	69a3      	ldr	r3, [r4, #24]
    341c:	7adb      	ldrb	r3, [r3, #11]
				if (res == FR_NO_FILE) {	/* Object is not found */
    341e:	2804      	cmp	r0, #4
    3420:	d0dc      	beq.n	33dc <follow_path+0x214>
}
    3422:	b005      	add	sp, #20
    3424:	bc3c      	pop	{r2, r3, r4, r5}
    3426:	4690      	mov	r8, r2
    3428:	4699      	mov	r9, r3
    342a:	46a2      	mov	sl, r4
    342c:	46ab      	mov	fp, r5
    342e:	bdf0      	pop	{r4, r5, r6, r7, pc}
			if (ni != 8 || c != '.') return FR_INVALID_NAME;
    3430:	2d08      	cmp	r5, #8
    3432:	d1e3      	bne.n	33fc <follow_path+0x234>
			b <<= 2; continue;
    3434:	4663      	mov	r3, ip
    3436:	009b      	lsls	r3, r3, #2
    3438:	b2db      	uxtb	r3, r3
    343a:	469c      	mov	ip, r3
			i = 8; ni = 11;
    343c:	0028      	movs	r0, r5
		c = (BYTE)p[si++];
    343e:	003a      	movs	r2, r7
			i = 8; ni = 11;
    3440:	250b      	movs	r5, #11
    3442:	e6fa      	b.n	323a <follow_path+0x72>
    3444:	000030a5 	.word	0x000030a5
    3448:	00002ddd 	.word	0x00002ddd
    344c:	000048f1 	.word	0x000048f1
    3450:	000026e1 	.word	0x000026e1
    3454:	000025fd 	.word	0x000025fd

00003458 <dir_register>:
{
    3458:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    345a:	0005      	movs	r5, r0
	res = dir_sdi(dp, 0);
    345c:	2100      	movs	r1, #0
    345e:	4b1b      	ldr	r3, [pc, #108]	; (34cc <dir_register+0x74>)
    3460:	4798      	blx	r3
    3462:	1e04      	subs	r4, r0, #0
	if (res == FR_OK) {
    3464:	d12b      	bne.n	34be <dir_register+0x66>
			res = move_window(dp->fs, dp->sect);
    3466:	4e1a      	ldr	r6, [pc, #104]	; (34d0 <dir_register+0x78>)
			res = dir_next(dp, 1);		/* Next entry with table stretch enabled */
    3468:	4f1a      	ldr	r7, [pc, #104]	; (34d4 <dir_register+0x7c>)
    346a:	e004      	b.n	3476 <dir_register+0x1e>
    346c:	2101      	movs	r1, #1
    346e:	0028      	movs	r0, r5
    3470:	47b8      	blx	r7
    3472:	1e04      	subs	r4, r0, #0
		} while (res == FR_OK);
    3474:	d127      	bne.n	34c6 <dir_register+0x6e>
			res = move_window(dp->fs, dp->sect);
    3476:	6929      	ldr	r1, [r5, #16]
    3478:	6828      	ldr	r0, [r5, #0]
    347a:	47b0      	blx	r6
    347c:	1e04      	subs	r4, r0, #0
			if (res != FR_OK) break;
    347e:	d122      	bne.n	34c6 <dir_register+0x6e>
			if (dp->dir[0] == DDEM || dp->dir[0] == 0) {	/* Is it a free entry? */
    3480:	696b      	ldr	r3, [r5, #20]
    3482:	781b      	ldrb	r3, [r3, #0]
    3484:	2be5      	cmp	r3, #229	; 0xe5
    3486:	d001      	beq.n	348c <dir_register+0x34>
    3488:	2b00      	cmp	r3, #0
    348a:	d1ef      	bne.n	346c <dir_register+0x14>
		res = move_window(dp->fs, dp->sect);
    348c:	6929      	ldr	r1, [r5, #16]
    348e:	6828      	ldr	r0, [r5, #0]
    3490:	4b0f      	ldr	r3, [pc, #60]	; (34d0 <dir_register+0x78>)
    3492:	4798      	blx	r3
    3494:	1e04      	subs	r4, r0, #0
		if (res == FR_OK) {
    3496:	d001      	beq.n	349c <dir_register+0x44>
}
    3498:	0020      	movs	r0, r4
    349a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			mem_set(dp->dir, 0, SZ_DIRE);	/* Clean the entry */
    349c:	696b      	ldr	r3, [r5, #20]
    349e:	0019      	movs	r1, r3
    34a0:	3120      	adds	r1, #32
		*d++ = (BYTE)val;
    34a2:	2200      	movs	r2, #0
    34a4:	701a      	strb	r2, [r3, #0]
    34a6:	3301      	adds	r3, #1
	while (cnt--)
    34a8:	428b      	cmp	r3, r1
    34aa:	d1fb      	bne.n	34a4 <dir_register+0x4c>
			mem_cpy(dp->dir, dp->fn, 11);	/* Put SFN */
    34ac:	220b      	movs	r2, #11
    34ae:	69a9      	ldr	r1, [r5, #24]
    34b0:	6968      	ldr	r0, [r5, #20]
    34b2:	4b09      	ldr	r3, [pc, #36]	; (34d8 <dir_register+0x80>)
    34b4:	4798      	blx	r3
			dp->fs->wflag = 1;
    34b6:	682b      	ldr	r3, [r5, #0]
    34b8:	2201      	movs	r2, #1
    34ba:	711a      	strb	r2, [r3, #4]
    34bc:	e7ec      	b.n	3498 <dir_register+0x40>
	if (res == FR_NO_FILE) res = FR_DENIED;	/* No directory entry to allocate */
    34be:	2804      	cmp	r0, #4
    34c0:	d1ea      	bne.n	3498 <dir_register+0x40>
    34c2:	2407      	movs	r4, #7
    34c4:	e7e8      	b.n	3498 <dir_register+0x40>
    34c6:	2c04      	cmp	r4, #4
    34c8:	d0fb      	beq.n	34c2 <dir_register+0x6a>
    34ca:	e7e5      	b.n	3498 <dir_register+0x40>
    34cc:	00002ddd 	.word	0x00002ddd
    34d0:	000026e1 	.word	0x000026e1
    34d4:	000030a5 	.word	0x000030a5
    34d8:	000025e9 	.word	0x000025e9

000034dc <remove_chain>:
{
    34dc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    34de:	46ce      	mov	lr, r9
    34e0:	4647      	mov	r7, r8
    34e2:	b580      	push	{r7, lr}
    34e4:	0004      	movs	r4, r0
    34e6:	000d      	movs	r5, r1
		res = FR_INT_ERR;
    34e8:	2002      	movs	r0, #2
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
    34ea:	2901      	cmp	r1, #1
    34ec:	d902      	bls.n	34f4 <remove_chain+0x18>
    34ee:	6963      	ldr	r3, [r4, #20]
    34f0:	4299      	cmp	r1, r3
    34f2:	d303      	bcc.n	34fc <remove_chain+0x20>
}
    34f4:	bc0c      	pop	{r2, r3}
    34f6:	4690      	mov	r8, r2
    34f8:	4699      	mov	r9, r3
    34fa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			nxt = get_fat(fs, clst);			/* Get cluster status */
    34fc:	4f14      	ldr	r7, [pc, #80]	; (3550 <remove_chain+0x74>)
			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
    34fe:	4b15      	ldr	r3, [pc, #84]	; (3554 <remove_chain+0x78>)
    3500:	4698      	mov	r8, r3
				fs->fsi_flag |= 1;
    3502:	2301      	movs	r3, #1
    3504:	4699      	mov	r9, r3
    3506:	e003      	b.n	3510 <remove_chain+0x34>
    3508:	0035      	movs	r5, r6
		while (clst < fs->n_fatent) {			/* Not a last link? */
    350a:	6963      	ldr	r3, [r4, #20]
    350c:	42b3      	cmp	r3, r6
    350e:	d9f1      	bls.n	34f4 <remove_chain+0x18>
			nxt = get_fat(fs, clst);			/* Get cluster status */
    3510:	0029      	movs	r1, r5
    3512:	0020      	movs	r0, r4
    3514:	47b8      	blx	r7
    3516:	1e06      	subs	r6, r0, #0
			if (nxt == 0) break;				/* Empty cluster? */
    3518:	d013      	beq.n	3542 <remove_chain+0x66>
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
    351a:	2801      	cmp	r0, #1
    351c:	d013      	beq.n	3546 <remove_chain+0x6a>
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
    351e:	1c43      	adds	r3, r0, #1
    3520:	d013      	beq.n	354a <remove_chain+0x6e>
			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
    3522:	2200      	movs	r2, #0
    3524:	0029      	movs	r1, r5
    3526:	0020      	movs	r0, r4
    3528:	47c0      	blx	r8
			if (res != FR_OK) break;
    352a:	2800      	cmp	r0, #0
    352c:	d1e2      	bne.n	34f4 <remove_chain+0x18>
			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSINFO */
    352e:	6923      	ldr	r3, [r4, #16]
    3530:	1c5a      	adds	r2, r3, #1
    3532:	d0e9      	beq.n	3508 <remove_chain+0x2c>
				fs->free_clust++;
    3534:	3301      	adds	r3, #1
    3536:	6123      	str	r3, [r4, #16]
				fs->fsi_flag |= 1;
    3538:	7963      	ldrb	r3, [r4, #5]
    353a:	464a      	mov	r2, r9
    353c:	4313      	orrs	r3, r2
    353e:	7163      	strb	r3, [r4, #5]
    3540:	e7e2      	b.n	3508 <remove_chain+0x2c>
    3542:	2000      	movs	r0, #0
    3544:	e7d6      	b.n	34f4 <remove_chain+0x18>
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
    3546:	2002      	movs	r0, #2
    3548:	e7d4      	b.n	34f4 <remove_chain+0x18>
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
    354a:	2001      	movs	r0, #1
    354c:	e7d2      	b.n	34f4 <remove_chain+0x18>
    354e:	46c0      	nop			; (mov r8, r8)
    3550:	00002ce5 	.word	0x00002ce5
    3554:	00002e8d 	.word	0x00002e8d

00003558 <f_mount>:
FRESULT f_mount (
	FATFS* fs,			/* Pointer to the file system object (NULL:unmount)*/
	const TCHAR* path,	/* Logical drive number to be mounted/unmounted */
	BYTE opt			/* 0:Do not mount (delayed mount), 1:Mount immediately */
)
{
    3558:	b510      	push	{r4, lr}
    355a:	b084      	sub	sp, #16
    355c:	9001      	str	r0, [sp, #4]
    355e:	9100      	str	r1, [sp, #0]
    3560:	0014      	movs	r4, r2
	FATFS *cfs;
	int vol;
	FRESULT res;
	const TCHAR *rp = path;
    3562:	9103      	str	r1, [sp, #12]


	vol = get_ldnumber(&rp);
    3564:	a803      	add	r0, sp, #12
    3566:	4b15      	ldr	r3, [pc, #84]	; (35bc <f_mount+0x64>)
    3568:	4798      	blx	r3
	if (vol < 0) return FR_INVALID_DRIVE;
    356a:	230b      	movs	r3, #11
    356c:	2800      	cmp	r0, #0
    356e:	db14      	blt.n	359a <f_mount+0x42>
	cfs = FatFs[vol];					/* Pointer to fs object */
    3570:	0083      	lsls	r3, r0, #2
    3572:	4a13      	ldr	r2, [pc, #76]	; (35c0 <f_mount+0x68>)
    3574:	589b      	ldr	r3, [r3, r2]

	if (cfs) {
    3576:	2b00      	cmp	r3, #0
    3578:	d001      	beq.n	357e <f_mount+0x26>
		clear_lock(cfs);
#endif
#if _FS_REENTRANT						/* Discard sync object of the current volume */
		if (!ff_del_syncobj(cfs->sobj)) return FR_INT_ERR;
#endif
		cfs->fs_type = 0;				/* Clear old fs object */
    357a:	2200      	movs	r2, #0
    357c:	701a      	strb	r2, [r3, #0]
	}

	if (fs) {
    357e:	9b01      	ldr	r3, [sp, #4]
    3580:	2b00      	cmp	r3, #0
    3582:	d014      	beq.n	35ae <f_mount+0x56>
		fs->fs_type = 0;				/* Clear new fs object */
    3584:	2200      	movs	r2, #0
    3586:	701a      	strb	r2, [r3, #0]
#if _FS_REENTRANT						/* Create sync object for the new volume */
		if (!ff_cre_syncobj((BYTE)vol, &fs->sobj)) return FR_INT_ERR;
#endif
	}
	FatFs[vol] = fs;					/* Register new fs object */
    3588:	9a01      	ldr	r2, [sp, #4]
    358a:	0080      	lsls	r0, r0, #2
    358c:	4b0c      	ldr	r3, [pc, #48]	; (35c0 <f_mount+0x68>)
    358e:	50c2      	str	r2, [r0, r3]

	if (!fs || opt != 1) return FR_OK;	/* Do not mount now, it will be mounted later */
    3590:	2300      	movs	r3, #0
    3592:	2a00      	cmp	r2, #0
    3594:	d001      	beq.n	359a <f_mount+0x42>
    3596:	2c01      	cmp	r4, #1
    3598:	d002      	beq.n	35a0 <f_mount+0x48>

	res = find_volume(&fs, &path, 0);	/* Force mounted the volume */
	LEAVE_FF(fs, res);
}
    359a:	0018      	movs	r0, r3
    359c:	b004      	add	sp, #16
    359e:	bd10      	pop	{r4, pc}
	res = find_volume(&fs, &path, 0);	/* Force mounted the volume */
    35a0:	2200      	movs	r2, #0
    35a2:	4669      	mov	r1, sp
    35a4:	a801      	add	r0, sp, #4
    35a6:	4b07      	ldr	r3, [pc, #28]	; (35c4 <f_mount+0x6c>)
    35a8:	4798      	blx	r3
    35aa:	0003      	movs	r3, r0
	LEAVE_FF(fs, res);
    35ac:	e7f5      	b.n	359a <f_mount+0x42>
	FatFs[vol] = fs;					/* Register new fs object */
    35ae:	0080      	lsls	r0, r0, #2
    35b0:	2200      	movs	r2, #0
    35b2:	4b03      	ldr	r3, [pc, #12]	; (35c0 <f_mount+0x68>)
    35b4:	50c2      	str	r2, [r0, r3]
	if (!fs || opt != 1) return FR_OK;	/* Do not mount now, it will be mounted later */
    35b6:	2300      	movs	r3, #0
    35b8:	e7ef      	b.n	359a <f_mount+0x42>
    35ba:	46c0      	nop			; (mov r8, r8)
    35bc:	0000261f 	.word	0x0000261f
    35c0:	20000458 	.word	0x20000458
    35c4:	000027fd 	.word	0x000027fd

000035c8 <f_open>:
FRESULT f_open (
	FIL* fp,			/* Pointer to the blank file object */
	const TCHAR* path,	/* Pointer to the file name */
	BYTE mode			/* Access mode and file open mode flags */
)
{
    35c8:	b5f0      	push	{r4, r5, r6, r7, lr}
    35ca:	46d6      	mov	lr, sl
    35cc:	464f      	mov	r7, r9
    35ce:	4646      	mov	r6, r8
    35d0:	b5c0      	push	{r6, r7, lr}
    35d2:	b08c      	sub	sp, #48	; 0x30
    35d4:	0005      	movs	r5, r0
    35d6:	9101      	str	r1, [sp, #4]
    35d8:	0016      	movs	r6, r2
#if !_FS_READONLY
	DWORD dw, cl;
#endif


	if (!fp) return FR_INVALID_OBJECT;
    35da:	2409      	movs	r4, #9
    35dc:	2800      	cmp	r0, #0
    35de:	d009      	beq.n	35f4 <f_open+0x2c>
	fp->fs = 0;			/* Clear file object */
    35e0:	2300      	movs	r3, #0
    35e2:	6003      	str	r3, [r0, #0]

	/* Get logical drive number */
#if !_FS_READONLY
	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
	res = find_volume(&dj.fs, &path, (BYTE)(mode & ~FA_READ));
    35e4:	221e      	movs	r2, #30
    35e6:	4032      	ands	r2, r6
    35e8:	a901      	add	r1, sp, #4
    35ea:	a805      	add	r0, sp, #20
    35ec:	4b57      	ldr	r3, [pc, #348]	; (374c <f_open+0x184>)
    35ee:	4798      	blx	r3
    35f0:	1e04      	subs	r4, r0, #0
#else
	mode &= FA_READ;
	res = find_volume(&dj.fs, &path, 0);
#endif
	if (res == FR_OK) {
    35f2:	d006      	beq.n	3602 <f_open+0x3a>
			fp->id = fp->fs->id;
		}
	}

	LEAVE_FF(dj.fs, res);
}
    35f4:	0020      	movs	r0, r4
    35f6:	b00c      	add	sp, #48	; 0x30
    35f8:	bc1c      	pop	{r2, r3, r4}
    35fa:	4690      	mov	r8, r2
    35fc:	4699      	mov	r9, r3
    35fe:	46a2      	mov	sl, r4
    3600:	bdf0      	pop	{r4, r5, r6, r7, pc}
	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
    3602:	231f      	movs	r3, #31
    3604:	4033      	ands	r3, r6
    3606:	4698      	mov	r8, r3
		INIT_BUF(dj);
    3608:	ab02      	add	r3, sp, #8
    360a:	930b      	str	r3, [sp, #44]	; 0x2c
		res = follow_path(&dj, path);	/* Follow the file path */
    360c:	9901      	ldr	r1, [sp, #4]
    360e:	a805      	add	r0, sp, #20
    3610:	4b4f      	ldr	r3, [pc, #316]	; (3750 <f_open+0x188>)
    3612:	4798      	blx	r3
		dir = dj.dir;
    3614:	9f0a      	ldr	r7, [sp, #40]	; 0x28
		if (res == FR_OK) {
    3616:	2800      	cmp	r0, #0
    3618:	d135      	bne.n	3686 <f_open+0xbe>
			if (!dir)	/* Default directory itself */
    361a:	2f00      	cmp	r7, #0
    361c:	d100      	bne.n	3620 <f_open+0x58>
    361e:	e088      	b.n	3732 <f_open+0x16a>
		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
    3620:	231c      	movs	r3, #28
    3622:	4233      	tst	r3, r6
    3624:	d149      	bne.n	36ba <f_open+0xf2>
				if (dir[DIR_Attr] & AM_DIR) {	/* It is a directory */
    3626:	7afb      	ldrb	r3, [r7, #11]
    3628:	06da      	lsls	r2, r3, #27
    362a:	d500      	bpl.n	362e <f_open+0x66>
    362c:	e08c      	b.n	3748 <f_open+0x180>
					if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
    362e:	07b2      	lsls	r2, r6, #30
    3630:	d502      	bpl.n	3638 <f_open+0x70>
    3632:	07db      	lsls	r3, r3, #31
    3634:	d500      	bpl.n	3638 <f_open+0x70>
    3636:	e085      	b.n	3744 <f_open+0x17c>
			if (mode & FA_CREATE_ALWAYS)		/* Set file change flag if created or overwritten */
    3638:	0733      	lsls	r3, r6, #28
    363a:	d503      	bpl.n	3644 <f_open+0x7c>
				mode |= FA__WRITTEN;
    363c:	2320      	movs	r3, #32
    363e:	4642      	mov	r2, r8
    3640:	431a      	orrs	r2, r3
    3642:	4690      	mov	r8, r2
			fp->dir_sect = dj.fs->winsect;		/* Pointer to the directory entry */
    3644:	9b05      	ldr	r3, [sp, #20]
    3646:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    3648:	61eb      	str	r3, [r5, #28]
			fp->dir_ptr = dir;
    364a:	622f      	str	r7, [r5, #32]
			fp->flag = mode;					/* File access mode */
    364c:	4643      	mov	r3, r8
    364e:	71ab      	strb	r3, [r5, #6]
			fp->err = 0;						/* Clear error flag */
    3650:	2300      	movs	r3, #0
    3652:	4698      	mov	r8, r3
    3654:	71eb      	strb	r3, [r5, #7]
			fp->sclust = ld_clust(dj.fs, dir);	/* File start cluster */
    3656:	9e05      	ldr	r6, [sp, #20]
    3658:	0039      	movs	r1, r7
    365a:	0030      	movs	r0, r6
    365c:	4b3d      	ldr	r3, [pc, #244]	; (3754 <f_open+0x18c>)
    365e:	4798      	blx	r3
    3660:	6128      	str	r0, [r5, #16]
			fp->fsize = LD_DWORD(dir + DIR_FileSize);	/* File size */
    3662:	7ffb      	ldrb	r3, [r7, #31]
    3664:	061b      	lsls	r3, r3, #24
    3666:	7fba      	ldrb	r2, [r7, #30]
    3668:	0412      	lsls	r2, r2, #16
    366a:	4313      	orrs	r3, r2
    366c:	7f3a      	ldrb	r2, [r7, #28]
    366e:	4313      	orrs	r3, r2
    3670:	7f7a      	ldrb	r2, [r7, #29]
    3672:	0212      	lsls	r2, r2, #8
    3674:	4313      	orrs	r3, r2
    3676:	60eb      	str	r3, [r5, #12]
			fp->fptr = 0;						/* File pointer */
    3678:	4643      	mov	r3, r8
    367a:	60ab      	str	r3, [r5, #8]
			fp->dsect = 0;
    367c:	61ab      	str	r3, [r5, #24]
			fp->fs = dj.fs;	 					/* Validate file object */
    367e:	602e      	str	r6, [r5, #0]
			fp->id = fp->fs->id;
    3680:	88f3      	ldrh	r3, [r6, #6]
    3682:	80ab      	strh	r3, [r5, #4]
    3684:	e7b6      	b.n	35f4 <f_open+0x2c>
		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
    3686:	231c      	movs	r3, #28
    3688:	4233      	tst	r3, r6
    368a:	d006      	beq.n	369a <f_open+0xd2>
				if (res == FR_NO_FILE)			/* There is no file to open, create a new entry */
    368c:	2804      	cmp	r0, #4
    368e:	d008      	beq.n	36a2 <f_open+0xda>
				mode |= FA_CREATE_ALWAYS;		/* File is created */
    3690:	2308      	movs	r3, #8
    3692:	4642      	mov	r2, r8
    3694:	431a      	orrs	r2, r3
    3696:	4690      	mov	r8, r2
				dir = dj.dir;					/* New entry */
    3698:	9f0a      	ldr	r7, [sp, #40]	; 0x28
		if (res == FR_OK) {
    369a:	2800      	cmp	r0, #0
    369c:	d0d6      	beq.n	364c <f_open+0x84>
    369e:	0004      	movs	r4, r0
    36a0:	e7a8      	b.n	35f4 <f_open+0x2c>
					res = dir_register(&dj);
    36a2:	a805      	add	r0, sp, #20
    36a4:	4b2c      	ldr	r3, [pc, #176]	; (3758 <f_open+0x190>)
    36a6:	4798      	blx	r3
				mode |= FA_CREATE_ALWAYS;		/* File is created */
    36a8:	2308      	movs	r3, #8
    36aa:	4642      	mov	r2, r8
    36ac:	431a      	orrs	r2, r3
    36ae:	4690      	mov	r8, r2
				dir = dj.dir;					/* New entry */
    36b0:	9f0a      	ldr	r7, [sp, #40]	; 0x28
			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
    36b2:	2800      	cmp	r0, #0
    36b4:	d007      	beq.n	36c6 <f_open+0xfe>
					res = dir_register(&dj);
    36b6:	0004      	movs	r4, r0
    36b8:	e79c      	b.n	35f4 <f_open+0x2c>
				if (dir[DIR_Attr] & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
    36ba:	7afb      	ldrb	r3, [r7, #11]
    36bc:	2211      	movs	r2, #17
    36be:	421a      	tst	r2, r3
    36c0:	d13c      	bne.n	373c <f_open+0x174>
					if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
    36c2:	0773      	lsls	r3, r6, #29
    36c4:	d43c      	bmi.n	3740 <f_open+0x178>
			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
    36c6:	4643      	mov	r3, r8
    36c8:	071b      	lsls	r3, r3, #28
    36ca:	d5bb      	bpl.n	3644 <f_open+0x7c>
				dw = GET_FATTIME();				/* Created time */
    36cc:	4b23      	ldr	r3, [pc, #140]	; (375c <f_open+0x194>)
    36ce:	4798      	blx	r3
				ST_DWORD(dir + DIR_CrtTime, dw);
    36d0:	73b8      	strb	r0, [r7, #14]
    36d2:	0a03      	lsrs	r3, r0, #8
    36d4:	73fb      	strb	r3, [r7, #15]
    36d6:	0c03      	lsrs	r3, r0, #16
    36d8:	743b      	strb	r3, [r7, #16]
    36da:	0e00      	lsrs	r0, r0, #24
    36dc:	7478      	strb	r0, [r7, #17]
				dir[DIR_Attr] = 0;				/* Reset attribute */
    36de:	2600      	movs	r6, #0
    36e0:	72fe      	strb	r6, [r7, #11]
				ST_DWORD(dir + DIR_FileSize, 0);/* size = 0 */
    36e2:	773e      	strb	r6, [r7, #28]
    36e4:	777e      	strb	r6, [r7, #29]
    36e6:	77be      	strb	r6, [r7, #30]
    36e8:	77fe      	strb	r6, [r7, #31]
				cl = ld_clust(dj.fs, dir);		/* Get start cluster */
    36ea:	9b05      	ldr	r3, [sp, #20]
    36ec:	4699      	mov	r9, r3
    36ee:	0039      	movs	r1, r7
    36f0:	0018      	movs	r0, r3
    36f2:	4b18      	ldr	r3, [pc, #96]	; (3754 <f_open+0x18c>)
    36f4:	4798      	blx	r3
    36f6:	4682      	mov	sl, r0
	ST_WORD(dir + DIR_FstClusLO, cl);
    36f8:	76be      	strb	r6, [r7, #26]
    36fa:	76fe      	strb	r6, [r7, #27]
	ST_WORD(dir + DIR_FstClusHI, cl >> 16);
    36fc:	753e      	strb	r6, [r7, #20]
    36fe:	757e      	strb	r6, [r7, #21]
				dj.fs->wflag = 1;
    3700:	2301      	movs	r3, #1
    3702:	464a      	mov	r2, r9
    3704:	7113      	strb	r3, [r2, #4]
				if (cl) {						/* Remove the cluster chain if exist */
    3706:	2800      	cmp	r0, #0
    3708:	d098      	beq.n	363c <f_open+0x74>
					dw = dj.fs->winsect;
    370a:	6ad6      	ldr	r6, [r2, #44]	; 0x2c
					res = remove_chain(dj.fs, cl);
    370c:	0001      	movs	r1, r0
    370e:	4648      	mov	r0, r9
    3710:	4b13      	ldr	r3, [pc, #76]	; (3760 <f_open+0x198>)
    3712:	4798      	blx	r3
					if (res == FR_OK) {
    3714:	2800      	cmp	r0, #0
    3716:	d001      	beq.n	371c <f_open+0x154>
					res = remove_chain(dj.fs, cl);
    3718:	0004      	movs	r4, r0
    371a:	e76b      	b.n	35f4 <f_open+0x2c>
						dj.fs->last_clust = cl - 1;	/* Reuse the cluster hole */
    371c:	9805      	ldr	r0, [sp, #20]
    371e:	4653      	mov	r3, sl
    3720:	3b01      	subs	r3, #1
    3722:	60c3      	str	r3, [r0, #12]
						res = move_window(dj.fs, dw);
    3724:	0031      	movs	r1, r6
    3726:	4b0f      	ldr	r3, [pc, #60]	; (3764 <f_open+0x19c>)
    3728:	4798      	blx	r3
		if (res == FR_OK) {
    372a:	2800      	cmp	r0, #0
    372c:	d086      	beq.n	363c <f_open+0x74>
						res = move_window(dj.fs, dw);
    372e:	0004      	movs	r4, r0
    3730:	e760      	b.n	35f4 <f_open+0x2c>
		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
    3732:	231c      	movs	r3, #28
				res = FR_INVALID_NAME;
    3734:	2006      	movs	r0, #6
		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
    3736:	4233      	tst	r3, r6
    3738:	d1aa      	bne.n	3690 <f_open+0xc8>
    373a:	e7ae      	b.n	369a <f_open+0xd2>
					res = FR_DENIED;
    373c:	2407      	movs	r4, #7
    373e:	e759      	b.n	35f4 <f_open+0x2c>
						res = FR_EXIST;
    3740:	2408      	movs	r4, #8
    3742:	e757      	b.n	35f4 <f_open+0x2c>
						res = FR_DENIED;
    3744:	2407      	movs	r4, #7
    3746:	e755      	b.n	35f4 <f_open+0x2c>
					res = FR_NO_FILE;
    3748:	2404      	movs	r4, #4
    374a:	e753      	b.n	35f4 <f_open+0x2c>
    374c:	000027fd 	.word	0x000027fd
    3750:	000031c9 	.word	0x000031c9
    3754:	000025fd 	.word	0x000025fd
    3758:	00003459 	.word	0x00003459
    375c:	000025e5 	.word	0x000025e5
    3760:	000034dd 	.word	0x000034dd
    3764:	000026e1 	.word	0x000026e1

00003768 <f_read>:
	FIL* fp, 		/* Pointer to the file object */
	void* buff,		/* Pointer to data buffer */
	UINT btr,		/* Number of bytes to read */
	UINT* br		/* Pointer to number of bytes read */
)
{
    3768:	b5f0      	push	{r4, r5, r6, r7, lr}
    376a:	46de      	mov	lr, fp
    376c:	4657      	mov	r7, sl
    376e:	464e      	mov	r6, r9
    3770:	4645      	mov	r5, r8
    3772:	b5e0      	push	{r5, r6, r7, lr}
    3774:	b083      	sub	sp, #12
    3776:	0004      	movs	r4, r0
    3778:	000e      	movs	r6, r1
    377a:	0015      	movs	r5, r2
    377c:	4699      	mov	r9, r3
	DWORD clst, sect, remain;
	UINT rcnt, cc;
	BYTE csect, *rbuff = (BYTE*)buff;


	*br = 0;	/* Clear read byte counter */
    377e:	2300      	movs	r3, #0
    3780:	464a      	mov	r2, r9
    3782:	6013      	str	r3, [r2, #0]

	res = validate(fp);							/* Check validity */
    3784:	4b5d      	ldr	r3, [pc, #372]	; (38fc <f_read+0x194>)
    3786:	4798      	blx	r3
    3788:	9001      	str	r0, [sp, #4]
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
    378a:	2800      	cmp	r0, #0
    378c:	d108      	bne.n	37a0 <f_read+0x38>
	if (fp->err)								/* Check error */
    378e:	79e3      	ldrb	r3, [r4, #7]
    3790:	2b00      	cmp	r3, #0
    3792:	d000      	beq.n	3796 <f_read+0x2e>
    3794:	e0af      	b.n	38f6 <f_read+0x18e>
		LEAVE_FF(fp->fs, (FRESULT)fp->err);
	if (!(fp->flag & FA_READ)) 					/* Check access mode */
    3796:	79a3      	ldrb	r3, [r4, #6]
    3798:	07db      	lsls	r3, r3, #31
    379a:	d409      	bmi.n	37b0 <f_read+0x48>
		LEAVE_FF(fp->fs, FR_DENIED);
    379c:	2307      	movs	r3, #7
    379e:	9301      	str	r3, [sp, #4]
		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
#endif
	}

	LEAVE_FF(fp->fs, FR_OK);
}
    37a0:	9801      	ldr	r0, [sp, #4]
    37a2:	b003      	add	sp, #12
    37a4:	bc3c      	pop	{r2, r3, r4, r5}
    37a6:	4690      	mov	r8, r2
    37a8:	4699      	mov	r9, r3
    37aa:	46a2      	mov	sl, r4
    37ac:	46ab      	mov	fp, r5
    37ae:	bdf0      	pop	{r4, r5, r6, r7, pc}
	remain = fp->fsize - fp->fptr;
    37b0:	68e3      	ldr	r3, [r4, #12]
    37b2:	68a2      	ldr	r2, [r4, #8]
    37b4:	1a9f      	subs	r7, r3, r2
    37b6:	42af      	cmp	r7, r5
    37b8:	d900      	bls.n	37bc <f_read+0x54>
    37ba:	002f      	movs	r7, r5
	for ( ;  btr;								/* Repeat until all data read */
    37bc:	2f00      	cmp	r7, #0
    37be:	d156      	bne.n	386e <f_read+0x106>
    37c0:	e7ee      	b.n	37a0 <f_read+0x38>
						clst = get_fat(fp->fs, fp->clust);	/* Follow cluster chain on the FAT */
    37c2:	6961      	ldr	r1, [r4, #20]
    37c4:	4b4e      	ldr	r3, [pc, #312]	; (3900 <f_read+0x198>)
    37c6:	4798      	blx	r3
    37c8:	e05f      	b.n	388a <f_read+0x122>
				if (clst < 2) ABORT(fp->fs, FR_INT_ERR);
    37ca:	2302      	movs	r3, #2
    37cc:	71e3      	strb	r3, [r4, #7]
    37ce:	9301      	str	r3, [sp, #4]
    37d0:	e7e6      	b.n	37a0 <f_read+0x38>
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
    37d2:	2301      	movs	r3, #1
    37d4:	71e3      	strb	r3, [r4, #7]
    37d6:	9301      	str	r3, [sp, #4]
    37d8:	e7e2      	b.n	37a0 <f_read+0x38>
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
    37da:	2302      	movs	r3, #2
    37dc:	71e3      	strb	r3, [r4, #7]
    37de:	9301      	str	r3, [sp, #4]
    37e0:	e7de      	b.n	37a0 <f_read+0x38>
					ABORT(fp->fs, FR_DISK_ERR);
    37e2:	2301      	movs	r3, #1
    37e4:	71e3      	strb	r3, [r4, #7]
    37e6:	9301      	str	r3, [sp, #4]
    37e8:	e7da      	b.n	37a0 <f_read+0x38>
					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
    37ea:	0021      	movs	r1, r4
    37ec:	3124      	adds	r1, #36	; 0x24
    37ee:	0240      	lsls	r0, r0, #9
    37f0:	1830      	adds	r0, r6, r0
    37f2:	2280      	movs	r2, #128	; 0x80
    37f4:	0092      	lsls	r2, r2, #2
    37f6:	4b43      	ldr	r3, [pc, #268]	; (3904 <f_read+0x19c>)
    37f8:	4798      	blx	r3
    37fa:	e071      	b.n	38e0 <f_read+0x178>
			if (fp->dsect != sect) {			/* Load data sector if not in cache */
    37fc:	69a2      	ldr	r2, [r4, #24]
    37fe:	4593      	cmp	fp, r2
    3800:	d019      	beq.n	3836 <f_read+0xce>
				if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
    3802:	79a3      	ldrb	r3, [r4, #6]
    3804:	065b      	lsls	r3, r3, #25
    3806:	d50c      	bpl.n	3822 <f_read+0xba>
					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
    3808:	0021      	movs	r1, r4
    380a:	3124      	adds	r1, #36	; 0x24
    380c:	4653      	mov	r3, sl
    380e:	7858      	ldrb	r0, [r3, #1]
    3810:	2301      	movs	r3, #1
    3812:	4d3d      	ldr	r5, [pc, #244]	; (3908 <f_read+0x1a0>)
    3814:	47a8      	blx	r5
    3816:	2800      	cmp	r0, #0
    3818:	d165      	bne.n	38e6 <f_read+0x17e>
					fp->flag &= ~FA__DIRTY;
    381a:	79a3      	ldrb	r3, [r4, #6]
    381c:	2240      	movs	r2, #64	; 0x40
    381e:	4393      	bics	r3, r2
    3820:	71a3      	strb	r3, [r4, #6]
				if (disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)	/* Fill sector cache */
    3822:	0021      	movs	r1, r4
    3824:	3124      	adds	r1, #36	; 0x24
    3826:	6823      	ldr	r3, [r4, #0]
    3828:	7858      	ldrb	r0, [r3, #1]
    382a:	2301      	movs	r3, #1
    382c:	465a      	mov	r2, fp
    382e:	4d37      	ldr	r5, [pc, #220]	; (390c <f_read+0x1a4>)
    3830:	47a8      	blx	r5
    3832:	2800      	cmp	r0, #0
    3834:	d15b      	bne.n	38ee <f_read+0x186>
			fp->dsect = sect;
    3836:	465b      	mov	r3, fp
    3838:	61a3      	str	r3, [r4, #24]
		rcnt = SS(fp->fs) - ((UINT)fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer */
    383a:	68a3      	ldr	r3, [r4, #8]
    383c:	05d9      	lsls	r1, r3, #23
    383e:	0dc9      	lsrs	r1, r1, #23
    3840:	2580      	movs	r5, #128	; 0x80
    3842:	00ad      	lsls	r5, r5, #2
    3844:	1a6d      	subs	r5, r5, r1
    3846:	42bd      	cmp	r5, r7
    3848:	d900      	bls.n	384c <f_read+0xe4>
    384a:	003d      	movs	r5, r7
		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
    384c:	3124      	adds	r1, #36	; 0x24
    384e:	1861      	adds	r1, r4, r1
    3850:	002a      	movs	r2, r5
    3852:	0030      	movs	r0, r6
    3854:	4b2b      	ldr	r3, [pc, #172]	; (3904 <f_read+0x19c>)
    3856:	4798      	blx	r3
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
    3858:	1976      	adds	r6, r6, r5
    385a:	68a3      	ldr	r3, [r4, #8]
    385c:	195b      	adds	r3, r3, r5
    385e:	60a3      	str	r3, [r4, #8]
    3860:	464b      	mov	r3, r9
    3862:	681b      	ldr	r3, [r3, #0]
    3864:	195b      	adds	r3, r3, r5
    3866:	464a      	mov	r2, r9
    3868:	6013      	str	r3, [r2, #0]
    386a:	1b7f      	subs	r7, r7, r5
	for ( ;  btr;								/* Repeat until all data read */
    386c:	d098      	beq.n	37a0 <f_read+0x38>
		if ((fp->fptr % SS(fp->fs)) == 0) {		/* On the sector boundary? */
    386e:	68a3      	ldr	r3, [r4, #8]
    3870:	05da      	lsls	r2, r3, #23
    3872:	d1e2      	bne.n	383a <f_read+0xd2>
			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
    3874:	6820      	ldr	r0, [r4, #0]
    3876:	7882      	ldrb	r2, [r0, #2]
    3878:	3a01      	subs	r2, #1
    387a:	0a5d      	lsrs	r5, r3, #9
    387c:	4015      	ands	r5, r2
    387e:	b2ed      	uxtb	r5, r5
			if (!csect) {						/* On the cluster boundary? */
    3880:	2d00      	cmp	r5, #0
    3882:	d107      	bne.n	3894 <f_read+0x12c>
				if (fp->fptr == 0) {			/* On the top of the file? */
    3884:	2b00      	cmp	r3, #0
    3886:	d19c      	bne.n	37c2 <f_read+0x5a>
					clst = fp->sclust;			/* Follow from the origin */
    3888:	6920      	ldr	r0, [r4, #16]
				if (clst < 2) ABORT(fp->fs, FR_INT_ERR);
    388a:	2801      	cmp	r0, #1
    388c:	d99d      	bls.n	37ca <f_read+0x62>
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
    388e:	1c43      	adds	r3, r0, #1
    3890:	d09f      	beq.n	37d2 <f_read+0x6a>
				fp->clust = clst;				/* Update current cluster */
    3892:	6160      	str	r0, [r4, #20]
			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
    3894:	6823      	ldr	r3, [r4, #0]
    3896:	469a      	mov	sl, r3
    3898:	6961      	ldr	r1, [r4, #20]
    389a:	0018      	movs	r0, r3
    389c:	4b1c      	ldr	r3, [pc, #112]	; (3910 <f_read+0x1a8>)
    389e:	4798      	blx	r3
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
    38a0:	2800      	cmp	r0, #0
    38a2:	d09a      	beq.n	37da <f_read+0x72>
			sect += csect;
    38a4:	4683      	mov	fp, r0
    38a6:	44ab      	add	fp, r5
			cc = btr / SS(fp->fs);				/* When remaining bytes >= sector size, */
    38a8:	0a7b      	lsrs	r3, r7, #9
    38aa:	4698      	mov	r8, r3
			if (cc) {							/* Read maximum contiguous sectors directly */
    38ac:	d0a6      	beq.n	37fc <f_read+0x94>
				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
    38ae:	4653      	mov	r3, sl
    38b0:	789b      	ldrb	r3, [r3, #2]
    38b2:	4642      	mov	r2, r8
    38b4:	18aa      	adds	r2, r5, r2
    38b6:	429a      	cmp	r2, r3
    38b8:	d901      	bls.n	38be <f_read+0x156>
					cc = fp->fs->csize - csect;
    38ba:	1b5b      	subs	r3, r3, r5
    38bc:	4698      	mov	r8, r3
				if (disk_read(fp->fs->drv, rbuff, sect, cc) != RES_OK)
    38be:	4653      	mov	r3, sl
    38c0:	7858      	ldrb	r0, [r3, #1]
    38c2:	4643      	mov	r3, r8
    38c4:	465a      	mov	r2, fp
    38c6:	0031      	movs	r1, r6
    38c8:	4d10      	ldr	r5, [pc, #64]	; (390c <f_read+0x1a4>)
    38ca:	47a8      	blx	r5
    38cc:	2800      	cmp	r0, #0
    38ce:	d188      	bne.n	37e2 <f_read+0x7a>
				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)
    38d0:	79a3      	ldrb	r3, [r4, #6]
    38d2:	065b      	lsls	r3, r3, #25
    38d4:	d504      	bpl.n	38e0 <f_read+0x178>
    38d6:	69a3      	ldr	r3, [r4, #24]
    38d8:	465a      	mov	r2, fp
    38da:	1a98      	subs	r0, r3, r2
    38dc:	4580      	cmp	r8, r0
    38de:	d884      	bhi.n	37ea <f_read+0x82>
				rcnt = SS(fp->fs) * cc;			/* Number of bytes transferred */
    38e0:	4643      	mov	r3, r8
    38e2:	025d      	lsls	r5, r3, #9
				continue;
    38e4:	e7b8      	b.n	3858 <f_read+0xf0>
						ABORT(fp->fs, FR_DISK_ERR);
    38e6:	2301      	movs	r3, #1
    38e8:	71e3      	strb	r3, [r4, #7]
    38ea:	9301      	str	r3, [sp, #4]
    38ec:	e758      	b.n	37a0 <f_read+0x38>
					ABORT(fp->fs, FR_DISK_ERR);
    38ee:	2301      	movs	r3, #1
    38f0:	71e3      	strb	r3, [r4, #7]
    38f2:	9301      	str	r3, [sp, #4]
    38f4:	e754      	b.n	37a0 <f_read+0x38>
		LEAVE_FF(fp->fs, (FRESULT)fp->err);
    38f6:	9301      	str	r3, [sp, #4]
    38f8:	e752      	b.n	37a0 <f_read+0x38>
    38fa:	46c0      	nop			; (mov r8, r8)
    38fc:	000027c1 	.word	0x000027c1
    3900:	00002ce5 	.word	0x00002ce5
    3904:	000025e9 	.word	0x000025e9
    3908:	00002565 	.word	0x00002565
    390c:	0000253d 	.word	0x0000253d
    3910:	00002ccd 	.word	0x00002ccd

00003914 <f_write>:
	FIL* fp,			/* Pointer to the file object */
	const void *buff,	/* Pointer to the data to be written */
	UINT btw,			/* Number of bytes to write */
	UINT* bw			/* Pointer to number of bytes written */
)
{
    3914:	b5f0      	push	{r4, r5, r6, r7, lr}
    3916:	46de      	mov	lr, fp
    3918:	4657      	mov	r7, sl
    391a:	464e      	mov	r6, r9
    391c:	4645      	mov	r5, r8
    391e:	b5e0      	push	{r5, r6, r7, lr}
    3920:	b083      	sub	sp, #12
    3922:	0004      	movs	r4, r0
    3924:	000d      	movs	r5, r1
    3926:	0017      	movs	r7, r2
    3928:	4699      	mov	r9, r3
	UINT wcnt, cc;
	const BYTE *wbuff = (const BYTE*)buff;
	BYTE csect;


	*bw = 0;	/* Clear write byte counter */
    392a:	2300      	movs	r3, #0
    392c:	464a      	mov	r2, r9
    392e:	6013      	str	r3, [r2, #0]

	res = validate(fp);						/* Check validity */
    3930:	4b6f      	ldr	r3, [pc, #444]	; (3af0 <f_write+0x1dc>)
    3932:	4798      	blx	r3
    3934:	9001      	str	r0, [sp, #4]
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
    3936:	2800      	cmp	r0, #0
    3938:	d108      	bne.n	394c <f_write+0x38>
	if (fp->err)							/* Check error */
    393a:	79e3      	ldrb	r3, [r4, #7]
    393c:	2b00      	cmp	r3, #0
    393e:	d000      	beq.n	3942 <f_write+0x2e>
    3940:	e0d3      	b.n	3aea <f_write+0x1d6>
		LEAVE_FF(fp->fs, (FRESULT)fp->err);
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
    3942:	79a3      	ldrb	r3, [r4, #6]
    3944:	079b      	lsls	r3, r3, #30
    3946:	d409      	bmi.n	395c <f_write+0x48>
		LEAVE_FF(fp->fs, FR_DENIED);
    3948:	2307      	movs	r3, #7
    394a:	9301      	str	r3, [sp, #4]

	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
	fp->flag |= FA__WRITTEN;						/* Set file change flag */

	LEAVE_FF(fp->fs, FR_OK);
}
    394c:	9801      	ldr	r0, [sp, #4]
    394e:	b003      	add	sp, #12
    3950:	bc3c      	pop	{r2, r3, r4, r5}
    3952:	4690      	mov	r8, r2
    3954:	4699      	mov	r9, r3
    3956:	46a2      	mov	sl, r4
    3958:	46ab      	mov	fp, r5
    395a:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (fp->fptr + btw < fp->fptr) btw = 0;	/* File size cannot reach 4GB */
    395c:	68a3      	ldr	r3, [r4, #8]
    395e:	19da      	adds	r2, r3, r7
    3960:	4293      	cmp	r3, r2
    3962:	d80e      	bhi.n	3982 <f_write+0x6e>
	for ( ;  btw;							/* Repeat until all data written */
    3964:	2f00      	cmp	r7, #0
    3966:	d00c      	beq.n	3982 <f_write+0x6e>
					disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)
    3968:	002e      	movs	r6, r5
    396a:	e06b      	b.n	3a44 <f_write+0x130>
						clst = create_chain(fp->fs, 0);	/* Create a new cluster chain */
    396c:	2100      	movs	r1, #0
    396e:	4b61      	ldr	r3, [pc, #388]	; (3af4 <f_write+0x1e0>)
    3970:	4798      	blx	r3
    3972:	0003      	movs	r3, r0
    3974:	e003      	b.n	397e <f_write+0x6a>
						clst = create_chain(fp->fs, fp->clust);	/* Follow or stretch cluster chain on the FAT */
    3976:	6961      	ldr	r1, [r4, #20]
    3978:	4b5e      	ldr	r3, [pc, #376]	; (3af4 <f_write+0x1e0>)
    397a:	4798      	blx	r3
    397c:	0003      	movs	r3, r0
				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
    397e:	2b00      	cmp	r3, #0
    3980:	d171      	bne.n	3a66 <f_write+0x152>
	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
    3982:	68a3      	ldr	r3, [r4, #8]
    3984:	68e2      	ldr	r2, [r4, #12]
    3986:	4293      	cmp	r3, r2
    3988:	d900      	bls.n	398c <f_write+0x78>
    398a:	60e3      	str	r3, [r4, #12]
	fp->flag |= FA__WRITTEN;						/* Set file change flag */
    398c:	79a3      	ldrb	r3, [r4, #6]
    398e:	2220      	movs	r2, #32
    3990:	4313      	orrs	r3, r2
    3992:	71a3      	strb	r3, [r4, #6]
	LEAVE_FF(fp->fs, FR_OK);
    3994:	e7da      	b.n	394c <f_write+0x38>
				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
    3996:	3301      	adds	r3, #1
    3998:	71e3      	strb	r3, [r4, #7]
    399a:	9301      	str	r3, [sp, #4]
    399c:	e7d6      	b.n	394c <f_write+0x38>
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
    399e:	3302      	adds	r3, #2
    39a0:	71e3      	strb	r3, [r4, #7]
    39a2:	9301      	str	r3, [sp, #4]
    39a4:	e7d2      	b.n	394c <f_write+0x38>
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
    39a6:	0021      	movs	r1, r4
    39a8:	3124      	adds	r1, #36	; 0x24
    39aa:	6823      	ldr	r3, [r4, #0]
    39ac:	7858      	ldrb	r0, [r3, #1]
    39ae:	2301      	movs	r3, #1
    39b0:	69a2      	ldr	r2, [r4, #24]
    39b2:	4d51      	ldr	r5, [pc, #324]	; (3af8 <f_write+0x1e4>)
    39b4:	47a8      	blx	r5
    39b6:	2800      	cmp	r0, #0
    39b8:	d104      	bne.n	39c4 <f_write+0xb0>
				fp->flag &= ~FA__DIRTY;
    39ba:	79a3      	ldrb	r3, [r4, #6]
    39bc:	2240      	movs	r2, #64	; 0x40
    39be:	4393      	bics	r3, r2
    39c0:	71a3      	strb	r3, [r4, #6]
    39c2:	e05c      	b.n	3a7e <f_write+0x16a>
					ABORT(fp->fs, FR_DISK_ERR);
    39c4:	2301      	movs	r3, #1
    39c6:	71e3      	strb	r3, [r4, #7]
    39c8:	9301      	str	r3, [sp, #4]
    39ca:	e7bf      	b.n	394c <f_write+0x38>
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
    39cc:	2302      	movs	r3, #2
    39ce:	71e3      	strb	r3, [r4, #7]
    39d0:	9301      	str	r3, [sp, #4]
    39d2:	e7bb      	b.n	394c <f_write+0x38>
					ABORT(fp->fs, FR_DISK_ERR);
    39d4:	2301      	movs	r3, #1
    39d6:	71e3      	strb	r3, [r4, #7]
    39d8:	9301      	str	r3, [sp, #4]
    39da:	e7b7      	b.n	394c <f_write+0x38>
					mem_cpy(fp->buf, wbuff + ((fp->dsect - sect) * SS(fp->fs)), SS(fp->fs));
    39dc:	0240      	lsls	r0, r0, #9
    39de:	1831      	adds	r1, r6, r0
    39e0:	0020      	movs	r0, r4
    39e2:	3024      	adds	r0, #36	; 0x24
    39e4:	2280      	movs	r2, #128	; 0x80
    39e6:	0092      	lsls	r2, r2, #2
    39e8:	4b44      	ldr	r3, [pc, #272]	; (3afc <f_write+0x1e8>)
    39ea:	4798      	blx	r3
					fp->flag &= ~FA__DIRTY;
    39ec:	79a3      	ldrb	r3, [r4, #6]
    39ee:	2240      	movs	r2, #64	; 0x40
    39f0:	4393      	bics	r3, r2
    39f2:	71a3      	strb	r3, [r4, #6]
    39f4:	e068      	b.n	3ac8 <f_write+0x1b4>
			if (fp->dsect != sect) {		/* Fill sector cache with file data */
    39f6:	69a3      	ldr	r3, [r4, #24]
    39f8:	4598      	cmp	r8, r3
    39fa:	d003      	beq.n	3a04 <f_write+0xf0>
				if (fp->fptr < fp->fsize &&
    39fc:	68a3      	ldr	r3, [r4, #8]
    39fe:	68e2      	ldr	r2, [r4, #12]
    3a00:	4293      	cmp	r3, r2
    3a02:	d364      	bcc.n	3ace <f_write+0x1ba>
			fp->dsect = sect;
    3a04:	4643      	mov	r3, r8
    3a06:	61a3      	str	r3, [r4, #24]
		wcnt = SS(fp->fs) - ((UINT)fp->fptr % SS(fp->fs));/* Put partial sector into file I/O buffer */
    3a08:	68a3      	ldr	r3, [r4, #8]
    3a0a:	05d8      	lsls	r0, r3, #23
    3a0c:	0dc0      	lsrs	r0, r0, #23
    3a0e:	2580      	movs	r5, #128	; 0x80
    3a10:	00ad      	lsls	r5, r5, #2
    3a12:	1a2d      	subs	r5, r5, r0
    3a14:	42bd      	cmp	r5, r7
    3a16:	d900      	bls.n	3a1a <f_write+0x106>
    3a18:	003d      	movs	r5, r7
		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
    3a1a:	3024      	adds	r0, #36	; 0x24
    3a1c:	1820      	adds	r0, r4, r0
    3a1e:	002a      	movs	r2, r5
    3a20:	0031      	movs	r1, r6
    3a22:	4b36      	ldr	r3, [pc, #216]	; (3afc <f_write+0x1e8>)
    3a24:	4798      	blx	r3
		fp->flag |= FA__DIRTY;
    3a26:	79a3      	ldrb	r3, [r4, #6]
    3a28:	2240      	movs	r2, #64	; 0x40
    3a2a:	4313      	orrs	r3, r2
    3a2c:	71a3      	strb	r3, [r4, #6]
		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
    3a2e:	1976      	adds	r6, r6, r5
    3a30:	68a3      	ldr	r3, [r4, #8]
    3a32:	195b      	adds	r3, r3, r5
    3a34:	60a3      	str	r3, [r4, #8]
    3a36:	464b      	mov	r3, r9
    3a38:	681b      	ldr	r3, [r3, #0]
    3a3a:	195b      	adds	r3, r3, r5
    3a3c:	464a      	mov	r2, r9
    3a3e:	6013      	str	r3, [r2, #0]
    3a40:	1b7f      	subs	r7, r7, r5
	for ( ;  btw;							/* Repeat until all data written */
    3a42:	d09e      	beq.n	3982 <f_write+0x6e>
		if ((fp->fptr % SS(fp->fs)) == 0) {	/* On the sector boundary? */
    3a44:	68a3      	ldr	r3, [r4, #8]
    3a46:	05da      	lsls	r2, r3, #23
    3a48:	d1de      	bne.n	3a08 <f_write+0xf4>
			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
    3a4a:	6820      	ldr	r0, [r4, #0]
    3a4c:	7882      	ldrb	r2, [r0, #2]
    3a4e:	3a01      	subs	r2, #1
    3a50:	0a5d      	lsrs	r5, r3, #9
    3a52:	4015      	ands	r5, r2
    3a54:	b2ea      	uxtb	r2, r5
    3a56:	4693      	mov	fp, r2
			if (!csect) {					/* On the cluster boundary? */
    3a58:	2a00      	cmp	r2, #0
    3a5a:	d10d      	bne.n	3a78 <f_write+0x164>
				if (fp->fptr == 0) {		/* On the top of the file? */
    3a5c:	2b00      	cmp	r3, #0
    3a5e:	d18a      	bne.n	3976 <f_write+0x62>
					clst = fp->sclust;		/* Follow from the origin */
    3a60:	6923      	ldr	r3, [r4, #16]
					if (clst == 0)			/* When no cluster is allocated, */
    3a62:	2b00      	cmp	r3, #0
    3a64:	d082      	beq.n	396c <f_write+0x58>
				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
    3a66:	2b01      	cmp	r3, #1
    3a68:	d095      	beq.n	3996 <f_write+0x82>
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
    3a6a:	1c5a      	adds	r2, r3, #1
    3a6c:	d097      	beq.n	399e <f_write+0x8a>
				fp->clust = clst;			/* Update current cluster */
    3a6e:	6163      	str	r3, [r4, #20]
				if (fp->sclust == 0) fp->sclust = clst;	/* Set start cluster if the first write */
    3a70:	6922      	ldr	r2, [r4, #16]
    3a72:	2a00      	cmp	r2, #0
    3a74:	d100      	bne.n	3a78 <f_write+0x164>
    3a76:	6123      	str	r3, [r4, #16]
			if (fp->flag & FA__DIRTY) {		/* Write-back sector cache */
    3a78:	79a3      	ldrb	r3, [r4, #6]
    3a7a:	065b      	lsls	r3, r3, #25
    3a7c:	d493      	bmi.n	39a6 <f_write+0x92>
			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
    3a7e:	6823      	ldr	r3, [r4, #0]
    3a80:	469a      	mov	sl, r3
    3a82:	6961      	ldr	r1, [r4, #20]
    3a84:	0018      	movs	r0, r3
    3a86:	4b1e      	ldr	r3, [pc, #120]	; (3b00 <f_write+0x1ec>)
    3a88:	4798      	blx	r3
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
    3a8a:	2800      	cmp	r0, #0
    3a8c:	d09e      	beq.n	39cc <f_write+0xb8>
			sect += csect;
    3a8e:	4680      	mov	r8, r0
    3a90:	4658      	mov	r0, fp
    3a92:	4684      	mov	ip, r0
    3a94:	44d8      	add	r8, fp
			cc = btw / SS(fp->fs);			/* When remaining bytes >= sector size, */
    3a96:	0a7b      	lsrs	r3, r7, #9
    3a98:	469b      	mov	fp, r3
			if (cc) {						/* Write maximum contiguous sectors directly */
    3a9a:	d0ac      	beq.n	39f6 <f_write+0xe2>
				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
    3a9c:	4653      	mov	r3, sl
    3a9e:	789b      	ldrb	r3, [r3, #2]
    3aa0:	465a      	mov	r2, fp
    3aa2:	4462      	add	r2, ip
    3aa4:	429a      	cmp	r2, r3
    3aa6:	d901      	bls.n	3aac <f_write+0x198>
					cc = fp->fs->csize - csect;
    3aa8:	1a1b      	subs	r3, r3, r0
    3aaa:	469b      	mov	fp, r3
				if (disk_write(fp->fs->drv, wbuff, sect, cc) != RES_OK)
    3aac:	4653      	mov	r3, sl
    3aae:	7858      	ldrb	r0, [r3, #1]
    3ab0:	465b      	mov	r3, fp
    3ab2:	4642      	mov	r2, r8
    3ab4:	0031      	movs	r1, r6
    3ab6:	4d10      	ldr	r5, [pc, #64]	; (3af8 <f_write+0x1e4>)
    3ab8:	47a8      	blx	r5
    3aba:	2800      	cmp	r0, #0
    3abc:	d18a      	bne.n	39d4 <f_write+0xc0>
				if (fp->dsect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
    3abe:	69a3      	ldr	r3, [r4, #24]
    3ac0:	4642      	mov	r2, r8
    3ac2:	1a98      	subs	r0, r3, r2
    3ac4:	4583      	cmp	fp, r0
    3ac6:	d889      	bhi.n	39dc <f_write+0xc8>
				wcnt = SS(fp->fs) * cc;		/* Number of bytes transferred */
    3ac8:	465b      	mov	r3, fp
    3aca:	025d      	lsls	r5, r3, #9
				continue;
    3acc:	e7af      	b.n	3a2e <f_write+0x11a>
					disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)
    3ace:	0021      	movs	r1, r4
    3ad0:	3124      	adds	r1, #36	; 0x24
    3ad2:	4653      	mov	r3, sl
    3ad4:	7858      	ldrb	r0, [r3, #1]
    3ad6:	2301      	movs	r3, #1
    3ad8:	4642      	mov	r2, r8
    3ada:	4d0a      	ldr	r5, [pc, #40]	; (3b04 <f_write+0x1f0>)
    3adc:	47a8      	blx	r5
				if (fp->fptr < fp->fsize &&
    3ade:	2800      	cmp	r0, #0
    3ae0:	d090      	beq.n	3a04 <f_write+0xf0>
						ABORT(fp->fs, FR_DISK_ERR);
    3ae2:	2001      	movs	r0, #1
    3ae4:	71e0      	strb	r0, [r4, #7]
    3ae6:	9001      	str	r0, [sp, #4]
    3ae8:	e730      	b.n	394c <f_write+0x38>
		LEAVE_FF(fp->fs, (FRESULT)fp->err);
    3aea:	9301      	str	r3, [sp, #4]
    3aec:	e72e      	b.n	394c <f_write+0x38>
    3aee:	46c0      	nop			; (mov r8, r8)
    3af0:	000027c1 	.word	0x000027c1
    3af4:	00002fd9 	.word	0x00002fd9
    3af8:	00002565 	.word	0x00002565
    3afc:	000025e9 	.word	0x000025e9
    3b00:	00002ccd 	.word	0x00002ccd
    3b04:	0000253d 	.word	0x0000253d

00003b08 <f_sync>:
/*-----------------------------------------------------------------------*/

FRESULT f_sync (
	FIL* fp		/* Pointer to the file object */
)
{
    3b08:	b570      	push	{r4, r5, r6, lr}
    3b0a:	0004      	movs	r4, r0
	FRESULT res;
	DWORD tm;
	BYTE *dir;


	res = validate(fp);					/* Check validity of the object */
    3b0c:	4b26      	ldr	r3, [pc, #152]	; (3ba8 <f_sync+0xa0>)
    3b0e:	4798      	blx	r3
	if (res == FR_OK) {
    3b10:	2800      	cmp	r0, #0
    3b12:	d11a      	bne.n	3b4a <f_sync+0x42>
		if (fp->flag & FA__WRITTEN) {	/* Has the file been written? */
    3b14:	79a3      	ldrb	r3, [r4, #6]
    3b16:	069a      	lsls	r2, r3, #26
    3b18:	d517      	bpl.n	3b4a <f_sync+0x42>
			/* Write-back dirty buffer */
#if !_FS_TINY
			if (fp->flag & FA__DIRTY) {
    3b1a:	065b      	lsls	r3, r3, #25
    3b1c:	d50f      	bpl.n	3b3e <f_sync+0x36>
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
    3b1e:	0021      	movs	r1, r4
    3b20:	3124      	adds	r1, #36	; 0x24
    3b22:	6823      	ldr	r3, [r4, #0]
    3b24:	7858      	ldrb	r0, [r3, #1]
    3b26:	2301      	movs	r3, #1
    3b28:	69a2      	ldr	r2, [r4, #24]
    3b2a:	4d20      	ldr	r5, [pc, #128]	; (3bac <f_sync+0xa4>)
    3b2c:	47a8      	blx	r5
    3b2e:	0003      	movs	r3, r0
					LEAVE_FF(fp->fs, FR_DISK_ERR);
    3b30:	2001      	movs	r0, #1
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
    3b32:	2b00      	cmp	r3, #0
    3b34:	d109      	bne.n	3b4a <f_sync+0x42>
				fp->flag &= ~FA__DIRTY;
    3b36:	79a3      	ldrb	r3, [r4, #6]
    3b38:	2240      	movs	r2, #64	; 0x40
    3b3a:	4393      	bics	r3, r2
    3b3c:	71a3      	strb	r3, [r4, #6]
			}
#endif
			/* Update the directory entry */
			res = move_window(fp->fs, fp->dir_sect);
    3b3e:	69e1      	ldr	r1, [r4, #28]
    3b40:	6820      	ldr	r0, [r4, #0]
    3b42:	4b1b      	ldr	r3, [pc, #108]	; (3bb0 <f_sync+0xa8>)
    3b44:	4798      	blx	r3
			if (res == FR_OK) {
    3b46:	2800      	cmp	r0, #0
    3b48:	d000      	beq.n	3b4c <f_sync+0x44>
			}
		}
	}

	LEAVE_FF(fp->fs, res);
}
    3b4a:	bd70      	pop	{r4, r5, r6, pc}
				dir = fp->dir_ptr;
    3b4c:	6a25      	ldr	r5, [r4, #32]
				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
    3b4e:	7aeb      	ldrb	r3, [r5, #11]
    3b50:	2220      	movs	r2, #32
    3b52:	4313      	orrs	r3, r2
    3b54:	72eb      	strb	r3, [r5, #11]
				ST_DWORD(dir + DIR_FileSize, fp->fsize);	/* Update file size */
    3b56:	7b23      	ldrb	r3, [r4, #12]
    3b58:	772b      	strb	r3, [r5, #28]
    3b5a:	89a3      	ldrh	r3, [r4, #12]
    3b5c:	0a1b      	lsrs	r3, r3, #8
    3b5e:	776b      	strb	r3, [r5, #29]
    3b60:	89e3      	ldrh	r3, [r4, #14]
    3b62:	77ab      	strb	r3, [r5, #30]
    3b64:	7be3      	ldrb	r3, [r4, #15]
    3b66:	77eb      	strb	r3, [r5, #31]
				st_clust(dir, fp->sclust);					/* Update start cluster */
    3b68:	6923      	ldr	r3, [r4, #16]
	ST_WORD(dir + DIR_FstClusLO, cl);
    3b6a:	76ab      	strb	r3, [r5, #26]
    3b6c:	0a1a      	lsrs	r2, r3, #8
    3b6e:	76ea      	strb	r2, [r5, #27]
	ST_WORD(dir + DIR_FstClusHI, cl >> 16);
    3b70:	0c1b      	lsrs	r3, r3, #16
    3b72:	752b      	strb	r3, [r5, #20]
    3b74:	0a1b      	lsrs	r3, r3, #8
    3b76:	756b      	strb	r3, [r5, #21]
				tm = GET_FATTIME();							/* Update updated time */
    3b78:	4b0e      	ldr	r3, [pc, #56]	; (3bb4 <f_sync+0xac>)
    3b7a:	4798      	blx	r3
				ST_DWORD(dir + DIR_WrtTime, tm);
    3b7c:	75a8      	strb	r0, [r5, #22]
    3b7e:	0a03      	lsrs	r3, r0, #8
    3b80:	75eb      	strb	r3, [r5, #23]
    3b82:	0c03      	lsrs	r3, r0, #16
    3b84:	762b      	strb	r3, [r5, #24]
    3b86:	0e00      	lsrs	r0, r0, #24
    3b88:	7668      	strb	r0, [r5, #25]
				ST_WORD(dir + DIR_LstAccDate, 0);
    3b8a:	2300      	movs	r3, #0
    3b8c:	74ab      	strb	r3, [r5, #18]
    3b8e:	74eb      	strb	r3, [r5, #19]
				fp->flag &= ~FA__WRITTEN;
    3b90:	79a3      	ldrb	r3, [r4, #6]
    3b92:	2220      	movs	r2, #32
    3b94:	4393      	bics	r3, r2
    3b96:	71a3      	strb	r3, [r4, #6]
				fp->fs->wflag = 1;
    3b98:	2301      	movs	r3, #1
    3b9a:	6822      	ldr	r2, [r4, #0]
    3b9c:	7113      	strb	r3, [r2, #4]
				res = sync_fs(fp->fs);
    3b9e:	6820      	ldr	r0, [r4, #0]
    3ba0:	4b05      	ldr	r3, [pc, #20]	; (3bb8 <f_sync+0xb0>)
    3ba2:	4798      	blx	r3
    3ba4:	e7d1      	b.n	3b4a <f_sync+0x42>
    3ba6:	46c0      	nop			; (mov r8, r8)
    3ba8:	000027c1 	.word	0x000027c1
    3bac:	00002565 	.word	0x00002565
    3bb0:	000026e1 	.word	0x000026e1
    3bb4:	000025e5 	.word	0x000025e5
    3bb8:	00002bd9 	.word	0x00002bd9

00003bbc <f_close>:
/*-----------------------------------------------------------------------*/

FRESULT f_close (
	FIL *fp		/* Pointer to the file object to be closed */
)
{
    3bbc:	b510      	push	{r4, lr}
    3bbe:	0004      	movs	r4, r0
	FRESULT res;


#if !_FS_READONLY
	res = f_sync(fp);					/* Flush cached data */
    3bc0:	4b06      	ldr	r3, [pc, #24]	; (3bdc <f_close+0x20>)
    3bc2:	4798      	blx	r3
	if (res == FR_OK)
    3bc4:	2800      	cmp	r0, #0
    3bc6:	d000      	beq.n	3bca <f_close+0xe>
			unlock_fs(fs, FR_OK);		/* Unlock volume */
#endif
		}
	}
	return res;
}
    3bc8:	bd10      	pop	{r4, pc}
		res = validate(fp);				/* Lock volume */
    3bca:	0020      	movs	r0, r4
    3bcc:	4b04      	ldr	r3, [pc, #16]	; (3be0 <f_close+0x24>)
    3bce:	4798      	blx	r3
		if (res == FR_OK) {
    3bd0:	2800      	cmp	r0, #0
    3bd2:	d1f9      	bne.n	3bc8 <f_close+0xc>
				fp->fs = 0;				/* Invalidate file object */
    3bd4:	2300      	movs	r3, #0
    3bd6:	6023      	str	r3, [r4, #0]
    3bd8:	e7f6      	b.n	3bc8 <f_close+0xc>
    3bda:	46c0      	nop			; (mov r8, r8)
    3bdc:	00003b09 	.word	0x00003b09
    3be0:	000027c1 	.word	0x000027c1

00003be4 <f_gets>:
TCHAR* f_gets (
	TCHAR* buff,	/* Pointer to the string buffer to read */
	int len,		/* Size of string buffer (characters) */
	FIL* fp			/* Pointer to the file object */
)
{
    3be4:	b5f0      	push	{r4, r5, r6, r7, lr}
    3be6:	b085      	sub	sp, #20
    3be8:	9001      	str	r0, [sp, #4]
    3bea:	9200      	str	r2, [sp, #0]
	int n = 0;
	TCHAR c, *p = buff;
    3bec:	0007      	movs	r7, r0
	int n = 0;
    3bee:	2400      	movs	r4, #0
	BYTE s[2];
	UINT rc;


	while (n < len - 1) {	/* Read characters until buffer gets filled */
    3bf0:	1e4d      	subs	r5, r1, #1
		}
		c = ff_convert(c, 1);	/* OEM -> Unicode */
		if (!c) c = '?';
#endif
#else						/* Read a character without conversion */
		f_read(fp, s, 1, &rc);
    3bf2:	4e10      	ldr	r6, [pc, #64]	; (3c34 <f_gets+0x50>)
	while (n < len - 1) {	/* Read characters until buffer gets filled */
    3bf4:	42ac      	cmp	r4, r5
    3bf6:	da13      	bge.n	3c20 <f_gets+0x3c>
		f_read(fp, s, 1, &rc);
    3bf8:	ab02      	add	r3, sp, #8
    3bfa:	2201      	movs	r2, #1
    3bfc:	a903      	add	r1, sp, #12
    3bfe:	9800      	ldr	r0, [sp, #0]
    3c00:	47b0      	blx	r6
		if (rc != 1) break;
    3c02:	9b02      	ldr	r3, [sp, #8]
    3c04:	2b01      	cmp	r3, #1
    3c06:	d10b      	bne.n	3c20 <f_gets+0x3c>
		c = s[0];
    3c08:	ab03      	add	r3, sp, #12
    3c0a:	781b      	ldrb	r3, [r3, #0]
#endif
		if (_USE_STRFUNC == 2 && c == '\r') continue;	/* Strip '\r' */
    3c0c:	2b0d      	cmp	r3, #13
    3c0e:	d0f1      	beq.n	3bf4 <f_gets+0x10>
		*p++ = c;
    3c10:	1c7a      	adds	r2, r7, #1
    3c12:	703b      	strb	r3, [r7, #0]
		n++;
    3c14:	3401      	adds	r4, #1
		if (c == '\n') break;		/* Break on EOL */
    3c16:	2b0a      	cmp	r3, #10
    3c18:	d001      	beq.n	3c1e <f_gets+0x3a>
		*p++ = c;
    3c1a:	0017      	movs	r7, r2
    3c1c:	e7ea      	b.n	3bf4 <f_gets+0x10>
    3c1e:	0017      	movs	r7, r2
	}
	*p = 0;
    3c20:	2300      	movs	r3, #0
    3c22:	703b      	strb	r3, [r7, #0]
	return n ? buff : 0;			/* When no data read (eof or error), return with error. */
    3c24:	1e63      	subs	r3, r4, #1
    3c26:	419c      	sbcs	r4, r3
    3c28:	4264      	negs	r4, r4
    3c2a:	9b01      	ldr	r3, [sp, #4]
    3c2c:	4023      	ands	r3, r4
}
    3c2e:	0018      	movs	r0, r3
    3c30:	b005      	add	sp, #20
    3c32:	bdf0      	pop	{r4, r5, r6, r7, pc}
    3c34:	00003769 	.word	0x00003769

00003c38 <main>:
 *
 * Note:
 *
 ******************************************************************************/
int main(void)
{
    3c38:	b510      	push	{r4, lr}
	// CMSIS compliant function not used
	//SystemInit();
	
	// Application hardware and software initialization 
	AppInit();
    3c3a:	4b02      	ldr	r3, [pc, #8]	; (3c44 <main+0xc>)
    3c3c:	4798      	blx	r3

	// Super loop
	while(1)
	{
		// Run your application
		AppRun();
    3c3e:	4c02      	ldr	r4, [pc, #8]	; (3c48 <main+0x10>)
    3c40:	47a0      	blx	r4
    3c42:	e7fd      	b.n	3c40 <main+0x8>
    3c44:	00002115 	.word	0x00002115
    3c48:	00002135 	.word	0x00002135

00003c4c <SDCard_SS>:
void SDCard_RunSpeed(void) {
    SPI_Initialize_Fast();
}

// Control the Slave Select line
void SDCard_SS(uint8_t cs) {
    3c4c:	b570      	push	{r4, r5, r6, lr}
    if (cs == 1) {
    3c4e:	2801      	cmp	r0, #1
    3c50:	d004      	beq.n	3c5c <SDCard_SS+0x10>
        SPI_CS_HIGH();
		for (uint8_t i = 0; i < 10; i++) {
			SPI_SD_Send_Byte(0xFF);  // Send dummy bytes
		}
    } else {
        SPI_CS_LOW();
    3c52:	2280      	movs	r2, #128	; 0x80
    3c54:	01d2      	lsls	r2, r2, #7
    3c56:	4b08      	ldr	r3, [pc, #32]	; (3c78 <SDCard_SS+0x2c>)
    3c58:	609a      	str	r2, [r3, #8]
    }
}
    3c5a:	bd70      	pop	{r4, r5, r6, pc}
        SPI_CS_HIGH();
    3c5c:	2280      	movs	r2, #128	; 0x80
    3c5e:	01d2      	lsls	r2, r2, #7
    3c60:	4b05      	ldr	r3, [pc, #20]	; (3c78 <SDCard_SS+0x2c>)
    3c62:	619a      	str	r2, [r3, #24]
    3c64:	240a      	movs	r4, #10
			SPI_SD_Send_Byte(0xFF);  // Send dummy bytes
    3c66:	4d05      	ldr	r5, [pc, #20]	; (3c7c <SDCard_SS+0x30>)
    3c68:	20ff      	movs	r0, #255	; 0xff
    3c6a:	47a8      	blx	r5
    3c6c:	3c01      	subs	r4, #1
    3c6e:	b2e4      	uxtb	r4, r4
		for (uint8_t i = 0; i < 10; i++) {
    3c70:	2c00      	cmp	r4, #0
    3c72:	d1f9      	bne.n	3c68 <SDCard_SS+0x1c>
    3c74:	e7f1      	b.n	3c5a <SDCard_SS+0xe>
    3c76:	46c0      	nop			; (mov r8, r8)
    3c78:	41004400 	.word	0x41004400
    3c7c:	00004029 	.word	0x00004029

00003c80 <SDCard_WriteCmd>:

    return 0; // Ready
}

// Write a command to the SD card
uint8_t SDCard_WriteCmd(uint8_t cmd, uint32_t arg, uint8_t crc) {
    3c80:	b5f0      	push	{r4, r5, r6, r7, lr}
    3c82:	46c6      	mov	lr, r8
    3c84:	b500      	push	{lr}
    3c86:	b082      	sub	sp, #8
    3c88:	4680      	mov	r8, r0
    3c8a:	000f      	movs	r7, r1
    3c8c:	9201      	str	r2, [sp, #4]
    uint16_t timeout = 1024;
    3c8e:	2480      	movs	r4, #128	; 0x80
    3c90:	00e4      	lsls	r4, r4, #3
	uint8_t response;
	do {
		response = SPI_SD_Send_Byte(0xFF);
    3c92:	4e1e      	ldr	r6, [pc, #120]	; (3d0c <SDCard_WriteCmd+0x8c>)
    3c94:	20ff      	movs	r0, #255	; 0xff
    3c96:	47b0      	blx	r6
		timeout--;
    3c98:	3c01      	subs	r4, #1
    3c9a:	b2a4      	uxth	r4, r4
	} while ((response == 0xFF) && timeout);
    3c9c:	28ff      	cmp	r0, #255	; 0xff
    3c9e:	d101      	bne.n	3ca4 <SDCard_WriteCmd+0x24>
    3ca0:	2c00      	cmp	r4, #0
    3ca2:	d1f7      	bne.n	3c94 <SDCard_WriteCmd+0x14>
    

    SDCard_SS(1);
    3ca4:	2001      	movs	r0, #1
    3ca6:	4d1a      	ldr	r5, [pc, #104]	; (3d10 <SDCard_WriteCmd+0x90>)
    3ca8:	47a8      	blx	r5
    SPI_SD_Send_Byte(0xFF);
    3caa:	20ff      	movs	r0, #255	; 0xff
    3cac:	4e17      	ldr	r6, [pc, #92]	; (3d0c <SDCard_WriteCmd+0x8c>)
    3cae:	47b0      	blx	r6
    SDCard_SS(0);
    3cb0:	2000      	movs	r0, #0
    3cb2:	47a8      	blx	r5

    // Send command packet
    SPI_SD_Send_Byte(cmd | 0x40);
    3cb4:	2040      	movs	r0, #64	; 0x40
    3cb6:	4643      	mov	r3, r8
    3cb8:	4303      	orrs	r3, r0
    3cba:	0018      	movs	r0, r3
    3cbc:	47b0      	blx	r6
    SPI_SD_Send_Byte((uint8_t)(arg >> 24));
    3cbe:	0e38      	lsrs	r0, r7, #24
    3cc0:	47b0      	blx	r6
    SPI_SD_Send_Byte((uint8_t)(arg >> 16));
    3cc2:	0c38      	lsrs	r0, r7, #16
    3cc4:	b2c0      	uxtb	r0, r0
    3cc6:	47b0      	blx	r6
    SPI_SD_Send_Byte((uint8_t)(arg >> 8));
    3cc8:	0a38      	lsrs	r0, r7, #8
    3cca:	b2c0      	uxtb	r0, r0
    3ccc:	47b0      	blx	r6
    SPI_SD_Send_Byte((uint8_t)arg);
    3cce:	b2f8      	uxtb	r0, r7
    3cd0:	47b0      	blx	r6
    SPI_SD_Send_Byte(crc);
    3cd2:	9801      	ldr	r0, [sp, #4]
    3cd4:	47b0      	blx	r6

    // Wait for a response
    do {
        response = SPI_SD_Send_Byte(0xFF);
    3cd6:	4e0d      	ldr	r6, [pc, #52]	; (3d0c <SDCard_WriteCmd+0x8c>)
    3cd8:	20ff      	movs	r0, #255	; 0xff
    3cda:	47b0      	blx	r6
    3cdc:	0005      	movs	r5, r0
        timeout--;
    3cde:	3c01      	subs	r4, #1
    3ce0:	b2a4      	uxth	r4, r4
    } while ((response == 0xFF) && timeout);
    3ce2:	28ff      	cmp	r0, #255	; 0xff
    3ce4:	d105      	bne.n	3cf2 <SDCard_WriteCmd+0x72>
    3ce6:	2c00      	cmp	r4, #0
    3ce8:	d1f6      	bne.n	3cd8 <SDCard_WriteCmd+0x58>

    if (timeout == 0) {
        UART3_Write_Text("Command response timeout\n");
    3cea:	480a      	ldr	r0, [pc, #40]	; (3d14 <SDCard_WriteCmd+0x94>)
    3cec:	4b0a      	ldr	r3, [pc, #40]	; (3d18 <SDCard_WriteCmd+0x98>)
    3cee:	4798      	blx	r3
    3cf0:	e001      	b.n	3cf6 <SDCard_WriteCmd+0x76>
    if (timeout == 0) {
    3cf2:	2c00      	cmp	r4, #0
    3cf4:	d0f9      	beq.n	3cea <SDCard_WriteCmd+0x6a>
    }

    // Deselect and send one more byte to finalize
    SDCard_SS(1);
    3cf6:	2001      	movs	r0, #1
    3cf8:	4b05      	ldr	r3, [pc, #20]	; (3d10 <SDCard_WriteCmd+0x90>)
    3cfa:	4798      	blx	r3
    SPI_SD_Send_Byte(0xFF);
    3cfc:	20ff      	movs	r0, #255	; 0xff
    3cfe:	4b03      	ldr	r3, [pc, #12]	; (3d0c <SDCard_WriteCmd+0x8c>)
    3d00:	4798      	blx	r3

    return response; // Return response from SD card
}
    3d02:	0028      	movs	r0, r5
    3d04:	b002      	add	sp, #8
    3d06:	bc04      	pop	{r2}
    3d08:	4690      	mov	r8, r2
    3d0a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    3d0c:	00004029 	.word	0x00004029
    3d10:	00003c4d 	.word	0x00003c4d
    3d14:	00004928 	.word	0x00004928
    3d18:	00004105 	.word	0x00004105

00003d1c <SDCard_Init>:

// Initialize the SD card
uint8_t SDCard_Init(void) {
    3d1c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    SPI_Initialize_Slow();
    3d1e:	4b4e      	ldr	r3, [pc, #312]	; (3e58 <SDCard_Init+0x13c>)
    3d20:	4798      	blx	r3
    uint8_t response;
    uint16_t retry = 0;

    // Set to low speed for initialization
    SDCard_InitSpeed();
    delay_ms(100);
    3d22:	484e      	ldr	r0, [pc, #312]	; (3e5c <SDCard_Init+0x140>)
    3d24:	4b4e      	ldr	r3, [pc, #312]	; (3e60 <SDCard_Init+0x144>)
    3d26:	4798      	blx	r3
    3d28:	240a      	movs	r4, #10

    // Send initial 80 clock pulses
    for (uint8_t i = 0; i < 10; i++) {
        SPI_SD_Send_Byte(0xFF);
    3d2a:	4d4e      	ldr	r5, [pc, #312]	; (3e64 <SDCard_Init+0x148>)
    3d2c:	20ff      	movs	r0, #255	; 0xff
    3d2e:	47a8      	blx	r5
    3d30:	3c01      	subs	r4, #1
    3d32:	b2e4      	uxtb	r4, r4
    for (uint8_t i = 0; i < 10; i++) {
    3d34:	2c00      	cmp	r4, #0
    3d36:	d1f9      	bne.n	3d2c <SDCard_Init+0x10>
    }

    // Try to reset the SD card
    do {
		UART3_Write_Text("Sending CMD0...\n"); 
    3d38:	4d4b      	ldr	r5, [pc, #300]	; (3e68 <SDCard_Init+0x14c>)
        response = SDCard_WriteCmd(CMD0, 0x00, 0x95);
    3d3a:	4f4c      	ldr	r7, [pc, #304]	; (3e6c <SDCard_Init+0x150>)
		UART3_Write_Text("Sending CMD0...\n"); 
    3d3c:	484c      	ldr	r0, [pc, #304]	; (3e70 <SDCard_Init+0x154>)
    3d3e:	47a8      	blx	r5
        response = SDCard_WriteCmd(CMD0, 0x00, 0x95);
    3d40:	2295      	movs	r2, #149	; 0x95
    3d42:	2100      	movs	r1, #0
    3d44:	2040      	movs	r0, #64	; 0x40
    3d46:	47b8      	blx	r7
    3d48:	0006      	movs	r6, r0
		delay_ms(1);
    3d4a:	484a      	ldr	r0, [pc, #296]	; (3e74 <SDCard_Init+0x158>)
    3d4c:	4b44      	ldr	r3, [pc, #272]	; (3e60 <SDCard_Init+0x144>)
    3d4e:	4798      	blx	r3
		UART3_Write_Text(response == 1 ? "CMD0 success\n" : "CMD0 failed\n");
    3d50:	2e01      	cmp	r6, #1
    3d52:	d05b      	beq.n	3e0c <SDCard_Init+0xf0>
    3d54:	4848      	ldr	r0, [pc, #288]	; (3e78 <SDCard_Init+0x15c>)
    3d56:	4b44      	ldr	r3, [pc, #272]	; (3e68 <SDCard_Init+0x14c>)
    3d58:	4798      	blx	r3
        retry++;
    3d5a:	3401      	adds	r4, #1
    3d5c:	b2a4      	uxth	r4, r4
        if (retry >= 200) {
    3d5e:	2cc8      	cmp	r4, #200	; 0xc8
    3d60:	d1ec      	bne.n	3d3c <SDCard_Init+0x20>
    3d62:	e05a      	b.n	3e1a <SDCard_Init+0xfe>
            UART3_Write_Text("Failed to reset card\n");
            return STA_NOINIT; // Initialization failed
        }
    } while (response != 1);

    UART3_Write_Text("Card reset successful\n");
    3d64:	4845      	ldr	r0, [pc, #276]	; (3e7c <SDCard_Init+0x160>)
    3d66:	4b40      	ldr	r3, [pc, #256]	; (3e68 <SDCard_Init+0x14c>)
    3d68:	4798      	blx	r3

    // Check SD card version with CMD8
    response = SDCard_WriteCmd(CMD8, 0x1AA, 0x87);
    3d6a:	2287      	movs	r2, #135	; 0x87
    3d6c:	21d5      	movs	r1, #213	; 0xd5
    3d6e:	0049      	lsls	r1, r1, #1
    3d70:	2048      	movs	r0, #72	; 0x48
    3d72:	4b3e      	ldr	r3, [pc, #248]	; (3e6c <SDCard_Init+0x150>)
    3d74:	4798      	blx	r3
    3d76:	0007      	movs	r7, r0
    if (response == 1) {
    3d78:	2801      	cmp	r0, #1
    3d7a:	d13e      	bne.n	3dfa <SDCard_Init+0xde>
        uint16_t counter = 0xFFFF;
        do {
            SDCard_WriteCmd(CMD55, 0, 0xFF);
    3d7c:	22ff      	movs	r2, #255	; 0xff
    3d7e:	2100      	movs	r1, #0
    3d80:	2077      	movs	r0, #119	; 0x77
    3d82:	4c3a      	ldr	r4, [pc, #232]	; (3e6c <SDCard_Init+0x150>)
    3d84:	47a0      	blx	r4
            response = SDCard_WriteCmd(CMD41, 0x40000000, 0xFF);
    3d86:	22ff      	movs	r2, #255	; 0xff
    3d88:	2180      	movs	r1, #128	; 0x80
    3d8a:	05c9      	lsls	r1, r1, #23
    3d8c:	2069      	movs	r0, #105	; 0x69
    3d8e:	47a0      	blx	r4
    3d90:	4c3b      	ldr	r4, [pc, #236]	; (3e80 <SDCard_Init+0x164>)
            SDCard_WriteCmd(CMD55, 0, 0xFF);
    3d92:	4e36      	ldr	r6, [pc, #216]	; (3e6c <SDCard_Init+0x150>)
            response = SDCard_WriteCmd(CMD41, 0x40000000, 0xFF);
    3d94:	2580      	movs	r5, #128	; 0x80
    3d96:	05ed      	lsls	r5, r5, #23
            counter--;
            if (counter == 0) {
                UART3_Write_Text("Timeout during initialization\n");
                return STA_NOINIT;
            }
        } while (response);
    3d98:	2800      	cmp	r0, #0
    3d9a:	d010      	beq.n	3dbe <SDCard_Init+0xa2>
            SDCard_WriteCmd(CMD55, 0, 0xFF);
    3d9c:	22ff      	movs	r2, #255	; 0xff
    3d9e:	2100      	movs	r1, #0
    3da0:	2077      	movs	r0, #119	; 0x77
    3da2:	47b0      	blx	r6
            response = SDCard_WriteCmd(CMD41, 0x40000000, 0xFF);
    3da4:	22ff      	movs	r2, #255	; 0xff
    3da6:	0029      	movs	r1, r5
    3da8:	2069      	movs	r0, #105	; 0x69
    3daa:	47b0      	blx	r6
    3dac:	3c01      	subs	r4, #1
    3dae:	b2a4      	uxth	r4, r4
            if (counter == 0) {
    3db0:	2c00      	cmp	r4, #0
    3db2:	d1f1      	bne.n	3d98 <SDCard_Init+0x7c>
                UART3_Write_Text("Timeout during initialization\n");
    3db4:	4833      	ldr	r0, [pc, #204]	; (3e84 <SDCard_Init+0x168>)
    3db6:	4b2c      	ldr	r3, [pc, #176]	; (3e68 <SDCard_Init+0x14c>)
    3db8:	4798      	blx	r3
                return STA_NOINIT;
    3dba:	003e      	movs	r6, r7
    3dbc:	e020      	b.n	3e00 <SDCard_Init+0xe4>

        response = SDCard_WriteCmd(CMD58, 0, 0xFF);
    3dbe:	22ff      	movs	r2, #255	; 0xff
    3dc0:	2100      	movs	r1, #0
    3dc2:	307a      	adds	r0, #122	; 0x7a
    3dc4:	4b29      	ldr	r3, [pc, #164]	; (3e6c <SDCard_Init+0x150>)
    3dc6:	4798      	blx	r3
    3dc8:	0006      	movs	r6, r0
    3dca:	2400      	movs	r4, #0
        if (response != 0x00) {
    3dcc:	2800      	cmp	r0, #0
    3dce:	d10f      	bne.n	3df0 <SDCard_Init+0xd4>
            return STA_NOINIT;
        }

        // Read OCR register
        for (uint8_t i = 0; i < 4; i++) {
            dataBuffer[i] = SPI_SD_Read_Byte();
    3dd0:	4f2d      	ldr	r7, [pc, #180]	; (3e88 <SDCard_Init+0x16c>)
    3dd2:	4d2e      	ldr	r5, [pc, #184]	; (3e8c <SDCard_Init+0x170>)
    3dd4:	47b8      	blx	r7
    3dd6:	5528      	strb	r0, [r5, r4]
    3dd8:	3401      	adds	r4, #1
        for (uint8_t i = 0; i < 4; i++) {
    3dda:	2c04      	cmp	r4, #4
    3ddc:	d1fa      	bne.n	3dd4 <SDCard_Init+0xb8>
        }

        SD_Type = (dataBuffer[0] & 0x40) ? SD_TYPE_V2HC : SD_TYPE_V2;
    3dde:	4b2b      	ldr	r3, [pc, #172]	; (3e8c <SDCard_Init+0x170>)
    3de0:	781b      	ldrb	r3, [r3, #0]
    3de2:	065b      	lsls	r3, r3, #25
    3de4:	d420      	bmi.n	3e28 <SDCard_Init+0x10c>
    3de6:	2202      	movs	r2, #2
    3de8:	4b29      	ldr	r3, [pc, #164]	; (3e90 <SDCard_Init+0x174>)
    3dea:	701a      	strb	r2, [r3, #0]
        UART3_Write_Text(SD_Type == SD_TYPE_V2HC ? "Card: V2.0 SDHC\n" : "Card Type: V2.0\n");
    3dec:	4829      	ldr	r0, [pc, #164]	; (3e94 <SDCard_Init+0x178>)
    3dee:	e01f      	b.n	3e30 <SDCard_Init+0x114>
            UART3_Write_Text("Error reading OCR\n");
    3df0:	4829      	ldr	r0, [pc, #164]	; (3e98 <SDCard_Init+0x17c>)
    3df2:	4b1d      	ldr	r3, [pc, #116]	; (3e68 <SDCard_Init+0x14c>)
    3df4:	4798      	blx	r3
            return STA_NOINIT;
    3df6:	003e      	movs	r6, r7
    3df8:	e002      	b.n	3e00 <SDCard_Init+0xe4>
    } else {
        UART3_Write_Text("Unsupported SD card type\n");
    3dfa:	4828      	ldr	r0, [pc, #160]	; (3e9c <SDCard_Init+0x180>)
    3dfc:	4b1a      	ldr	r3, [pc, #104]	; (3e68 <SDCard_Init+0x14c>)
    3dfe:	4798      	blx	r3
    // Switch to high speed for normal operation
    SDCard_RunSpeed();
    SDCard_SS(1);

    return 0; // Success
}
    3e00:	0030      	movs	r0, r6
    3e02:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        UART3_Write_Text("Error setting block length\n");
    3e04:	4826      	ldr	r0, [pc, #152]	; (3ea0 <SDCard_Init+0x184>)
    3e06:	4b18      	ldr	r3, [pc, #96]	; (3e68 <SDCard_Init+0x14c>)
    3e08:	4798      	blx	r3
    3e0a:	e01b      	b.n	3e44 <SDCard_Init+0x128>
		UART3_Write_Text(response == 1 ? "CMD0 success\n" : "CMD0 failed\n");
    3e0c:	4825      	ldr	r0, [pc, #148]	; (3ea4 <SDCard_Init+0x188>)
    3e0e:	4b16      	ldr	r3, [pc, #88]	; (3e68 <SDCard_Init+0x14c>)
    3e10:	4798      	blx	r3
        retry++;
    3e12:	3401      	adds	r4, #1
        if (retry >= 200) {
    3e14:	b2a4      	uxth	r4, r4
    3e16:	2cc7      	cmp	r4, #199	; 0xc7
    3e18:	d9a4      	bls.n	3d64 <SDCard_Init+0x48>
			UART3_Write_Text("Failed to reset card after 200 retries\n");
    3e1a:	4823      	ldr	r0, [pc, #140]	; (3ea8 <SDCard_Init+0x18c>)
    3e1c:	4c12      	ldr	r4, [pc, #72]	; (3e68 <SDCard_Init+0x14c>)
    3e1e:	47a0      	blx	r4
            UART3_Write_Text("Failed to reset card\n");
    3e20:	4822      	ldr	r0, [pc, #136]	; (3eac <SDCard_Init+0x190>)
    3e22:	47a0      	blx	r4
            return STA_NOINIT; // Initialization failed
    3e24:	2601      	movs	r6, #1
    3e26:	e7eb      	b.n	3e00 <SDCard_Init+0xe4>
        SD_Type = (dataBuffer[0] & 0x40) ? SD_TYPE_V2HC : SD_TYPE_V2;
    3e28:	2204      	movs	r2, #4
    3e2a:	4b19      	ldr	r3, [pc, #100]	; (3e90 <SDCard_Init+0x174>)
    3e2c:	701a      	strb	r2, [r3, #0]
        UART3_Write_Text(SD_Type == SD_TYPE_V2HC ? "Card: V2.0 SDHC\n" : "Card Type: V2.0\n");
    3e2e:	4820      	ldr	r0, [pc, #128]	; (3eb0 <SDCard_Init+0x194>)
    3e30:	4b0d      	ldr	r3, [pc, #52]	; (3e68 <SDCard_Init+0x14c>)
    3e32:	4798      	blx	r3
    if (SDCard_WriteCmd(CMD16, 512, 0xFF) != 0) {
    3e34:	22ff      	movs	r2, #255	; 0xff
    3e36:	2180      	movs	r1, #128	; 0x80
    3e38:	0089      	lsls	r1, r1, #2
    3e3a:	2050      	movs	r0, #80	; 0x50
    3e3c:	4b0b      	ldr	r3, [pc, #44]	; (3e6c <SDCard_Init+0x150>)
    3e3e:	4798      	blx	r3
    3e40:	2800      	cmp	r0, #0
    3e42:	d1df      	bne.n	3e04 <SDCard_Init+0xe8>
    UART3_Write_Text("Initialization complete\n");
    3e44:	481b      	ldr	r0, [pc, #108]	; (3eb4 <SDCard_Init+0x198>)
    3e46:	4b08      	ldr	r3, [pc, #32]	; (3e68 <SDCard_Init+0x14c>)
    3e48:	4798      	blx	r3
    SPI_Initialize_Fast();
    3e4a:	4b1b      	ldr	r3, [pc, #108]	; (3eb8 <SDCard_Init+0x19c>)
    3e4c:	4798      	blx	r3
    SDCard_SS(1);
    3e4e:	2001      	movs	r0, #1
    3e50:	4b1a      	ldr	r3, [pc, #104]	; (3ebc <SDCard_Init+0x1a0>)
    3e52:	4798      	blx	r3
    return 0; // Success
    3e54:	e7d4      	b.n	3e00 <SDCard_Init+0xe4>
    3e56:	46c0      	nop			; (mov r8, r8)
    3e58:	00003f65 	.word	0x00003f65
    3e5c:	000a7693 	.word	0x000a7693
    3e60:	00002429 	.word	0x00002429
    3e64:	00004029 	.word	0x00004029
    3e68:	00004105 	.word	0x00004105
    3e6c:	00003c81 	.word	0x00003c81
    3e70:	0000496c 	.word	0x0000496c
    3e74:	00001aca 	.word	0x00001aca
    3e78:	00004a70 	.word	0x00004a70
    3e7c:	000049c0 	.word	0x000049c0
    3e80:	0000fffe 	.word	0x0000fffe
    3e84:	000049d8 	.word	0x000049d8
    3e88:	00004035 	.word	0x00004035
    3e8c:	200008bc 	.word	0x200008bc
    3e90:	2000045e 	.word	0x2000045e
    3e94:	00004944 	.word	0x00004944
    3e98:	000049f8 	.word	0x000049f8
    3e9c:	00004a0c 	.word	0x00004a0c
    3ea0:	00004a28 	.word	0x00004a28
    3ea4:	00004a60 	.word	0x00004a60
    3ea8:	00004980 	.word	0x00004980
    3eac:	000049a8 	.word	0x000049a8
    3eb0:	00004958 	.word	0x00004958
    3eb4:	00004a44 	.word	0x00004a44
    3eb8:	00003ec1 	.word	0x00003ec1
    3ebc:	00003c4d 	.word	0x00003c4d

00003ec0 <SPI_Initialize_Fast>:
 *
 ******************************************************************************/
void SPI_Initialize_Fast(void)
{
	  // Wait Sync
	  while(SERCOM2->SPI.SYNCBUSY.bit.ENABLE);
    3ec0:	4a20      	ldr	r2, [pc, #128]	; (3f44 <SPI_Initialize_Fast+0x84>)
    3ec2:	69d3      	ldr	r3, [r2, #28]
    3ec4:	079b      	lsls	r3, r3, #30
    3ec6:	d4fc      	bmi.n	3ec2 <SPI_Initialize_Fast+0x2>
	
	  /* -------------------------------------------------
	  * 1) Enable bus clock to APBC mask
	  */
	  PM->APBCMASK.reg |= PM_APBCMASK_SERCOM2;								
    3ec8:	4a1f      	ldr	r2, [pc, #124]	; (3f48 <SPI_Initialize_Fast+0x88>)
    3eca:	6a13      	ldr	r3, [r2, #32]
    3ecc:	2110      	movs	r1, #16
    3ece:	430b      	orrs	r3, r1
    3ed0:	6213      	str	r3, [r2, #32]
	  
	  
	  /* -------------------------------------------------
	  * 2) select SPI clock
	  */
	  GCLK->CLKCTRL.reg = 
    3ed2:	4a1e      	ldr	r2, [pc, #120]	; (3f4c <SPI_Initialize_Fast+0x8c>)
    3ed4:	4b1e      	ldr	r3, [pc, #120]	; (3f50 <SPI_Initialize_Fast+0x90>)
    3ed6:	805a      	strh	r2, [r3, #2]
	  GCLK_CLKCTRL_ID(SERCOM2_GCLK_ID_CORE) |				
	  GCLK_CLKCTRL_CLKEN | 
	  GCLK_CLKCTRL_GEN(0);
	  
	  while(GCLK->STATUS.bit.SYNCBUSY);
    3ed8:	001a      	movs	r2, r3
    3eda:	7853      	ldrb	r3, [r2, #1]
    3edc:	09db      	lsrs	r3, r3, #7
    3ede:	d1fc      	bne.n	3eda <SPI_Initialize_Fast+0x1a>
	  * 3) setup pins
	  */ 
	  //Using the WRCONFIG register to bulk configure PA16 for being configured the SERCOM1 SPI MASTER MISO
	  
	  // Configure PA15 for SERCOM4 SPI MASTER MISO (PAD[3])
	  PORT->Group[0].WRCONFIG.reg =
    3ee0:	4b1c      	ldr	r3, [pc, #112]	; (3f54 <SPI_Initialize_Fast+0x94>)
    3ee2:	4a1d      	ldr	r2, [pc, #116]	; (3f58 <SPI_Initialize_Fast+0x98>)
    3ee4:	629a      	str	r2, [r3, #40]	; 0x28
	  PORT_WRCONFIG_HWSEL |						     // Select the correct pin configurations for 16-31
	  PORT_WRCONFIG_INEN |							 // Enable input on this pin MISO
	  PORT_WRCONFIG_PINMASK((uint16_t)((PORT_PA15) >> 16)); // Selecting which pin is configured

	  // Using the WRCONFIG register to bulk configure PA12 for MOSI and PA13 for SCK
	  PORT->Group[0].WRCONFIG.reg =
    3ee6:	4a1d      	ldr	r2, [pc, #116]	; (3f5c <SPI_Initialize_Fast+0x9c>)
    3ee8:	629a      	str	r2, [r3, #40]	; 0x28
	  PORT_WRCONFIG_PMUXEN |							 // Enables the PMUX for the pins
	  PORT_WRCONFIG_HWSEL |							     // Select the correct pin configurations for 16-31
	  PORT_WRCONFIG_PINMASK((uint16_t)((PORT_PA12 | PORT_PA13) >> 16));	// Selecting which pins are configured
	  
	  // Set the drive strength to strong for SCK
	  PORT->Group[0].PINCFG[13].bit.DRVSTR = 1;          // PA13 (SCK)
    3eea:	214d      	movs	r1, #77	; 0x4d
    3eec:	5c5a      	ldrb	r2, [r3, r1]
    3eee:	2040      	movs	r0, #64	; 0x40
    3ef0:	4302      	orrs	r2, r0
    3ef2:	545a      	strb	r2, [r3, r1]

       /* -------------------------------------------------
	   * 4) Configure SPI Module
	   */ 
	   // Disable the SERCOM SPI module 
	   SERCOM2->SPI.CTRLA.bit.ENABLE = 0;
    3ef4:	4a13      	ldr	r2, [pc, #76]	; (3f44 <SPI_Initialize_Fast+0x84>)
    3ef6:	6813      	ldr	r3, [r2, #0]
    3ef8:	394b      	subs	r1, #75	; 0x4b
    3efa:	438b      	bics	r3, r1
    3efc:	6013      	str	r3, [r2, #0]

       // Wait for synchronization 
       while(SERCOM2->SPI.SYNCBUSY.bit.SWRST)
    3efe:	69d3      	ldr	r3, [r2, #28]
    3f00:	07db      	lsls	r3, r3, #31
    3f02:	d4fc      	bmi.n	3efe <SPI_Initialize_Fast+0x3e>
	   {
		   
	   }

       // Perform a software reset 
       SERCOM2->SPI.CTRLA.bit.SWRST = 1;
    3f04:	4a0f      	ldr	r2, [pc, #60]	; (3f44 <SPI_Initialize_Fast+0x84>)
    3f06:	6813      	ldr	r3, [r2, #0]
    3f08:	2101      	movs	r1, #1
    3f0a:	430b      	orrs	r3, r1
    3f0c:	6013      	str	r3, [r2, #0]
		   
       // Wait for synchronization 
       while(SERCOM2->SPI.CTRLA.bit.SWRST)
    3f0e:	6813      	ldr	r3, [r2, #0]
    3f10:	07db      	lsls	r3, r3, #31
    3f12:	d4fc      	bmi.n	3f0e <SPI_Initialize_Fast+0x4e>
	   {
		   
	   }
	   
	   /* Wait for synchronization */
	   while(SERCOM2->SPI.SYNCBUSY.bit.SWRST || SERCOM2->SPI.SYNCBUSY.bit.ENABLE);
    3f14:	4a0b      	ldr	r2, [pc, #44]	; (3f44 <SPI_Initialize_Fast+0x84>)
    3f16:	69d3      	ldr	r3, [r2, #28]
    3f18:	07db      	lsls	r3, r3, #31
    3f1a:	d4fc      	bmi.n	3f16 <SPI_Initialize_Fast+0x56>
    3f1c:	69d3      	ldr	r3, [r2, #28]
    3f1e:	079b      	lsls	r3, r3, #30
    3f20:	d4f9      	bmi.n	3f16 <SPI_Initialize_Fast+0x56>

	   SERCOM2->SPI.CTRLA.reg = 
    3f22:	4b08      	ldr	r3, [pc, #32]	; (3f44 <SPI_Initialize_Fast+0x84>)
    3f24:	4a0e      	ldr	r2, [pc, #56]	; (3f60 <SPI_Initialize_Fast+0xa0>)
    3f26:	601a      	str	r2, [r3, #0]
	   SERCOM_SPI_CTRLA_MODE_SPI_MASTER |   // set SPI Master Mode
	   SERCOM_SPI_CTRLA_DIPO(2) |           // PAD2 is used as data input
	   SERCOM_SPI_CTRLA_DOPO(3);            // PAD0 is used as data output, PAD3 is SCK, PAD1 is SS
		 
	   SERCOM2->SPI.CTRLB.reg = SERCOM_SPI_CTRLB_RXEN;      // Enable SPI Receive enable
    3f28:	2280      	movs	r2, #128	; 0x80
    3f2a:	0292      	lsls	r2, r2, #10
    3f2c:	605a      	str	r2, [r3, #4]
	
	   /* -------------------------------------------------
	   * 5) Set the baud rate
	   */ 
	   uint32_t BAUD_REG =  ((float)48000000 / (float)(2 * 12000000)) - 1;	//Calculate BAUD value
	   SERCOM2->SPI.BAUD.reg =	SERCOM_SPI_BAUD_BAUD(BAUD_REG);
    3f2e:	2201      	movs	r2, #1
    3f30:	731a      	strb	r2, [r3, #12]
	   /* -------------------------------------------------
	   * 6) Enable SPI Module
	   */ 
	    // enable SPI receive
	    
	    SERCOM2->SPI.CTRLA.reg |= SERCOM_SPI_CTRLA_ENABLE;	//Enable the SPI
    3f32:	681a      	ldr	r2, [r3, #0]
    3f34:	2102      	movs	r1, #2
    3f36:	430a      	orrs	r2, r1
    3f38:	601a      	str	r2, [r3, #0]
	    while(SERCOM2->SPI.SYNCBUSY.bit.ENABLE);
    3f3a:	001a      	movs	r2, r3
    3f3c:	69d3      	ldr	r3, [r2, #28]
    3f3e:	079b      	lsls	r3, r3, #30
    3f40:	d4fc      	bmi.n	3f3c <SPI_Initialize_Fast+0x7c>
}
    3f42:	4770      	bx	lr
    3f44:	42001000 	.word	0x42001000
    3f48:	40000400 	.word	0x40000400
    3f4c:	00004016 	.word	0x00004016
    3f50:	40000c00 	.word	0x40000c00
    3f54:	41004400 	.word	0x41004400
    3f58:	d2030000 	.word	0xd2030000
    3f5c:	d2010000 	.word	0xd2010000
    3f60:	0023000c 	.word	0x0023000c

00003f64 <SPI_Initialize_Slow>:
 *
 ******************************************************************************/
void SPI_Initialize_Slow(void)
{
	  // Wait Sync
	  while(SERCOM2->SPI.SYNCBUSY.bit.ENABLE);
    3f64:	4a20      	ldr	r2, [pc, #128]	; (3fe8 <SPI_Initialize_Slow+0x84>)
    3f66:	69d3      	ldr	r3, [r2, #28]
    3f68:	079b      	lsls	r3, r3, #30
    3f6a:	d4fc      	bmi.n	3f66 <SPI_Initialize_Slow+0x2>
	
	  /* -------------------------------------------------
	  * 1) Enable bus clock to APBC mask
	  */
	  PM->APBCMASK.reg |= PM_APBCMASK_SERCOM2;								
    3f6c:	4a1f      	ldr	r2, [pc, #124]	; (3fec <SPI_Initialize_Slow+0x88>)
    3f6e:	6a13      	ldr	r3, [r2, #32]
    3f70:	2110      	movs	r1, #16
    3f72:	430b      	orrs	r3, r1
    3f74:	6213      	str	r3, [r2, #32]
	  
	  
	  /* -------------------------------------------------
	  * 2) select SPI clock
	  */
	  GCLK->CLKCTRL.reg = 
    3f76:	4a1e      	ldr	r2, [pc, #120]	; (3ff0 <SPI_Initialize_Slow+0x8c>)
    3f78:	4b1e      	ldr	r3, [pc, #120]	; (3ff4 <SPI_Initialize_Slow+0x90>)
    3f7a:	805a      	strh	r2, [r3, #2]
	  GCLK_CLKCTRL_ID(SERCOM2_GCLK_ID_CORE) |				
	  GCLK_CLKCTRL_CLKEN | 
	  GCLK_CLKCTRL_GEN(0);
	  
	  while(GCLK->STATUS.bit.SYNCBUSY);
    3f7c:	001a      	movs	r2, r3
    3f7e:	7853      	ldrb	r3, [r2, #1]
    3f80:	09db      	lsrs	r3, r3, #7
    3f82:	d1fc      	bne.n	3f7e <SPI_Initialize_Slow+0x1a>
	  * 3) setup pins
	  */ 
	  //Using the WRCONFIG register to bulk configure PA16 for being configured the SERCOM5 SPI MASTER MISO
	  
	  // Configure PA15 for SERCOM4 SPI MASTER MISO (PAD[3])
	  PORT->Group[0].WRCONFIG.reg =
    3f84:	4b1c      	ldr	r3, [pc, #112]	; (3ff8 <SPI_Initialize_Slow+0x94>)
    3f86:	4a1d      	ldr	r2, [pc, #116]	; (3ffc <SPI_Initialize_Slow+0x98>)
    3f88:	629a      	str	r2, [r3, #40]	; 0x28
	  PORT_WRCONFIG_HWSEL |						     // Select the correct pin configurations for 16-31
	  PORT_WRCONFIG_INEN |							 // Enable input on this pin MISO
	  PORT_WRCONFIG_PINMASK((uint16_t)((PORT_PA15) >> 16)); // Selecting which pin is configured

	  // Using the WRCONFIG register to bulk configure PA12 for MOSI and PA13 for SCK
	  PORT->Group[0].WRCONFIG.reg =
    3f8a:	4a1d      	ldr	r2, [pc, #116]	; (4000 <SPI_Initialize_Slow+0x9c>)
    3f8c:	629a      	str	r2, [r3, #40]	; 0x28
	  PORT_WRCONFIG_PMUXEN |							 // Enables the PMUX for the pins
	  PORT_WRCONFIG_HWSEL |							     // Select the correct pin configurations for 16-31
	  PORT_WRCONFIG_PINMASK((uint16_t)((PORT_PA12 | PORT_PA13) >> 16));	// Selecting which pins are configured
	  
	  // Set the drive strength to strong for SCK
	  PORT->Group[0].PINCFG[13].bit.DRVSTR = 1;          // PA13 (SCK)
    3f8e:	214d      	movs	r1, #77	; 0x4d
    3f90:	5c5a      	ldrb	r2, [r3, r1]
    3f92:	2040      	movs	r0, #64	; 0x40
    3f94:	4302      	orrs	r2, r0
    3f96:	545a      	strb	r2, [r3, r1]

       /* -------------------------------------------------
	   * 4) Configure SPI Module
	   */ 
	   // Disable the SERCOM SPI module 
	   SERCOM2->SPI.CTRLA.bit.ENABLE = 0;
    3f98:	4a13      	ldr	r2, [pc, #76]	; (3fe8 <SPI_Initialize_Slow+0x84>)
    3f9a:	6813      	ldr	r3, [r2, #0]
    3f9c:	394b      	subs	r1, #75	; 0x4b
    3f9e:	438b      	bics	r3, r1
    3fa0:	6013      	str	r3, [r2, #0]

       // Wait for synchronization 
       while(SERCOM2->SPI.SYNCBUSY.bit.SWRST)
    3fa2:	69d3      	ldr	r3, [r2, #28]
    3fa4:	07db      	lsls	r3, r3, #31
    3fa6:	d4fc      	bmi.n	3fa2 <SPI_Initialize_Slow+0x3e>
	   {
		   
	   }

       // Perform a software reset 
       SERCOM2->SPI.CTRLA.bit.SWRST = 1;
    3fa8:	4a0f      	ldr	r2, [pc, #60]	; (3fe8 <SPI_Initialize_Slow+0x84>)
    3faa:	6813      	ldr	r3, [r2, #0]
    3fac:	2101      	movs	r1, #1
    3fae:	430b      	orrs	r3, r1
    3fb0:	6013      	str	r3, [r2, #0]
		   
       // Wait for synchronization 
       while(SERCOM2->SPI.CTRLA.bit.SWRST)
    3fb2:	6813      	ldr	r3, [r2, #0]
    3fb4:	07db      	lsls	r3, r3, #31
    3fb6:	d4fc      	bmi.n	3fb2 <SPI_Initialize_Slow+0x4e>
	   {
		   
	   }
	   
	   /* Wait for synchronization */
	   while(SERCOM2->SPI.SYNCBUSY.bit.SWRST || SERCOM2->SPI.SYNCBUSY.bit.ENABLE);
    3fb8:	4a0b      	ldr	r2, [pc, #44]	; (3fe8 <SPI_Initialize_Slow+0x84>)
    3fba:	69d3      	ldr	r3, [r2, #28]
    3fbc:	07db      	lsls	r3, r3, #31
    3fbe:	d4fc      	bmi.n	3fba <SPI_Initialize_Slow+0x56>
    3fc0:	69d3      	ldr	r3, [r2, #28]
    3fc2:	079b      	lsls	r3, r3, #30
    3fc4:	d4f9      	bmi.n	3fba <SPI_Initialize_Slow+0x56>

	   SERCOM2->SPI.CTRLA.reg = 
    3fc6:	4b08      	ldr	r3, [pc, #32]	; (3fe8 <SPI_Initialize_Slow+0x84>)
    3fc8:	4a0e      	ldr	r2, [pc, #56]	; (4004 <SPI_Initialize_Slow+0xa0>)
    3fca:	601a      	str	r2, [r3, #0]
	   SERCOM_SPI_CTRLA_MODE_SPI_MASTER |   // set SPI Master Mode
	   SERCOM_SPI_CTRLA_DIPO(2) |           // PAD2 is used as data input
	   SERCOM_SPI_CTRLA_DOPO(3);            // PAD0 is used as data output, PAD3 is SCK, PAD1 is SS
		 
	   SERCOM2->SPI.CTRLB.reg = SERCOM_SPI_CTRLB_RXEN;      // Enable SPI Receive enable
    3fcc:	2280      	movs	r2, #128	; 0x80
    3fce:	0292      	lsls	r2, r2, #10
    3fd0:	605a      	str	r2, [r3, #4]
	
	   /* -------------------------------------------------
	   * 5) Set the baud rate
	   */ 
	   uint32_t BAUD_REG =  ((float)48000000 / (float)(2 * 400000)) - 1;	//Calculate BAUD value
	   SERCOM2->SPI.BAUD.reg =	SERCOM_SPI_BAUD_BAUD(BAUD_REG);
    3fd2:	223b      	movs	r2, #59	; 0x3b
    3fd4:	731a      	strb	r2, [r3, #12]
	   /* -------------------------------------------------
	   * 6) Enable SPI Module
	   */ 
	    // enable SPI receive
	    
	    SERCOM2->SPI.CTRLA.reg |= SERCOM_SPI_CTRLA_ENABLE;	//Enable the SPI
    3fd6:	681a      	ldr	r2, [r3, #0]
    3fd8:	2102      	movs	r1, #2
    3fda:	430a      	orrs	r2, r1
    3fdc:	601a      	str	r2, [r3, #0]
	    while(SERCOM2->SPI.SYNCBUSY.bit.ENABLE);
    3fde:	001a      	movs	r2, r3
    3fe0:	69d3      	ldr	r3, [r2, #28]
    3fe2:	079b      	lsls	r3, r3, #30
    3fe4:	d4fc      	bmi.n	3fe0 <SPI_Initialize_Slow+0x7c>
}
    3fe6:	4770      	bx	lr
    3fe8:	42001000 	.word	0x42001000
    3fec:	40000400 	.word	0x40000400
    3ff0:	00004016 	.word	0x00004016
    3ff4:	40000c00 	.word	0x40000c00
    3ff8:	41004400 	.word	0x41004400
    3ffc:	d2030000 	.word	0xd2030000
    4000:	d2010000 	.word	0xd2010000
    4004:	0023000c 	.word	0x0023000c

00004008 <SPI_Exchange8bit>:
 * Note:            
 *
 ******************************************************************************/
uint8_t SPI_Exchange8bit(uint8_t data)
{
	while(SERCOM2->SPI.INTFLAG.bit.DRE == 0);
    4008:	4a06      	ldr	r2, [pc, #24]	; (4024 <SPI_Exchange8bit+0x1c>)
    400a:	7e13      	ldrb	r3, [r2, #24]
    400c:	07db      	lsls	r3, r3, #31
    400e:	d5fc      	bpl.n	400a <SPI_Exchange8bit+0x2>
	SERCOM2->SPI.DATA.reg = data;
    4010:	4b04      	ldr	r3, [pc, #16]	; (4024 <SPI_Exchange8bit+0x1c>)
    4012:	6298      	str	r0, [r3, #40]	; 0x28
	
	while(SERCOM2->SPI.INTFLAG.bit.RXC == 0);
    4014:	001a      	movs	r2, r3
    4016:	7e13      	ldrb	r3, [r2, #24]
    4018:	075b      	lsls	r3, r3, #29
    401a:	d5fc      	bpl.n	4016 <SPI_Exchange8bit+0xe>
	return (uint8_t)SERCOM2->SPI.DATA.reg;
    401c:	4b01      	ldr	r3, [pc, #4]	; (4024 <SPI_Exchange8bit+0x1c>)
    401e:	6a98      	ldr	r0, [r3, #40]	; 0x28
    4020:	b2c0      	uxtb	r0, r0
}
    4022:	4770      	bx	lr
    4024:	42001000 	.word	0x42001000

00004028 <SPI_SD_Send_Byte>:
 *
 * Note:            
 *
 ******************************************************************************/
uint8_t SPI_SD_Send_Byte(uint8_t byte_val)
{
    4028:	b510      	push	{r4, lr}
	uint8_t data;
	
	data = SPI_Exchange8bit(byte_val);
    402a:	4b01      	ldr	r3, [pc, #4]	; (4030 <SPI_SD_Send_Byte+0x8>)
    402c:	4798      	blx	r3
	return data;
}
    402e:	bd10      	pop	{r4, pc}
    4030:	00004009 	.word	0x00004009

00004034 <SPI_SD_Read_Byte>:
 *
 * Note:            
 *
 ******************************************************************************/
uint8_t SPI_SD_Read_Byte(void)
{
    4034:	b510      	push	{r4, lr}
	uint8_t data;

	data = SPI_Exchange8bit(0xff);
    4036:	20ff      	movs	r0, #255	; 0xff
    4038:	4b01      	ldr	r3, [pc, #4]	; (4040 <SPI_SD_Read_Byte+0xc>)
    403a:	4798      	blx	r3
	return data;
    403c:	bd10      	pop	{r4, pc}
    403e:	46c0      	nop			; (mov r8, r8)
    4040:	00004009 	.word	0x00004009

00004044 <UART3_Init>:
 *
 * Note:            
 *
 ******************************************************************************/
void UART3_Init(uint32_t baud)
{
    4044:	b570      	push	{r4, r5, r6, lr}
	
	/* -------------------------------------------------
	* 1) Enable bus clock to APBC mask
	*/
	REG_PM_APBCMASK |=  PM_APBCMASK_SERCOM3;
    4046:	4a21      	ldr	r2, [pc, #132]	; (40cc <UART3_Init+0x88>)
    4048:	6813      	ldr	r3, [r2, #0]
    404a:	2120      	movs	r1, #32
    404c:	430b      	orrs	r3, r1
    404e:	6013      	str	r3, [r2, #0]
	
    /* -------------------------------------------------
	* 2) select UART clock
	*/
	GCLK->CLKCTRL.reg =  
    4050:	4a1f      	ldr	r2, [pc, #124]	; (40d0 <UART3_Init+0x8c>)
    4052:	4b20      	ldr	r3, [pc, #128]	; (40d4 <UART3_Init+0x90>)
    4054:	805a      	strh	r2, [r3, #2]
	
	/* --------------------------------------------------
	* 3) Configure PA22 as TX Pin
	*/
	// Set pin direction to output
	PORT->Group[0].DIRSET.reg = (1 << 22);     
    4056:	4b20      	ldr	r3, [pc, #128]	; (40d8 <UART3_Init+0x94>)
    4058:	2280      	movs	r2, #128	; 0x80
    405a:	03d2      	lsls	r2, r2, #15
    405c:	609a      	str	r2, [r3, #8]
	
    // Enable PMUX
	PORT->Group[0].PINCFG[22].reg |= PORT_PINCFG_PMUXEN;   
    405e:	2256      	movs	r2, #86	; 0x56
    4060:	5c99      	ldrb	r1, [r3, r2]
    4062:	2601      	movs	r6, #1
    4064:	4331      	orrs	r1, r6
    4066:	b2c9      	uxtb	r1, r1
    4068:	5499      	strb	r1, [r3, r2]
	
	// Enable PMUX and set the PMUX bit, since pin is even we use PMUXE
	PORT->Group[0].PMUX[22>>1].bit.PMUXE = PORT_PMUX_PMUXE_C_Val;
    406a:	243b      	movs	r4, #59	; 0x3b
    406c:	5d19      	ldrb	r1, [r3, r4]
    406e:	3a47      	subs	r2, #71	; 0x47
    4070:	4391      	bics	r1, r2
    4072:	2202      	movs	r2, #2
    4074:	4311      	orrs	r1, r2
    4076:	5519      	strb	r1, [r3, r4]
	
	/* ---------------------------------------------------
	* 4) Configure PA23 as RX Pin
	*/
	// Set pin direction to input
	PORT->Group[0].DIRCLR.reg = (1 << 23);       
    4078:	2280      	movs	r2, #128	; 0x80
    407a:	0412      	lsls	r2, r2, #16
    407c:	605a      	str	r2, [r3, #4]

	// Enable pull down resistor
	PORT->Group[0].PINCFG[23].reg &= ~PORT_PINCFG_PULLEN;   
    407e:	2157      	movs	r1, #87	; 0x57
    4080:	5c5d      	ldrb	r5, [r3, r1]
    4082:	2204      	movs	r2, #4
    4084:	4395      	bics	r5, r2
    4086:	545d      	strb	r5, [r3, r1]
	
	// Enable PMUX and set the PMUX bit, since pin is odd we use PMUX0
	PORT->Group[0].PINCFG[23].reg |= PORT_PINCFG_PMUXEN; 
    4088:	5c5a      	ldrb	r2, [r3, r1]
    408a:	4332      	orrs	r2, r6
    408c:	b2d2      	uxtb	r2, r2
    408e:	545a      	strb	r2, [r3, r1]
	PORT->Group[0].PMUX[23>>1].bit.PMUXO = PORT_PMUX_PMUXO_C_Val; 
    4090:	5d19      	ldrb	r1, [r3, r4]
    4092:	220f      	movs	r2, #15
    4094:	400a      	ands	r2, r1
    4096:	2120      	movs	r1, #32
    4098:	430a      	orrs	r2, r1
    409a:	551a      	strb	r2, [r3, r4]
	
	
	/* ----------------------------------------------------
	* 5) Configure USART via Control A and Control B 
	*/
	SERCOM3->USART.CTRLA.reg =                  // USART is ASYNCHRONOUS
    409c:	4c0f      	ldr	r4, [pc, #60]	; (40dc <UART3_Init+0x98>)
    409e:	4b10      	ldr	r3, [pc, #64]	; (40e0 <UART3_Init+0x9c>)
    40a0:	6023      	str	r3, [r4, #0]
	   SERCOM_USART_CTRLA_MODE_USART_INT_CLK |  // Set Internal Clock 
	   SERCOM_USART_CTRLA_RXPO(1) |             // Use SERCOM pad 1 for data reception
	   SERCOM_USART_CTRLA_TXPO(0/*PAD0*/);      // Set SERCOM pad 0 for data transmission
	
	
	SERCOM3->USART.CTRLB.reg =        // We don't use PARITY
    40a2:	23c0      	movs	r3, #192	; 0xc0
    40a4:	029b      	lsls	r3, r3, #10
    40a6:	6063      	str	r3, [r4, #4]
	
	/* -----------------------------------------------------
	* 6) Set USART Baud Rate
	*/
	// Baud rate is (65536) * (CPU_CLock - 16 * wanted baud) / CPU_Clock
	uint64_t baudRate = (uint64_t)65536 * (F_CPU - 16 * baud) / F_CPU;
    40a8:	0100      	lsls	r0, r0, #4
    40aa:	4240      	negs	r0, r0
    40ac:	4b0d      	ldr	r3, [pc, #52]	; (40e4 <UART3_Init+0xa0>)
    40ae:	469c      	mov	ip, r3
    40b0:	4460      	add	r0, ip
    40b2:	0c01      	lsrs	r1, r0, #16
    40b4:	0400      	lsls	r0, r0, #16
    40b6:	4a0b      	ldr	r2, [pc, #44]	; (40e4 <UART3_Init+0xa0>)
    40b8:	2300      	movs	r3, #0
    40ba:	4d0b      	ldr	r5, [pc, #44]	; (40e8 <UART3_Init+0xa4>)
    40bc:	47a8      	blx	r5
	
	// Set Baud Rate
	SERCOM3->USART.BAUD.reg = (uint32_t)baudRate;
    40be:	b280      	uxth	r0, r0
    40c0:	81a0      	strh	r0, [r4, #12]

    /* ------------------------------------------------------
	* 7) Enable the USART
	*/
	// SERCOM3 peripheral enabled
	SERCOM3->USART.CTRLA.reg |= SERCOM_USART_CTRLA_ENABLE;
    40c2:	6823      	ldr	r3, [r4, #0]
    40c4:	2202      	movs	r2, #2
    40c6:	4313      	orrs	r3, r2
    40c8:	6023      	str	r3, [r4, #0]
}  // UART3_Init()
    40ca:	bd70      	pop	{r4, r5, r6, pc}
    40cc:	40000420 	.word	0x40000420
    40d0:	00004017 	.word	0x00004017
    40d4:	40000c00 	.word	0x40000c00
    40d8:	41004400 	.word	0x41004400
    40dc:	42001400 	.word	0x42001400
    40e0:	40100004 	.word	0x40100004
    40e4:	02dc6c00 	.word	0x02dc6c00
    40e8:	00004245 	.word	0x00004245

000040ec <UART3_Write>:
 *
 ******************************************************************************/
void UART3_Write(char data)
{
	// Wait on interrupt flag and Write some data
	while(!(REG_SERCOM3_USART_INTFLAG) & 1)
    40ec:	4a03      	ldr	r2, [pc, #12]	; (40fc <UART3_Write+0x10>)
    40ee:	7813      	ldrb	r3, [r2, #0]
    40f0:	2b00      	cmp	r3, #0
    40f2:	d0fc      	beq.n	40ee <UART3_Write+0x2>
	{
		
	}
	
	REG_SERCOM3_USART_DATA = data;
    40f4:	b280      	uxth	r0, r0
    40f6:	4b02      	ldr	r3, [pc, #8]	; (4100 <UART3_Write+0x14>)
    40f8:	8018      	strh	r0, [r3, #0]
} //UART3_Write()
    40fa:	4770      	bx	lr
    40fc:	42001418 	.word	0x42001418
    4100:	42001428 	.word	0x42001428

00004104 <UART3_Write_Text>:
 *
 * Note:            
 *
 ******************************************************************************/
void UART3_Write_Text(char *text)
{
    4104:	b570      	push	{r4, r5, r6, lr}
    4106:	0004      	movs	r4, r0
	// Send a carriage return to move to the start of the line
	UART3_Write('\r');
    4108:	200d      	movs	r0, #13
    410a:	4b07      	ldr	r3, [pc, #28]	; (4128 <UART3_Write_Text+0x24>)
    410c:	4798      	blx	r3

	// Write the text until the end of the string
	for (int i = 0; text[i] != '\0'; i++)
    410e:	7820      	ldrb	r0, [r4, #0]
    4110:	2800      	cmp	r0, #0
    4112:	d007      	beq.n	4124 <UART3_Write_Text+0x20>
    4114:	3401      	adds	r4, #1
	{
		UART3_Write(text[i]);
    4116:	4d04      	ldr	r5, [pc, #16]	; (4128 <UART3_Write_Text+0x24>)
    4118:	47a8      	blx	r5
    411a:	3401      	adds	r4, #1
	for (int i = 0; text[i] != '\0'; i++)
    411c:	1e63      	subs	r3, r4, #1
    411e:	7818      	ldrb	r0, [r3, #0]
    4120:	2800      	cmp	r0, #0
    4122:	d1f9      	bne.n	4118 <UART3_Write_Text+0x14>
	}
} // UART3_Write_Text()
    4124:	bd70      	pop	{r4, r5, r6, pc}
    4126:	46c0      	nop			; (mov r8, r8)
    4128:	000040ed 	.word	0x000040ed

0000412c <__udivsi3>:
    412c:	2200      	movs	r2, #0
    412e:	0843      	lsrs	r3, r0, #1
    4130:	428b      	cmp	r3, r1
    4132:	d374      	bcc.n	421e <__udivsi3+0xf2>
    4134:	0903      	lsrs	r3, r0, #4
    4136:	428b      	cmp	r3, r1
    4138:	d35f      	bcc.n	41fa <__udivsi3+0xce>
    413a:	0a03      	lsrs	r3, r0, #8
    413c:	428b      	cmp	r3, r1
    413e:	d344      	bcc.n	41ca <__udivsi3+0x9e>
    4140:	0b03      	lsrs	r3, r0, #12
    4142:	428b      	cmp	r3, r1
    4144:	d328      	bcc.n	4198 <__udivsi3+0x6c>
    4146:	0c03      	lsrs	r3, r0, #16
    4148:	428b      	cmp	r3, r1
    414a:	d30d      	bcc.n	4168 <__udivsi3+0x3c>
    414c:	22ff      	movs	r2, #255	; 0xff
    414e:	0209      	lsls	r1, r1, #8
    4150:	ba12      	rev	r2, r2
    4152:	0c03      	lsrs	r3, r0, #16
    4154:	428b      	cmp	r3, r1
    4156:	d302      	bcc.n	415e <__udivsi3+0x32>
    4158:	1212      	asrs	r2, r2, #8
    415a:	0209      	lsls	r1, r1, #8
    415c:	d065      	beq.n	422a <__udivsi3+0xfe>
    415e:	0b03      	lsrs	r3, r0, #12
    4160:	428b      	cmp	r3, r1
    4162:	d319      	bcc.n	4198 <__udivsi3+0x6c>
    4164:	e000      	b.n	4168 <__udivsi3+0x3c>
    4166:	0a09      	lsrs	r1, r1, #8
    4168:	0bc3      	lsrs	r3, r0, #15
    416a:	428b      	cmp	r3, r1
    416c:	d301      	bcc.n	4172 <__udivsi3+0x46>
    416e:	03cb      	lsls	r3, r1, #15
    4170:	1ac0      	subs	r0, r0, r3
    4172:	4152      	adcs	r2, r2
    4174:	0b83      	lsrs	r3, r0, #14
    4176:	428b      	cmp	r3, r1
    4178:	d301      	bcc.n	417e <__udivsi3+0x52>
    417a:	038b      	lsls	r3, r1, #14
    417c:	1ac0      	subs	r0, r0, r3
    417e:	4152      	adcs	r2, r2
    4180:	0b43      	lsrs	r3, r0, #13
    4182:	428b      	cmp	r3, r1
    4184:	d301      	bcc.n	418a <__udivsi3+0x5e>
    4186:	034b      	lsls	r3, r1, #13
    4188:	1ac0      	subs	r0, r0, r3
    418a:	4152      	adcs	r2, r2
    418c:	0b03      	lsrs	r3, r0, #12
    418e:	428b      	cmp	r3, r1
    4190:	d301      	bcc.n	4196 <__udivsi3+0x6a>
    4192:	030b      	lsls	r3, r1, #12
    4194:	1ac0      	subs	r0, r0, r3
    4196:	4152      	adcs	r2, r2
    4198:	0ac3      	lsrs	r3, r0, #11
    419a:	428b      	cmp	r3, r1
    419c:	d301      	bcc.n	41a2 <__udivsi3+0x76>
    419e:	02cb      	lsls	r3, r1, #11
    41a0:	1ac0      	subs	r0, r0, r3
    41a2:	4152      	adcs	r2, r2
    41a4:	0a83      	lsrs	r3, r0, #10
    41a6:	428b      	cmp	r3, r1
    41a8:	d301      	bcc.n	41ae <__udivsi3+0x82>
    41aa:	028b      	lsls	r3, r1, #10
    41ac:	1ac0      	subs	r0, r0, r3
    41ae:	4152      	adcs	r2, r2
    41b0:	0a43      	lsrs	r3, r0, #9
    41b2:	428b      	cmp	r3, r1
    41b4:	d301      	bcc.n	41ba <__udivsi3+0x8e>
    41b6:	024b      	lsls	r3, r1, #9
    41b8:	1ac0      	subs	r0, r0, r3
    41ba:	4152      	adcs	r2, r2
    41bc:	0a03      	lsrs	r3, r0, #8
    41be:	428b      	cmp	r3, r1
    41c0:	d301      	bcc.n	41c6 <__udivsi3+0x9a>
    41c2:	020b      	lsls	r3, r1, #8
    41c4:	1ac0      	subs	r0, r0, r3
    41c6:	4152      	adcs	r2, r2
    41c8:	d2cd      	bcs.n	4166 <__udivsi3+0x3a>
    41ca:	09c3      	lsrs	r3, r0, #7
    41cc:	428b      	cmp	r3, r1
    41ce:	d301      	bcc.n	41d4 <__udivsi3+0xa8>
    41d0:	01cb      	lsls	r3, r1, #7
    41d2:	1ac0      	subs	r0, r0, r3
    41d4:	4152      	adcs	r2, r2
    41d6:	0983      	lsrs	r3, r0, #6
    41d8:	428b      	cmp	r3, r1
    41da:	d301      	bcc.n	41e0 <__udivsi3+0xb4>
    41dc:	018b      	lsls	r3, r1, #6
    41de:	1ac0      	subs	r0, r0, r3
    41e0:	4152      	adcs	r2, r2
    41e2:	0943      	lsrs	r3, r0, #5
    41e4:	428b      	cmp	r3, r1
    41e6:	d301      	bcc.n	41ec <__udivsi3+0xc0>
    41e8:	014b      	lsls	r3, r1, #5
    41ea:	1ac0      	subs	r0, r0, r3
    41ec:	4152      	adcs	r2, r2
    41ee:	0903      	lsrs	r3, r0, #4
    41f0:	428b      	cmp	r3, r1
    41f2:	d301      	bcc.n	41f8 <__udivsi3+0xcc>
    41f4:	010b      	lsls	r3, r1, #4
    41f6:	1ac0      	subs	r0, r0, r3
    41f8:	4152      	adcs	r2, r2
    41fa:	08c3      	lsrs	r3, r0, #3
    41fc:	428b      	cmp	r3, r1
    41fe:	d301      	bcc.n	4204 <__udivsi3+0xd8>
    4200:	00cb      	lsls	r3, r1, #3
    4202:	1ac0      	subs	r0, r0, r3
    4204:	4152      	adcs	r2, r2
    4206:	0883      	lsrs	r3, r0, #2
    4208:	428b      	cmp	r3, r1
    420a:	d301      	bcc.n	4210 <__udivsi3+0xe4>
    420c:	008b      	lsls	r3, r1, #2
    420e:	1ac0      	subs	r0, r0, r3
    4210:	4152      	adcs	r2, r2
    4212:	0843      	lsrs	r3, r0, #1
    4214:	428b      	cmp	r3, r1
    4216:	d301      	bcc.n	421c <__udivsi3+0xf0>
    4218:	004b      	lsls	r3, r1, #1
    421a:	1ac0      	subs	r0, r0, r3
    421c:	4152      	adcs	r2, r2
    421e:	1a41      	subs	r1, r0, r1
    4220:	d200      	bcs.n	4224 <__udivsi3+0xf8>
    4222:	4601      	mov	r1, r0
    4224:	4152      	adcs	r2, r2
    4226:	4610      	mov	r0, r2
    4228:	4770      	bx	lr
    422a:	e7ff      	b.n	422c <__udivsi3+0x100>
    422c:	b501      	push	{r0, lr}
    422e:	2000      	movs	r0, #0
    4230:	f000 f806 	bl	4240 <__aeabi_idiv0>
    4234:	bd02      	pop	{r1, pc}
    4236:	46c0      	nop			; (mov r8, r8)

00004238 <__aeabi_uidivmod>:
    4238:	2900      	cmp	r1, #0
    423a:	d0f7      	beq.n	422c <__udivsi3+0x100>
    423c:	e776      	b.n	412c <__udivsi3>
    423e:	4770      	bx	lr

00004240 <__aeabi_idiv0>:
    4240:	4770      	bx	lr
    4242:	46c0      	nop			; (mov r8, r8)

00004244 <__aeabi_uldivmod>:
    4244:	2b00      	cmp	r3, #0
    4246:	d111      	bne.n	426c <__aeabi_uldivmod+0x28>
    4248:	2a00      	cmp	r2, #0
    424a:	d10f      	bne.n	426c <__aeabi_uldivmod+0x28>
    424c:	2900      	cmp	r1, #0
    424e:	d100      	bne.n	4252 <__aeabi_uldivmod+0xe>
    4250:	2800      	cmp	r0, #0
    4252:	d002      	beq.n	425a <__aeabi_uldivmod+0x16>
    4254:	2100      	movs	r1, #0
    4256:	43c9      	mvns	r1, r1
    4258:	1c08      	adds	r0, r1, #0
    425a:	b407      	push	{r0, r1, r2}
    425c:	4802      	ldr	r0, [pc, #8]	; (4268 <__aeabi_uldivmod+0x24>)
    425e:	a102      	add	r1, pc, #8	; (adr r1, 4268 <__aeabi_uldivmod+0x24>)
    4260:	1840      	adds	r0, r0, r1
    4262:	9002      	str	r0, [sp, #8]
    4264:	bd03      	pop	{r0, r1, pc}
    4266:	46c0      	nop			; (mov r8, r8)
    4268:	ffffffd9 	.word	0xffffffd9
    426c:	b403      	push	{r0, r1}
    426e:	4668      	mov	r0, sp
    4270:	b501      	push	{r0, lr}
    4272:	9802      	ldr	r0, [sp, #8]
    4274:	f000 f806 	bl	4284 <__udivmoddi4>
    4278:	9b01      	ldr	r3, [sp, #4]
    427a:	469e      	mov	lr, r3
    427c:	b002      	add	sp, #8
    427e:	bc0c      	pop	{r2, r3}
    4280:	4770      	bx	lr
    4282:	46c0      	nop			; (mov r8, r8)

00004284 <__udivmoddi4>:
    4284:	b5f0      	push	{r4, r5, r6, r7, lr}
    4286:	4657      	mov	r7, sl
    4288:	464e      	mov	r6, r9
    428a:	4645      	mov	r5, r8
    428c:	46de      	mov	lr, fp
    428e:	b5e0      	push	{r5, r6, r7, lr}
    4290:	0004      	movs	r4, r0
    4292:	b083      	sub	sp, #12
    4294:	000d      	movs	r5, r1
    4296:	4692      	mov	sl, r2
    4298:	4699      	mov	r9, r3
    429a:	428b      	cmp	r3, r1
    429c:	d82f      	bhi.n	42fe <__udivmoddi4+0x7a>
    429e:	d02c      	beq.n	42fa <__udivmoddi4+0x76>
    42a0:	4649      	mov	r1, r9
    42a2:	4650      	mov	r0, sl
    42a4:	f000 f8ae 	bl	4404 <__clzdi2>
    42a8:	0029      	movs	r1, r5
    42aa:	0006      	movs	r6, r0
    42ac:	0020      	movs	r0, r4
    42ae:	f000 f8a9 	bl	4404 <__clzdi2>
    42b2:	1a33      	subs	r3, r6, r0
    42b4:	4698      	mov	r8, r3
    42b6:	3b20      	subs	r3, #32
    42b8:	469b      	mov	fp, r3
    42ba:	d500      	bpl.n	42be <__udivmoddi4+0x3a>
    42bc:	e074      	b.n	43a8 <__udivmoddi4+0x124>
    42be:	4653      	mov	r3, sl
    42c0:	465a      	mov	r2, fp
    42c2:	4093      	lsls	r3, r2
    42c4:	001f      	movs	r7, r3
    42c6:	4653      	mov	r3, sl
    42c8:	4642      	mov	r2, r8
    42ca:	4093      	lsls	r3, r2
    42cc:	001e      	movs	r6, r3
    42ce:	42af      	cmp	r7, r5
    42d0:	d829      	bhi.n	4326 <__udivmoddi4+0xa2>
    42d2:	d026      	beq.n	4322 <__udivmoddi4+0x9e>
    42d4:	465b      	mov	r3, fp
    42d6:	1ba4      	subs	r4, r4, r6
    42d8:	41bd      	sbcs	r5, r7
    42da:	2b00      	cmp	r3, #0
    42dc:	da00      	bge.n	42e0 <__udivmoddi4+0x5c>
    42de:	e079      	b.n	43d4 <__udivmoddi4+0x150>
    42e0:	2200      	movs	r2, #0
    42e2:	2300      	movs	r3, #0
    42e4:	9200      	str	r2, [sp, #0]
    42e6:	9301      	str	r3, [sp, #4]
    42e8:	2301      	movs	r3, #1
    42ea:	465a      	mov	r2, fp
    42ec:	4093      	lsls	r3, r2
    42ee:	9301      	str	r3, [sp, #4]
    42f0:	2301      	movs	r3, #1
    42f2:	4642      	mov	r2, r8
    42f4:	4093      	lsls	r3, r2
    42f6:	9300      	str	r3, [sp, #0]
    42f8:	e019      	b.n	432e <__udivmoddi4+0xaa>
    42fa:	4282      	cmp	r2, r0
    42fc:	d9d0      	bls.n	42a0 <__udivmoddi4+0x1c>
    42fe:	2200      	movs	r2, #0
    4300:	2300      	movs	r3, #0
    4302:	9200      	str	r2, [sp, #0]
    4304:	9301      	str	r3, [sp, #4]
    4306:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    4308:	2b00      	cmp	r3, #0
    430a:	d001      	beq.n	4310 <__udivmoddi4+0x8c>
    430c:	601c      	str	r4, [r3, #0]
    430e:	605d      	str	r5, [r3, #4]
    4310:	9800      	ldr	r0, [sp, #0]
    4312:	9901      	ldr	r1, [sp, #4]
    4314:	b003      	add	sp, #12
    4316:	bc3c      	pop	{r2, r3, r4, r5}
    4318:	4690      	mov	r8, r2
    431a:	4699      	mov	r9, r3
    431c:	46a2      	mov	sl, r4
    431e:	46ab      	mov	fp, r5
    4320:	bdf0      	pop	{r4, r5, r6, r7, pc}
    4322:	42a3      	cmp	r3, r4
    4324:	d9d6      	bls.n	42d4 <__udivmoddi4+0x50>
    4326:	2200      	movs	r2, #0
    4328:	2300      	movs	r3, #0
    432a:	9200      	str	r2, [sp, #0]
    432c:	9301      	str	r3, [sp, #4]
    432e:	4643      	mov	r3, r8
    4330:	2b00      	cmp	r3, #0
    4332:	d0e8      	beq.n	4306 <__udivmoddi4+0x82>
    4334:	07fb      	lsls	r3, r7, #31
    4336:	0872      	lsrs	r2, r6, #1
    4338:	431a      	orrs	r2, r3
    433a:	4646      	mov	r6, r8
    433c:	087b      	lsrs	r3, r7, #1
    433e:	e00e      	b.n	435e <__udivmoddi4+0xda>
    4340:	42ab      	cmp	r3, r5
    4342:	d101      	bne.n	4348 <__udivmoddi4+0xc4>
    4344:	42a2      	cmp	r2, r4
    4346:	d80c      	bhi.n	4362 <__udivmoddi4+0xde>
    4348:	1aa4      	subs	r4, r4, r2
    434a:	419d      	sbcs	r5, r3
    434c:	2001      	movs	r0, #1
    434e:	1924      	adds	r4, r4, r4
    4350:	416d      	adcs	r5, r5
    4352:	2100      	movs	r1, #0
    4354:	3e01      	subs	r6, #1
    4356:	1824      	adds	r4, r4, r0
    4358:	414d      	adcs	r5, r1
    435a:	2e00      	cmp	r6, #0
    435c:	d006      	beq.n	436c <__udivmoddi4+0xe8>
    435e:	42ab      	cmp	r3, r5
    4360:	d9ee      	bls.n	4340 <__udivmoddi4+0xbc>
    4362:	3e01      	subs	r6, #1
    4364:	1924      	adds	r4, r4, r4
    4366:	416d      	adcs	r5, r5
    4368:	2e00      	cmp	r6, #0
    436a:	d1f8      	bne.n	435e <__udivmoddi4+0xda>
    436c:	465b      	mov	r3, fp
    436e:	9800      	ldr	r0, [sp, #0]
    4370:	9901      	ldr	r1, [sp, #4]
    4372:	1900      	adds	r0, r0, r4
    4374:	4169      	adcs	r1, r5
    4376:	2b00      	cmp	r3, #0
    4378:	db22      	blt.n	43c0 <__udivmoddi4+0x13c>
    437a:	002b      	movs	r3, r5
    437c:	465a      	mov	r2, fp
    437e:	40d3      	lsrs	r3, r2
    4380:	002a      	movs	r2, r5
    4382:	4644      	mov	r4, r8
    4384:	40e2      	lsrs	r2, r4
    4386:	001c      	movs	r4, r3
    4388:	465b      	mov	r3, fp
    438a:	0015      	movs	r5, r2
    438c:	2b00      	cmp	r3, #0
    438e:	db2c      	blt.n	43ea <__udivmoddi4+0x166>
    4390:	0026      	movs	r6, r4
    4392:	409e      	lsls	r6, r3
    4394:	0033      	movs	r3, r6
    4396:	0026      	movs	r6, r4
    4398:	4647      	mov	r7, r8
    439a:	40be      	lsls	r6, r7
    439c:	0032      	movs	r2, r6
    439e:	1a80      	subs	r0, r0, r2
    43a0:	4199      	sbcs	r1, r3
    43a2:	9000      	str	r0, [sp, #0]
    43a4:	9101      	str	r1, [sp, #4]
    43a6:	e7ae      	b.n	4306 <__udivmoddi4+0x82>
    43a8:	4642      	mov	r2, r8
    43aa:	2320      	movs	r3, #32
    43ac:	1a9b      	subs	r3, r3, r2
    43ae:	4652      	mov	r2, sl
    43b0:	40da      	lsrs	r2, r3
    43b2:	4641      	mov	r1, r8
    43b4:	0013      	movs	r3, r2
    43b6:	464a      	mov	r2, r9
    43b8:	408a      	lsls	r2, r1
    43ba:	0017      	movs	r7, r2
    43bc:	431f      	orrs	r7, r3
    43be:	e782      	b.n	42c6 <__udivmoddi4+0x42>
    43c0:	4642      	mov	r2, r8
    43c2:	2320      	movs	r3, #32
    43c4:	1a9b      	subs	r3, r3, r2
    43c6:	002a      	movs	r2, r5
    43c8:	4646      	mov	r6, r8
    43ca:	409a      	lsls	r2, r3
    43cc:	0023      	movs	r3, r4
    43ce:	40f3      	lsrs	r3, r6
    43d0:	4313      	orrs	r3, r2
    43d2:	e7d5      	b.n	4380 <__udivmoddi4+0xfc>
    43d4:	4642      	mov	r2, r8
    43d6:	2320      	movs	r3, #32
    43d8:	2100      	movs	r1, #0
    43da:	1a9b      	subs	r3, r3, r2
    43dc:	2200      	movs	r2, #0
    43de:	9100      	str	r1, [sp, #0]
    43e0:	9201      	str	r2, [sp, #4]
    43e2:	2201      	movs	r2, #1
    43e4:	40da      	lsrs	r2, r3
    43e6:	9201      	str	r2, [sp, #4]
    43e8:	e782      	b.n	42f0 <__udivmoddi4+0x6c>
    43ea:	4642      	mov	r2, r8
    43ec:	2320      	movs	r3, #32
    43ee:	0026      	movs	r6, r4
    43f0:	1a9b      	subs	r3, r3, r2
    43f2:	40de      	lsrs	r6, r3
    43f4:	002f      	movs	r7, r5
    43f6:	46b4      	mov	ip, r6
    43f8:	4097      	lsls	r7, r2
    43fa:	4666      	mov	r6, ip
    43fc:	003b      	movs	r3, r7
    43fe:	4333      	orrs	r3, r6
    4400:	e7c9      	b.n	4396 <__udivmoddi4+0x112>
    4402:	46c0      	nop			; (mov r8, r8)

00004404 <__clzdi2>:
    4404:	b510      	push	{r4, lr}
    4406:	2900      	cmp	r1, #0
    4408:	d103      	bne.n	4412 <__clzdi2+0xe>
    440a:	f000 f807 	bl	441c <__clzsi2>
    440e:	3020      	adds	r0, #32
    4410:	e002      	b.n	4418 <__clzdi2+0x14>
    4412:	1c08      	adds	r0, r1, #0
    4414:	f000 f802 	bl	441c <__clzsi2>
    4418:	bd10      	pop	{r4, pc}
    441a:	46c0      	nop			; (mov r8, r8)

0000441c <__clzsi2>:
    441c:	211c      	movs	r1, #28
    441e:	2301      	movs	r3, #1
    4420:	041b      	lsls	r3, r3, #16
    4422:	4298      	cmp	r0, r3
    4424:	d301      	bcc.n	442a <__clzsi2+0xe>
    4426:	0c00      	lsrs	r0, r0, #16
    4428:	3910      	subs	r1, #16
    442a:	0a1b      	lsrs	r3, r3, #8
    442c:	4298      	cmp	r0, r3
    442e:	d301      	bcc.n	4434 <__clzsi2+0x18>
    4430:	0a00      	lsrs	r0, r0, #8
    4432:	3908      	subs	r1, #8
    4434:	091b      	lsrs	r3, r3, #4
    4436:	4298      	cmp	r0, r3
    4438:	d301      	bcc.n	443e <__clzsi2+0x22>
    443a:	0900      	lsrs	r0, r0, #4
    443c:	3904      	subs	r1, #4
    443e:	a202      	add	r2, pc, #8	; (adr r2, 4448 <__clzsi2+0x2c>)
    4440:	5c10      	ldrb	r0, [r2, r0]
    4442:	1840      	adds	r0, r0, r1
    4444:	4770      	bx	lr
    4446:	46c0      	nop			; (mov r8, r8)
    4448:	02020304 	.word	0x02020304
    444c:	01010101 	.word	0x01010101
	...

00004458 <__libc_init_array>:
    4458:	b570      	push	{r4, r5, r6, lr}
    445a:	4e0d      	ldr	r6, [pc, #52]	; (4490 <__libc_init_array+0x38>)
    445c:	4d0d      	ldr	r5, [pc, #52]	; (4494 <__libc_init_array+0x3c>)
    445e:	2400      	movs	r4, #0
    4460:	1bad      	subs	r5, r5, r6
    4462:	10ad      	asrs	r5, r5, #2
    4464:	d005      	beq.n	4472 <__libc_init_array+0x1a>
    4466:	00a3      	lsls	r3, r4, #2
    4468:	58f3      	ldr	r3, [r6, r3]
    446a:	3401      	adds	r4, #1
    446c:	4798      	blx	r3
    446e:	42a5      	cmp	r5, r4
    4470:	d1f9      	bne.n	4466 <__libc_init_array+0xe>
    4472:	f000 fb07 	bl	4a84 <_init>
    4476:	4e08      	ldr	r6, [pc, #32]	; (4498 <__libc_init_array+0x40>)
    4478:	4d08      	ldr	r5, [pc, #32]	; (449c <__libc_init_array+0x44>)
    447a:	2400      	movs	r4, #0
    447c:	1bad      	subs	r5, r5, r6
    447e:	10ad      	asrs	r5, r5, #2
    4480:	d005      	beq.n	448e <__libc_init_array+0x36>
    4482:	00a3      	lsls	r3, r4, #2
    4484:	58f3      	ldr	r3, [r6, r3]
    4486:	3401      	adds	r4, #1
    4488:	4798      	blx	r3
    448a:	42a5      	cmp	r5, r4
    448c:	d1f9      	bne.n	4482 <__libc_init_array+0x2a>
    448e:	bd70      	pop	{r4, r5, r6, pc}
    4490:	00004a90 	.word	0x00004a90
    4494:	00004a90 	.word	0x00004a90
    4498:	00004a90 	.word	0x00004a90
    449c:	00004a98 	.word	0x00004a98

000044a0 <register_fini>:
    44a0:	4b03      	ldr	r3, [pc, #12]	; (44b0 <register_fini+0x10>)
    44a2:	b510      	push	{r4, lr}
    44a4:	2b00      	cmp	r3, #0
    44a6:	d002      	beq.n	44ae <register_fini+0xe>
    44a8:	4802      	ldr	r0, [pc, #8]	; (44b4 <register_fini+0x14>)
    44aa:	f000 f805 	bl	44b8 <atexit>
    44ae:	bd10      	pop	{r4, pc}
    44b0:	00000000 	.word	0x00000000
    44b4:	000044c9 	.word	0x000044c9

000044b8 <atexit>:
    44b8:	b510      	push	{r4, lr}
    44ba:	0001      	movs	r1, r0
    44bc:	2300      	movs	r3, #0
    44be:	2200      	movs	r2, #0
    44c0:	2000      	movs	r0, #0
    44c2:	f000 f81f 	bl	4504 <__register_exitproc>
    44c6:	bd10      	pop	{r4, pc}

000044c8 <__libc_fini_array>:
    44c8:	b570      	push	{r4, r5, r6, lr}
    44ca:	4b09      	ldr	r3, [pc, #36]	; (44f0 <__libc_fini_array+0x28>)
    44cc:	4c09      	ldr	r4, [pc, #36]	; (44f4 <__libc_fini_array+0x2c>)
    44ce:	1ae4      	subs	r4, r4, r3
    44d0:	10a4      	asrs	r4, r4, #2
    44d2:	d009      	beq.n	44e8 <__libc_fini_array+0x20>
    44d4:	4a08      	ldr	r2, [pc, #32]	; (44f8 <__libc_fini_array+0x30>)
    44d6:	18a5      	adds	r5, r4, r2
    44d8:	00ad      	lsls	r5, r5, #2
    44da:	18ed      	adds	r5, r5, r3
    44dc:	682b      	ldr	r3, [r5, #0]
    44de:	3c01      	subs	r4, #1
    44e0:	4798      	blx	r3
    44e2:	3d04      	subs	r5, #4
    44e4:	2c00      	cmp	r4, #0
    44e6:	d1f9      	bne.n	44dc <__libc_fini_array+0x14>
    44e8:	f000 fad6 	bl	4a98 <_fini>
    44ec:	bd70      	pop	{r4, r5, r6, pc}
    44ee:	46c0      	nop			; (mov r8, r8)
    44f0:	00004aa4 	.word	0x00004aa4
    44f4:	00004aa8 	.word	0x00004aa8
    44f8:	3fffffff 	.word	0x3fffffff

000044fc <__retarget_lock_acquire_recursive>:
    44fc:	4770      	bx	lr
    44fe:	46c0      	nop			; (mov r8, r8)

00004500 <__retarget_lock_release_recursive>:
    4500:	4770      	bx	lr
    4502:	46c0      	nop			; (mov r8, r8)

00004504 <__register_exitproc>:
    4504:	b5f0      	push	{r4, r5, r6, r7, lr}
    4506:	464e      	mov	r6, r9
    4508:	4645      	mov	r5, r8
    450a:	46de      	mov	lr, fp
    450c:	4657      	mov	r7, sl
    450e:	b5e0      	push	{r5, r6, r7, lr}
    4510:	4d36      	ldr	r5, [pc, #216]	; (45ec <__register_exitproc+0xe8>)
    4512:	b083      	sub	sp, #12
    4514:	0006      	movs	r6, r0
    4516:	6828      	ldr	r0, [r5, #0]
    4518:	4698      	mov	r8, r3
    451a:	000f      	movs	r7, r1
    451c:	4691      	mov	r9, r2
    451e:	f7ff ffed 	bl	44fc <__retarget_lock_acquire_recursive>
    4522:	4b33      	ldr	r3, [pc, #204]	; (45f0 <__register_exitproc+0xec>)
    4524:	681c      	ldr	r4, [r3, #0]
    4526:	23a4      	movs	r3, #164	; 0xa4
    4528:	005b      	lsls	r3, r3, #1
    452a:	58e0      	ldr	r0, [r4, r3]
    452c:	2800      	cmp	r0, #0
    452e:	d052      	beq.n	45d6 <__register_exitproc+0xd2>
    4530:	6843      	ldr	r3, [r0, #4]
    4532:	2b1f      	cmp	r3, #31
    4534:	dc13      	bgt.n	455e <__register_exitproc+0x5a>
    4536:	1c5a      	adds	r2, r3, #1
    4538:	9201      	str	r2, [sp, #4]
    453a:	2e00      	cmp	r6, #0
    453c:	d128      	bne.n	4590 <__register_exitproc+0x8c>
    453e:	9a01      	ldr	r2, [sp, #4]
    4540:	3302      	adds	r3, #2
    4542:	009b      	lsls	r3, r3, #2
    4544:	6042      	str	r2, [r0, #4]
    4546:	501f      	str	r7, [r3, r0]
    4548:	6828      	ldr	r0, [r5, #0]
    454a:	f7ff ffd9 	bl	4500 <__retarget_lock_release_recursive>
    454e:	2000      	movs	r0, #0
    4550:	b003      	add	sp, #12
    4552:	bc3c      	pop	{r2, r3, r4, r5}
    4554:	4690      	mov	r8, r2
    4556:	4699      	mov	r9, r3
    4558:	46a2      	mov	sl, r4
    455a:	46ab      	mov	fp, r5
    455c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    455e:	4b25      	ldr	r3, [pc, #148]	; (45f4 <__register_exitproc+0xf0>)
    4560:	2b00      	cmp	r3, #0
    4562:	d03d      	beq.n	45e0 <__register_exitproc+0xdc>
    4564:	20c8      	movs	r0, #200	; 0xc8
    4566:	0040      	lsls	r0, r0, #1
    4568:	e000      	b.n	456c <__register_exitproc+0x68>
    456a:	bf00      	nop
    456c:	2800      	cmp	r0, #0
    456e:	d037      	beq.n	45e0 <__register_exitproc+0xdc>
    4570:	22a4      	movs	r2, #164	; 0xa4
    4572:	2300      	movs	r3, #0
    4574:	0052      	lsls	r2, r2, #1
    4576:	58a1      	ldr	r1, [r4, r2]
    4578:	6043      	str	r3, [r0, #4]
    457a:	6001      	str	r1, [r0, #0]
    457c:	50a0      	str	r0, [r4, r2]
    457e:	3240      	adds	r2, #64	; 0x40
    4580:	5083      	str	r3, [r0, r2]
    4582:	3204      	adds	r2, #4
    4584:	5083      	str	r3, [r0, r2]
    4586:	3301      	adds	r3, #1
    4588:	9301      	str	r3, [sp, #4]
    458a:	2300      	movs	r3, #0
    458c:	2e00      	cmp	r6, #0
    458e:	d0d6      	beq.n	453e <__register_exitproc+0x3a>
    4590:	009a      	lsls	r2, r3, #2
    4592:	4692      	mov	sl, r2
    4594:	4482      	add	sl, r0
    4596:	464a      	mov	r2, r9
    4598:	2188      	movs	r1, #136	; 0x88
    459a:	4654      	mov	r4, sl
    459c:	5062      	str	r2, [r4, r1]
    459e:	22c4      	movs	r2, #196	; 0xc4
    45a0:	0052      	lsls	r2, r2, #1
    45a2:	4691      	mov	r9, r2
    45a4:	4481      	add	r9, r0
    45a6:	464a      	mov	r2, r9
    45a8:	3987      	subs	r1, #135	; 0x87
    45aa:	4099      	lsls	r1, r3
    45ac:	6812      	ldr	r2, [r2, #0]
    45ae:	468b      	mov	fp, r1
    45b0:	430a      	orrs	r2, r1
    45b2:	4694      	mov	ip, r2
    45b4:	464a      	mov	r2, r9
    45b6:	4661      	mov	r1, ip
    45b8:	6011      	str	r1, [r2, #0]
    45ba:	2284      	movs	r2, #132	; 0x84
    45bc:	4641      	mov	r1, r8
    45be:	0052      	lsls	r2, r2, #1
    45c0:	50a1      	str	r1, [r4, r2]
    45c2:	2e02      	cmp	r6, #2
    45c4:	d1bb      	bne.n	453e <__register_exitproc+0x3a>
    45c6:	0002      	movs	r2, r0
    45c8:	465c      	mov	r4, fp
    45ca:	328d      	adds	r2, #141	; 0x8d
    45cc:	32ff      	adds	r2, #255	; 0xff
    45ce:	6811      	ldr	r1, [r2, #0]
    45d0:	430c      	orrs	r4, r1
    45d2:	6014      	str	r4, [r2, #0]
    45d4:	e7b3      	b.n	453e <__register_exitproc+0x3a>
    45d6:	0020      	movs	r0, r4
    45d8:	304d      	adds	r0, #77	; 0x4d
    45da:	30ff      	adds	r0, #255	; 0xff
    45dc:	50e0      	str	r0, [r4, r3]
    45de:	e7a7      	b.n	4530 <__register_exitproc+0x2c>
    45e0:	6828      	ldr	r0, [r5, #0]
    45e2:	f7ff ff8d 	bl	4500 <__retarget_lock_release_recursive>
    45e6:	2001      	movs	r0, #1
    45e8:	4240      	negs	r0, r0
    45ea:	e7b1      	b.n	4550 <__register_exitproc+0x4c>
    45ec:	20000438 	.word	0x20000438
    45f0:	00004a80 	.word	0x00004a80
    45f4:	00000000 	.word	0x00000000
    45f8:	74696e49 	.word	0x74696e49
    45fc:	696c6169 	.word	0x696c6169
    4600:	676e697a 	.word	0x676e697a
    4604:	49505320 	.word	0x49505320
    4608:	206e6920 	.word	0x206e6920
    460c:	776f6c73 	.word	0x776f6c73
    4610:	646f6d20 	.word	0x646f6d20
    4614:	00000a65 	.word	0x00000a65
    4618:	20495053 	.word	0x20495053
    461c:	74696e69 	.word	0x74696e69
    4620:	696c6169 	.word	0x696c6169
    4624:	6974617a 	.word	0x6974617a
    4628:	64206e6f 	.word	0x64206e6f
    462c:	0a656e6f 	.word	0x0a656e6f
    4630:	00000000 	.word	0x00000000
    4634:	72617453 	.word	0x72617453
    4638:	676e6974 	.word	0x676e6974
    463c:	20445320 	.word	0x20445320
    4640:	64726163 	.word	0x64726163
    4644:	696e6920 	.word	0x696e6920
    4648:	6c616974 	.word	0x6c616974
    464c:	74617a69 	.word	0x74617a69
    4650:	0a6e6f69 	.word	0x0a6e6f69
    4654:	00000000 	.word	0x00000000
    4658:	6c6c6548 	.word	0x6c6c6548
    465c:	6f68206f 	.word	0x6f68206f
    4660:	72612077 	.word	0x72612077
    4664:	3f752065 	.word	0x3f752065
    4668:	0000000a 	.word	0x0000000a
    466c:	63204453 	.word	0x63204453
    4670:	20647261 	.word	0x20647261
    4674:	74696e69 	.word	0x74696e69
    4678:	696c6169 	.word	0x696c6169
    467c:	6974617a 	.word	0x6974617a
    4680:	64206e6f 	.word	0x64206e6f
    4684:	0a656e6f 	.word	0x0a656e6f
    4688:	00000000 	.word	0x00000000
    468c:	6e756f4d 	.word	0x6e756f4d
    4690:	676e6974 	.word	0x676e6974
    4694:	6c696620 	.word	0x6c696620
    4698:	79732065 	.word	0x79732065
    469c:	6d657473 	.word	0x6d657473
    46a0:	0000000a 	.word	0x0000000a
    46a4:	656c6946 	.word	0x656c6946
    46a8:	73797320 	.word	0x73797320
    46ac:	206d6574 	.word	0x206d6574
    46b0:	6e756f6d 	.word	0x6e756f6d
    46b4:	0a646574 	.word	0x0a646574
    46b8:	00000000 	.word	0x00000000
    46bc:	6f727245 	.word	0x6f727245
    46c0:	6f6d2072 	.word	0x6f6d2072
    46c4:	69746e75 	.word	0x69746e75
    46c8:	6620676e 	.word	0x6620676e
    46cc:	20656c69 	.word	0x20656c69
    46d0:	74737973 	.word	0x74737973
    46d4:	000a6d65 	.word	0x000a6d65
    46d8:	6e65704f 	.word	0x6e65704f
    46dc:	20676e69 	.word	0x20676e69
    46e0:	656c6966 	.word	0x656c6966
    46e4:	726f6620 	.word	0x726f6620
    46e8:	69727720 	.word	0x69727720
    46ec:	676e6974 	.word	0x676e6974
    46f0:	0000000a 	.word	0x0000000a
    46f4:	6f727245 	.word	0x6f727245
    46f8:	706f2072 	.word	0x706f2072
    46fc:	6e696e65 	.word	0x6e696e65
    4700:	69662067 	.word	0x69662067
    4704:	000a656c 	.word	0x000a656c
    4708:	656c6946 	.word	0x656c6946
    470c:	65706f20 	.word	0x65706f20
    4710:	2064656e 	.word	0x2064656e
    4714:	63637573 	.word	0x63637573
    4718:	66737365 	.word	0x66737365
    471c:	796c6c75 	.word	0x796c6c75
    4720:	0000000a 	.word	0x0000000a
    4724:	74697257 	.word	0x74697257
    4728:	20676e69 	.word	0x20676e69
    472c:	66206f74 	.word	0x66206f74
    4730:	0a656c69 	.word	0x0a656c69
    4734:	00000000 	.word	0x00000000
    4738:	61746144 	.word	0x61746144
    473c:	442c2031 	.word	0x442c2031
    4740:	32617461 	.word	0x32617461
    4744:	61442c20 	.word	0x61442c20
    4748:	20336174 	.word	0x20336174
    474c:	7461442c 	.word	0x7461442c
    4750:	0d203461 	.word	0x0d203461
    4754:	0000000a 	.word	0x0000000a
    4758:	6f727245 	.word	0x6f727245
    475c:	72772072 	.word	0x72772072
    4760:	6e697469 	.word	0x6e697469
    4764:	6f742067 	.word	0x6f742067
    4768:	6c696620 	.word	0x6c696620
    476c:	00000a65 	.word	0x00000a65
    4770:	74697257 	.word	0x74697257
    4774:	20676e69 	.word	0x20676e69
    4778:	706d6f63 	.word	0x706d6f63
    477c:	6574656c 	.word	0x6574656c
    4780:	00000a64 	.word	0x00000a64
    4784:	736f6c43 	.word	0x736f6c43
    4788:	20676e69 	.word	0x20676e69
    478c:	656c6966 	.word	0x656c6966
    4790:	0000000a 	.word	0x0000000a
    4794:	6f727245 	.word	0x6f727245
    4798:	6c632072 	.word	0x6c632072
    479c:	6e69736f 	.word	0x6e69736f
    47a0:	69662067 	.word	0x69662067
    47a4:	000a656c 	.word	0x000a656c
    47a8:	656c6946 	.word	0x656c6946
    47ac:	6f6c6320 	.word	0x6f6c6320
    47b0:	20646573 	.word	0x20646573
    47b4:	63637573 	.word	0x63637573
    47b8:	66737365 	.word	0x66737365
    47bc:	796c6c75 	.word	0x796c6c75
    47c0:	0000000a 	.word	0x0000000a
    47c4:	63637553 	.word	0x63637553
    47c8:	66737365 	.word	0x66737365
    47cc:	57206c75 	.word	0x57206c75
    47d0:	65746972 	.word	0x65746972
    47d4:	6c694620 	.word	0x6c694620
    47d8:	6f442065 	.word	0x6f442065
    47dc:	0a21656e 	.word	0x0a21656e
    47e0:	00000000 	.word	0x00000000
    47e4:	72617453 	.word	0x72617453
    47e8:	676e6974 	.word	0x676e6974
    47ec:	206f7420 	.word	0x206f7420
    47f0:	64616572 	.word	0x64616572
    47f4:	6c696620 	.word	0x6c696620
    47f8:	00000a65 	.word	0x00000a65
    47fc:	6f727245 	.word	0x6f727245
    4800:	706f2072 	.word	0x706f2072
    4804:	6e696e65 	.word	0x6e696e65
    4808:	69662067 	.word	0x69662067
    480c:	6620656c 	.word	0x6620656c
    4810:	7220726f 	.word	0x7220726f
    4814:	69646165 	.word	0x69646165
    4818:	000a676e 	.word	0x000a676e
    481c:	656c6946 	.word	0x656c6946
    4820:	65706f20 	.word	0x65706f20
    4824:	2064656e 	.word	0x2064656e
    4828:	20726f66 	.word	0x20726f66
    482c:	64616572 	.word	0x64616572
    4830:	0a676e69 	.word	0x0a676e69
    4834:	00000000 	.word	0x00000000
    4838:	20656854 	.word	0x20656854
    483c:	656c6966 	.word	0x656c6966
    4840:	6e6f6320 	.word	0x6e6f6320
    4844:	6e696174 	.word	0x6e696174
    4848:	0a203a73 	.word	0x0a203a73
    484c:	00000000 	.word	0x00000000
    4850:	64616552 	.word	0x64616552
    4854:	20676e69 	.word	0x20676e69
    4858:	706d6f63 	.word	0x706d6f63
    485c:	6574656c 	.word	0x6574656c
    4860:	00000a64 	.word	0x00000a64
    4864:	736f6c43 	.word	0x736f6c43
    4868:	20676e69 	.word	0x20676e69
    486c:	656c6966 	.word	0x656c6966
    4870:	74666120 	.word	0x74666120
    4874:	72207265 	.word	0x72207265
    4878:	69646165 	.word	0x69646165
    487c:	000a676e 	.word	0x000a676e
    4880:	6f727245 	.word	0x6f727245
    4884:	6c632072 	.word	0x6c632072
    4888:	6e69736f 	.word	0x6e69736f
    488c:	69662067 	.word	0x69662067
    4890:	6120656c 	.word	0x6120656c
    4894:	72657466 	.word	0x72657466
    4898:	61657220 	.word	0x61657220
    489c:	676e6964 	.word	0x676e6964
    48a0:	0000000a 	.word	0x0000000a
    48a4:	656c6946 	.word	0x656c6946
    48a8:	6f6c6320 	.word	0x6f6c6320
    48ac:	20646573 	.word	0x20646573
    48b0:	63637573 	.word	0x63637573
    48b4:	66737365 	.word	0x66737365
    48b8:	796c6c75 	.word	0x796c6c75
    48bc:	74666120 	.word	0x74666120
    48c0:	72207265 	.word	0x72207265
    48c4:	69646165 	.word	0x69646165
    48c8:	000a676e 	.word	0x000a676e
    48cc:	64616572 	.word	0x64616572
    48d0:	0a203220 	.word	0x0a203220
    48d4:	00000000 	.word	0x00000000
    48d8:	74697277 	.word	0x74697277
    48dc:	20312065 	.word	0x20312065
    48e0:	0000000a 	.word	0x0000000a
    48e4:	74697277 	.word	0x74697277
    48e8:	20322065 	.word	0x20322065
    48ec:	0000000a 	.word	0x0000000a
    48f0:	2c2b2a22 	.word	0x2c2b2a22
    48f4:	3d3c3b3a 	.word	0x3d3c3b3a
    48f8:	5d5b3f3e 	.word	0x5d5b3f3e
    48fc:	00007f7c 	.word	0x00007f7c
    4900:	64616552 	.word	0x64616552
    4904:	69617720 	.word	0x69617720
    4908:	69742074 	.word	0x69742074
    490c:	756f656d 	.word	0x756f656d
    4910:	00000a74 	.word	0x00000a74
    4914:	64616552 	.word	0x64616552
    4918:	61772079 	.word	0x61772079
    491c:	74207469 	.word	0x74207469
    4920:	6f656d69 	.word	0x6f656d69
    4924:	000a7475 	.word	0x000a7475
    4928:	6d6d6f43 	.word	0x6d6d6f43
    492c:	20646e61 	.word	0x20646e61
    4930:	70736572 	.word	0x70736572
    4934:	65736e6f 	.word	0x65736e6f
    4938:	6d697420 	.word	0x6d697420
    493c:	74756f65 	.word	0x74756f65
    4940:	0000000a 	.word	0x0000000a
    4944:	64726143 	.word	0x64726143
    4948:	70795420 	.word	0x70795420
    494c:	56203a65 	.word	0x56203a65
    4950:	0a302e32 	.word	0x0a302e32
    4954:	00000000 	.word	0x00000000
    4958:	64726143 	.word	0x64726143
    495c:	3256203a 	.word	0x3256203a
    4960:	5320302e 	.word	0x5320302e
    4964:	0a434844 	.word	0x0a434844
    4968:	00000000 	.word	0x00000000
    496c:	646e6553 	.word	0x646e6553
    4970:	20676e69 	.word	0x20676e69
    4974:	30444d43 	.word	0x30444d43
    4978:	0a2e2e2e 	.word	0x0a2e2e2e
    497c:	00000000 	.word	0x00000000
    4980:	6c696146 	.word	0x6c696146
    4984:	74206465 	.word	0x74206465
    4988:	6572206f 	.word	0x6572206f
    498c:	20746573 	.word	0x20746573
    4990:	64726163 	.word	0x64726163
    4994:	74666120 	.word	0x74666120
    4998:	32207265 	.word	0x32207265
    499c:	72203030 	.word	0x72203030
    49a0:	69727465 	.word	0x69727465
    49a4:	000a7365 	.word	0x000a7365
    49a8:	6c696146 	.word	0x6c696146
    49ac:	74206465 	.word	0x74206465
    49b0:	6572206f 	.word	0x6572206f
    49b4:	20746573 	.word	0x20746573
    49b8:	64726163 	.word	0x64726163
    49bc:	0000000a 	.word	0x0000000a
    49c0:	64726143 	.word	0x64726143
    49c4:	73657220 	.word	0x73657220
    49c8:	73207465 	.word	0x73207465
    49cc:	65636375 	.word	0x65636375
    49d0:	75667373 	.word	0x75667373
    49d4:	00000a6c 	.word	0x00000a6c
    49d8:	656d6954 	.word	0x656d6954
    49dc:	2074756f 	.word	0x2074756f
    49e0:	69727564 	.word	0x69727564
    49e4:	6920676e 	.word	0x6920676e
    49e8:	6974696e 	.word	0x6974696e
    49ec:	7a696c61 	.word	0x7a696c61
    49f0:	6f697461 	.word	0x6f697461
    49f4:	00000a6e 	.word	0x00000a6e
    49f8:	6f727245 	.word	0x6f727245
    49fc:	65722072 	.word	0x65722072
    4a00:	6e696461 	.word	0x6e696461
    4a04:	434f2067 	.word	0x434f2067
    4a08:	00000a52 	.word	0x00000a52
    4a0c:	75736e55 	.word	0x75736e55
    4a10:	726f7070 	.word	0x726f7070
    4a14:	20646574 	.word	0x20646574
    4a18:	63204453 	.word	0x63204453
    4a1c:	20647261 	.word	0x20647261
    4a20:	65707974 	.word	0x65707974
    4a24:	0000000a 	.word	0x0000000a
    4a28:	6f727245 	.word	0x6f727245
    4a2c:	65732072 	.word	0x65732072
    4a30:	6e697474 	.word	0x6e697474
    4a34:	6c622067 	.word	0x6c622067
    4a38:	206b636f 	.word	0x206b636f
    4a3c:	676e656c 	.word	0x676e656c
    4a40:	000a6874 	.word	0x000a6874
    4a44:	74696e49 	.word	0x74696e49
    4a48:	696c6169 	.word	0x696c6169
    4a4c:	6974617a 	.word	0x6974617a
    4a50:	63206e6f 	.word	0x63206e6f
    4a54:	6c706d6f 	.word	0x6c706d6f
    4a58:	0a657465 	.word	0x0a657465
    4a5c:	00000000 	.word	0x00000000
    4a60:	30444d43 	.word	0x30444d43
    4a64:	63757320 	.word	0x63757320
    4a68:	73736563 	.word	0x73736563
    4a6c:	0000000a 	.word	0x0000000a
    4a70:	30444d43 	.word	0x30444d43
    4a74:	69616620 	.word	0x69616620
    4a78:	0a64656c 	.word	0x0a64656c
    4a7c:	00000000 	.word	0x00000000

00004a80 <_global_impure_ptr>:
    4a80:	20000010                                ... 

00004a84 <_init>:
    4a84:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    4a86:	46c0      	nop			; (mov r8, r8)
    4a88:	bcf8      	pop	{r3, r4, r5, r6, r7}
    4a8a:	bc08      	pop	{r3}
    4a8c:	469e      	mov	lr, r3
    4a8e:	4770      	bx	lr

00004a90 <__init_array_start>:
    4a90:	000044a1 	.word	0x000044a1

00004a94 <__frame_dummy_init_array_entry>:
    4a94:	000020dd                                . ..

00004a98 <_fini>:
    4a98:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    4a9a:	46c0      	nop			; (mov r8, r8)
    4a9c:	bcf8      	pop	{r3, r4, r5, r6, r7}
    4a9e:	bc08      	pop	{r3}
    4aa0:	469e      	mov	lr, r3
    4aa2:	4770      	bx	lr

00004aa4 <__fini_array_start>:
    4aa4:	000020b5 	.word	0x000020b5
